package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i fisherman/internal/configuration.Rule -o ./testing/mocks/rule_mock.go -n RuleMock

import (
	"context"
	"fisherman/internal/rules"
	"io"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// RuleMock implements configuration.Rule
type RuleMock struct {
	t minimock.Tester

	funcCheck          func(ctx context.Context, w1 io.Writer) (err error)
	inspectFuncCheck   func(ctx context.Context, w1 io.Writer)
	afterCheckCounter  uint64
	beforeCheckCounter uint64
	CheckMock          mRuleMockCheck

	funcCompile          func(m1 map[string]interface{})
	inspectFuncCompile   func(m1 map[string]interface{})
	afterCompileCounter  uint64
	beforeCompileCounter uint64
	CompileMock          mRuleMockCompile

	funcGetContition          func() (s1 string)
	inspectFuncGetContition   func()
	afterGetContitionCounter  uint64
	beforeGetContitionCounter uint64
	GetContitionMock          mRuleMockGetContition

	funcGetPosition          func() (b1 byte)
	inspectFuncGetPosition   func()
	afterGetPositionCounter  uint64
	beforeGetPositionCounter uint64
	GetPositionMock          mRuleMockGetPosition

	funcGetPrefix          func() (s1 string)
	inspectFuncGetPrefix   func()
	afterGetPrefixCounter  uint64
	beforeGetPrefixCounter uint64
	GetPrefixMock          mRuleMockGetPrefix

	funcGetType          func() (s1 string)
	inspectFuncGetType   func()
	afterGetTypeCounter  uint64
	beforeGetTypeCounter uint64
	GetTypeMock          mRuleMockGetType

	funcInit          func(options ...rules.RuleOption)
	inspectFuncInit   func(options ...rules.RuleOption)
	afterInitCounter  uint64
	beforeInitCounter uint64
	InitMock          mRuleMockInit
}

// NewRuleMock returns a mock for configuration.Rule
func NewRuleMock(t minimock.Tester) *RuleMock {
	m := &RuleMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CheckMock = mRuleMockCheck{mock: m}
	m.CheckMock.callArgs = []*RuleMockCheckParams{}

	m.CompileMock = mRuleMockCompile{mock: m}
	m.CompileMock.callArgs = []*RuleMockCompileParams{}

	m.GetContitionMock = mRuleMockGetContition{mock: m}

	m.GetPositionMock = mRuleMockGetPosition{mock: m}

	m.GetPrefixMock = mRuleMockGetPrefix{mock: m}

	m.GetTypeMock = mRuleMockGetType{mock: m}

	m.InitMock = mRuleMockInit{mock: m}
	m.InitMock.callArgs = []*RuleMockInitParams{}

	return m
}

type mRuleMockCheck struct {
	mock               *RuleMock
	defaultExpectation *RuleMockCheckExpectation
	expectations       []*RuleMockCheckExpectation

	callArgs []*RuleMockCheckParams
	mutex    sync.RWMutex
}

// RuleMockCheckExpectation specifies expectation struct of the Rule.Check
type RuleMockCheckExpectation struct {
	mock    *RuleMock
	params  *RuleMockCheckParams
	results *RuleMockCheckResults
	Counter uint64
}

// RuleMockCheckParams contains parameters of the Rule.Check
type RuleMockCheckParams struct {
	ctx context.Context
	w1  io.Writer
}

// RuleMockCheckResults contains results of the Rule.Check
type RuleMockCheckResults struct {
	err error
}

// Expect sets up expected params for Rule.Check
func (mmCheck *mRuleMockCheck) Expect(ctx context.Context, w1 io.Writer) *mRuleMockCheck {
	if mmCheck.mock.funcCheck != nil {
		mmCheck.mock.t.Fatalf("RuleMock.Check mock is already set by Set")
	}

	if mmCheck.defaultExpectation == nil {
		mmCheck.defaultExpectation = &RuleMockCheckExpectation{}
	}

	mmCheck.defaultExpectation.params = &RuleMockCheckParams{ctx, w1}
	for _, e := range mmCheck.expectations {
		if minimock.Equal(e.params, mmCheck.defaultExpectation.params) {
			mmCheck.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCheck.defaultExpectation.params)
		}
	}

	return mmCheck
}

// Inspect accepts an inspector function that has same arguments as the Rule.Check
func (mmCheck *mRuleMockCheck) Inspect(f func(ctx context.Context, w1 io.Writer)) *mRuleMockCheck {
	if mmCheck.mock.inspectFuncCheck != nil {
		mmCheck.mock.t.Fatalf("Inspect function is already set for RuleMock.Check")
	}

	mmCheck.mock.inspectFuncCheck = f

	return mmCheck
}

// Return sets up results that will be returned by Rule.Check
func (mmCheck *mRuleMockCheck) Return(err error) *RuleMock {
	if mmCheck.mock.funcCheck != nil {
		mmCheck.mock.t.Fatalf("RuleMock.Check mock is already set by Set")
	}

	if mmCheck.defaultExpectation == nil {
		mmCheck.defaultExpectation = &RuleMockCheckExpectation{mock: mmCheck.mock}
	}
	mmCheck.defaultExpectation.results = &RuleMockCheckResults{err}
	return mmCheck.mock
}

//Set uses given function f to mock the Rule.Check method
func (mmCheck *mRuleMockCheck) Set(f func(ctx context.Context, w1 io.Writer) (err error)) *RuleMock {
	if mmCheck.defaultExpectation != nil {
		mmCheck.mock.t.Fatalf("Default expectation is already set for the Rule.Check method")
	}

	if len(mmCheck.expectations) > 0 {
		mmCheck.mock.t.Fatalf("Some expectations are already set for the Rule.Check method")
	}

	mmCheck.mock.funcCheck = f
	return mmCheck.mock
}

// When sets expectation for the Rule.Check which will trigger the result defined by the following
// Then helper
func (mmCheck *mRuleMockCheck) When(ctx context.Context, w1 io.Writer) *RuleMockCheckExpectation {
	if mmCheck.mock.funcCheck != nil {
		mmCheck.mock.t.Fatalf("RuleMock.Check mock is already set by Set")
	}

	expectation := &RuleMockCheckExpectation{
		mock:   mmCheck.mock,
		params: &RuleMockCheckParams{ctx, w1},
	}
	mmCheck.expectations = append(mmCheck.expectations, expectation)
	return expectation
}

// Then sets up Rule.Check return parameters for the expectation previously defined by the When method
func (e *RuleMockCheckExpectation) Then(err error) *RuleMock {
	e.results = &RuleMockCheckResults{err}
	return e.mock
}

// Check implements configuration.Rule
func (mmCheck *RuleMock) Check(ctx context.Context, w1 io.Writer) (err error) {
	mm_atomic.AddUint64(&mmCheck.beforeCheckCounter, 1)
	defer mm_atomic.AddUint64(&mmCheck.afterCheckCounter, 1)

	if mmCheck.inspectFuncCheck != nil {
		mmCheck.inspectFuncCheck(ctx, w1)
	}

	mm_params := &RuleMockCheckParams{ctx, w1}

	// Record call args
	mmCheck.CheckMock.mutex.Lock()
	mmCheck.CheckMock.callArgs = append(mmCheck.CheckMock.callArgs, mm_params)
	mmCheck.CheckMock.mutex.Unlock()

	for _, e := range mmCheck.CheckMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCheck.CheckMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCheck.CheckMock.defaultExpectation.Counter, 1)
		mm_want := mmCheck.CheckMock.defaultExpectation.params
		mm_got := RuleMockCheckParams{ctx, w1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCheck.t.Errorf("RuleMock.Check got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCheck.CheckMock.defaultExpectation.results
		if mm_results == nil {
			mmCheck.t.Fatal("No results are set for the RuleMock.Check")
		}
		return (*mm_results).err
	}
	if mmCheck.funcCheck != nil {
		return mmCheck.funcCheck(ctx, w1)
	}
	mmCheck.t.Fatalf("Unexpected call to RuleMock.Check. %v %v", ctx, w1)
	return
}

// CheckAfterCounter returns a count of finished RuleMock.Check invocations
func (mmCheck *RuleMock) CheckAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheck.afterCheckCounter)
}

// CheckBeforeCounter returns a count of RuleMock.Check invocations
func (mmCheck *RuleMock) CheckBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheck.beforeCheckCounter)
}

// Calls returns a list of arguments used in each call to RuleMock.Check.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCheck *mRuleMockCheck) Calls() []*RuleMockCheckParams {
	mmCheck.mutex.RLock()

	argCopy := make([]*RuleMockCheckParams, len(mmCheck.callArgs))
	copy(argCopy, mmCheck.callArgs)

	mmCheck.mutex.RUnlock()

	return argCopy
}

// MinimockCheckDone returns true if the count of the Check invocations corresponds
// the number of defined expectations
func (m *RuleMock) MinimockCheckDone() bool {
	for _, e := range m.CheckMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CheckMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCheckCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCheck != nil && mm_atomic.LoadUint64(&m.afterCheckCounter) < 1 {
		return false
	}
	return true
}

// MinimockCheckInspect logs each unmet expectation
func (m *RuleMock) MinimockCheckInspect() {
	for _, e := range m.CheckMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RuleMock.Check with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CheckMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCheckCounter) < 1 {
		if m.CheckMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RuleMock.Check")
		} else {
			m.t.Errorf("Expected call to RuleMock.Check with params: %#v", *m.CheckMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCheck != nil && mm_atomic.LoadUint64(&m.afterCheckCounter) < 1 {
		m.t.Error("Expected call to RuleMock.Check")
	}
}

type mRuleMockCompile struct {
	mock               *RuleMock
	defaultExpectation *RuleMockCompileExpectation
	expectations       []*RuleMockCompileExpectation

	callArgs []*RuleMockCompileParams
	mutex    sync.RWMutex
}

// RuleMockCompileExpectation specifies expectation struct of the Rule.Compile
type RuleMockCompileExpectation struct {
	mock   *RuleMock
	params *RuleMockCompileParams

	Counter uint64
}

// RuleMockCompileParams contains parameters of the Rule.Compile
type RuleMockCompileParams struct {
	m1 map[string]interface{}
}

// Expect sets up expected params for Rule.Compile
func (mmCompile *mRuleMockCompile) Expect(m1 map[string]interface{}) *mRuleMockCompile {
	if mmCompile.mock.funcCompile != nil {
		mmCompile.mock.t.Fatalf("RuleMock.Compile mock is already set by Set")
	}

	if mmCompile.defaultExpectation == nil {
		mmCompile.defaultExpectation = &RuleMockCompileExpectation{}
	}

	mmCompile.defaultExpectation.params = &RuleMockCompileParams{m1}
	for _, e := range mmCompile.expectations {
		if minimock.Equal(e.params, mmCompile.defaultExpectation.params) {
			mmCompile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCompile.defaultExpectation.params)
		}
	}

	return mmCompile
}

// Inspect accepts an inspector function that has same arguments as the Rule.Compile
func (mmCompile *mRuleMockCompile) Inspect(f func(m1 map[string]interface{})) *mRuleMockCompile {
	if mmCompile.mock.inspectFuncCompile != nil {
		mmCompile.mock.t.Fatalf("Inspect function is already set for RuleMock.Compile")
	}

	mmCompile.mock.inspectFuncCompile = f

	return mmCompile
}

// Return sets up results that will be returned by Rule.Compile
func (mmCompile *mRuleMockCompile) Return() *RuleMock {
	if mmCompile.mock.funcCompile != nil {
		mmCompile.mock.t.Fatalf("RuleMock.Compile mock is already set by Set")
	}

	if mmCompile.defaultExpectation == nil {
		mmCompile.defaultExpectation = &RuleMockCompileExpectation{mock: mmCompile.mock}
	}

	return mmCompile.mock
}

//Set uses given function f to mock the Rule.Compile method
func (mmCompile *mRuleMockCompile) Set(f func(m1 map[string]interface{})) *RuleMock {
	if mmCompile.defaultExpectation != nil {
		mmCompile.mock.t.Fatalf("Default expectation is already set for the Rule.Compile method")
	}

	if len(mmCompile.expectations) > 0 {
		mmCompile.mock.t.Fatalf("Some expectations are already set for the Rule.Compile method")
	}

	mmCompile.mock.funcCompile = f
	return mmCompile.mock
}

// Compile implements configuration.Rule
func (mmCompile *RuleMock) Compile(m1 map[string]interface{}) {
	mm_atomic.AddUint64(&mmCompile.beforeCompileCounter, 1)
	defer mm_atomic.AddUint64(&mmCompile.afterCompileCounter, 1)

	if mmCompile.inspectFuncCompile != nil {
		mmCompile.inspectFuncCompile(m1)
	}

	mm_params := &RuleMockCompileParams{m1}

	// Record call args
	mmCompile.CompileMock.mutex.Lock()
	mmCompile.CompileMock.callArgs = append(mmCompile.CompileMock.callArgs, mm_params)
	mmCompile.CompileMock.mutex.Unlock()

	for _, e := range mmCompile.CompileMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmCompile.CompileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCompile.CompileMock.defaultExpectation.Counter, 1)
		mm_want := mmCompile.CompileMock.defaultExpectation.params
		mm_got := RuleMockCompileParams{m1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCompile.t.Errorf("RuleMock.Compile got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmCompile.funcCompile != nil {
		mmCompile.funcCompile(m1)
		return
	}
	mmCompile.t.Fatalf("Unexpected call to RuleMock.Compile. %v", m1)

}

// CompileAfterCounter returns a count of finished RuleMock.Compile invocations
func (mmCompile *RuleMock) CompileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCompile.afterCompileCounter)
}

// CompileBeforeCounter returns a count of RuleMock.Compile invocations
func (mmCompile *RuleMock) CompileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCompile.beforeCompileCounter)
}

// Calls returns a list of arguments used in each call to RuleMock.Compile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCompile *mRuleMockCompile) Calls() []*RuleMockCompileParams {
	mmCompile.mutex.RLock()

	argCopy := make([]*RuleMockCompileParams, len(mmCompile.callArgs))
	copy(argCopy, mmCompile.callArgs)

	mmCompile.mutex.RUnlock()

	return argCopy
}

// MinimockCompileDone returns true if the count of the Compile invocations corresponds
// the number of defined expectations
func (m *RuleMock) MinimockCompileDone() bool {
	for _, e := range m.CompileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CompileMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCompileCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCompile != nil && mm_atomic.LoadUint64(&m.afterCompileCounter) < 1 {
		return false
	}
	return true
}

// MinimockCompileInspect logs each unmet expectation
func (m *RuleMock) MinimockCompileInspect() {
	for _, e := range m.CompileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RuleMock.Compile with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CompileMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCompileCounter) < 1 {
		if m.CompileMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RuleMock.Compile")
		} else {
			m.t.Errorf("Expected call to RuleMock.Compile with params: %#v", *m.CompileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCompile != nil && mm_atomic.LoadUint64(&m.afterCompileCounter) < 1 {
		m.t.Error("Expected call to RuleMock.Compile")
	}
}

type mRuleMockGetContition struct {
	mock               *RuleMock
	defaultExpectation *RuleMockGetContitionExpectation
	expectations       []*RuleMockGetContitionExpectation
}

// RuleMockGetContitionExpectation specifies expectation struct of the Rule.GetContition
type RuleMockGetContitionExpectation struct {
	mock *RuleMock

	results *RuleMockGetContitionResults
	Counter uint64
}

// RuleMockGetContitionResults contains results of the Rule.GetContition
type RuleMockGetContitionResults struct {
	s1 string
}

// Expect sets up expected params for Rule.GetContition
func (mmGetContition *mRuleMockGetContition) Expect() *mRuleMockGetContition {
	if mmGetContition.mock.funcGetContition != nil {
		mmGetContition.mock.t.Fatalf("RuleMock.GetContition mock is already set by Set")
	}

	if mmGetContition.defaultExpectation == nil {
		mmGetContition.defaultExpectation = &RuleMockGetContitionExpectation{}
	}

	return mmGetContition
}

// Inspect accepts an inspector function that has same arguments as the Rule.GetContition
func (mmGetContition *mRuleMockGetContition) Inspect(f func()) *mRuleMockGetContition {
	if mmGetContition.mock.inspectFuncGetContition != nil {
		mmGetContition.mock.t.Fatalf("Inspect function is already set for RuleMock.GetContition")
	}

	mmGetContition.mock.inspectFuncGetContition = f

	return mmGetContition
}

// Return sets up results that will be returned by Rule.GetContition
func (mmGetContition *mRuleMockGetContition) Return(s1 string) *RuleMock {
	if mmGetContition.mock.funcGetContition != nil {
		mmGetContition.mock.t.Fatalf("RuleMock.GetContition mock is already set by Set")
	}

	if mmGetContition.defaultExpectation == nil {
		mmGetContition.defaultExpectation = &RuleMockGetContitionExpectation{mock: mmGetContition.mock}
	}
	mmGetContition.defaultExpectation.results = &RuleMockGetContitionResults{s1}
	return mmGetContition.mock
}

//Set uses given function f to mock the Rule.GetContition method
func (mmGetContition *mRuleMockGetContition) Set(f func() (s1 string)) *RuleMock {
	if mmGetContition.defaultExpectation != nil {
		mmGetContition.mock.t.Fatalf("Default expectation is already set for the Rule.GetContition method")
	}

	if len(mmGetContition.expectations) > 0 {
		mmGetContition.mock.t.Fatalf("Some expectations are already set for the Rule.GetContition method")
	}

	mmGetContition.mock.funcGetContition = f
	return mmGetContition.mock
}

// GetContition implements configuration.Rule
func (mmGetContition *RuleMock) GetContition() (s1 string) {
	mm_atomic.AddUint64(&mmGetContition.beforeGetContitionCounter, 1)
	defer mm_atomic.AddUint64(&mmGetContition.afterGetContitionCounter, 1)

	if mmGetContition.inspectFuncGetContition != nil {
		mmGetContition.inspectFuncGetContition()
	}

	if mmGetContition.GetContitionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetContition.GetContitionMock.defaultExpectation.Counter, 1)

		mm_results := mmGetContition.GetContitionMock.defaultExpectation.results
		if mm_results == nil {
			mmGetContition.t.Fatal("No results are set for the RuleMock.GetContition")
		}
		return (*mm_results).s1
	}
	if mmGetContition.funcGetContition != nil {
		return mmGetContition.funcGetContition()
	}
	mmGetContition.t.Fatalf("Unexpected call to RuleMock.GetContition.")
	return
}

// GetContitionAfterCounter returns a count of finished RuleMock.GetContition invocations
func (mmGetContition *RuleMock) GetContitionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetContition.afterGetContitionCounter)
}

// GetContitionBeforeCounter returns a count of RuleMock.GetContition invocations
func (mmGetContition *RuleMock) GetContitionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetContition.beforeGetContitionCounter)
}

// MinimockGetContitionDone returns true if the count of the GetContition invocations corresponds
// the number of defined expectations
func (m *RuleMock) MinimockGetContitionDone() bool {
	for _, e := range m.GetContitionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetContitionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetContitionCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetContition != nil && mm_atomic.LoadUint64(&m.afterGetContitionCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetContitionInspect logs each unmet expectation
func (m *RuleMock) MinimockGetContitionInspect() {
	for _, e := range m.GetContitionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RuleMock.GetContition")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetContitionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetContitionCounter) < 1 {
		m.t.Error("Expected call to RuleMock.GetContition")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetContition != nil && mm_atomic.LoadUint64(&m.afterGetContitionCounter) < 1 {
		m.t.Error("Expected call to RuleMock.GetContition")
	}
}

type mRuleMockGetPosition struct {
	mock               *RuleMock
	defaultExpectation *RuleMockGetPositionExpectation
	expectations       []*RuleMockGetPositionExpectation
}

// RuleMockGetPositionExpectation specifies expectation struct of the Rule.GetPosition
type RuleMockGetPositionExpectation struct {
	mock *RuleMock

	results *RuleMockGetPositionResults
	Counter uint64
}

// RuleMockGetPositionResults contains results of the Rule.GetPosition
type RuleMockGetPositionResults struct {
	b1 byte
}

// Expect sets up expected params for Rule.GetPosition
func (mmGetPosition *mRuleMockGetPosition) Expect() *mRuleMockGetPosition {
	if mmGetPosition.mock.funcGetPosition != nil {
		mmGetPosition.mock.t.Fatalf("RuleMock.GetPosition mock is already set by Set")
	}

	if mmGetPosition.defaultExpectation == nil {
		mmGetPosition.defaultExpectation = &RuleMockGetPositionExpectation{}
	}

	return mmGetPosition
}

// Inspect accepts an inspector function that has same arguments as the Rule.GetPosition
func (mmGetPosition *mRuleMockGetPosition) Inspect(f func()) *mRuleMockGetPosition {
	if mmGetPosition.mock.inspectFuncGetPosition != nil {
		mmGetPosition.mock.t.Fatalf("Inspect function is already set for RuleMock.GetPosition")
	}

	mmGetPosition.mock.inspectFuncGetPosition = f

	return mmGetPosition
}

// Return sets up results that will be returned by Rule.GetPosition
func (mmGetPosition *mRuleMockGetPosition) Return(b1 byte) *RuleMock {
	if mmGetPosition.mock.funcGetPosition != nil {
		mmGetPosition.mock.t.Fatalf("RuleMock.GetPosition mock is already set by Set")
	}

	if mmGetPosition.defaultExpectation == nil {
		mmGetPosition.defaultExpectation = &RuleMockGetPositionExpectation{mock: mmGetPosition.mock}
	}
	mmGetPosition.defaultExpectation.results = &RuleMockGetPositionResults{b1}
	return mmGetPosition.mock
}

//Set uses given function f to mock the Rule.GetPosition method
func (mmGetPosition *mRuleMockGetPosition) Set(f func() (b1 byte)) *RuleMock {
	if mmGetPosition.defaultExpectation != nil {
		mmGetPosition.mock.t.Fatalf("Default expectation is already set for the Rule.GetPosition method")
	}

	if len(mmGetPosition.expectations) > 0 {
		mmGetPosition.mock.t.Fatalf("Some expectations are already set for the Rule.GetPosition method")
	}

	mmGetPosition.mock.funcGetPosition = f
	return mmGetPosition.mock
}

// GetPosition implements configuration.Rule
func (mmGetPosition *RuleMock) GetPosition() (b1 byte) {
	mm_atomic.AddUint64(&mmGetPosition.beforeGetPositionCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPosition.afterGetPositionCounter, 1)

	if mmGetPosition.inspectFuncGetPosition != nil {
		mmGetPosition.inspectFuncGetPosition()
	}

	if mmGetPosition.GetPositionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPosition.GetPositionMock.defaultExpectation.Counter, 1)

		mm_results := mmGetPosition.GetPositionMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPosition.t.Fatal("No results are set for the RuleMock.GetPosition")
		}
		return (*mm_results).b1
	}
	if mmGetPosition.funcGetPosition != nil {
		return mmGetPosition.funcGetPosition()
	}
	mmGetPosition.t.Fatalf("Unexpected call to RuleMock.GetPosition.")
	return
}

// GetPositionAfterCounter returns a count of finished RuleMock.GetPosition invocations
func (mmGetPosition *RuleMock) GetPositionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPosition.afterGetPositionCounter)
}

// GetPositionBeforeCounter returns a count of RuleMock.GetPosition invocations
func (mmGetPosition *RuleMock) GetPositionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPosition.beforeGetPositionCounter)
}

// MinimockGetPositionDone returns true if the count of the GetPosition invocations corresponds
// the number of defined expectations
func (m *RuleMock) MinimockGetPositionDone() bool {
	for _, e := range m.GetPositionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPositionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPositionCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPosition != nil && mm_atomic.LoadUint64(&m.afterGetPositionCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetPositionInspect logs each unmet expectation
func (m *RuleMock) MinimockGetPositionInspect() {
	for _, e := range m.GetPositionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RuleMock.GetPosition")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPositionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPositionCounter) < 1 {
		m.t.Error("Expected call to RuleMock.GetPosition")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPosition != nil && mm_atomic.LoadUint64(&m.afterGetPositionCounter) < 1 {
		m.t.Error("Expected call to RuleMock.GetPosition")
	}
}

type mRuleMockGetPrefix struct {
	mock               *RuleMock
	defaultExpectation *RuleMockGetPrefixExpectation
	expectations       []*RuleMockGetPrefixExpectation
}

// RuleMockGetPrefixExpectation specifies expectation struct of the Rule.GetPrefix
type RuleMockGetPrefixExpectation struct {
	mock *RuleMock

	results *RuleMockGetPrefixResults
	Counter uint64
}

// RuleMockGetPrefixResults contains results of the Rule.GetPrefix
type RuleMockGetPrefixResults struct {
	s1 string
}

// Expect sets up expected params for Rule.GetPrefix
func (mmGetPrefix *mRuleMockGetPrefix) Expect() *mRuleMockGetPrefix {
	if mmGetPrefix.mock.funcGetPrefix != nil {
		mmGetPrefix.mock.t.Fatalf("RuleMock.GetPrefix mock is already set by Set")
	}

	if mmGetPrefix.defaultExpectation == nil {
		mmGetPrefix.defaultExpectation = &RuleMockGetPrefixExpectation{}
	}

	return mmGetPrefix
}

// Inspect accepts an inspector function that has same arguments as the Rule.GetPrefix
func (mmGetPrefix *mRuleMockGetPrefix) Inspect(f func()) *mRuleMockGetPrefix {
	if mmGetPrefix.mock.inspectFuncGetPrefix != nil {
		mmGetPrefix.mock.t.Fatalf("Inspect function is already set for RuleMock.GetPrefix")
	}

	mmGetPrefix.mock.inspectFuncGetPrefix = f

	return mmGetPrefix
}

// Return sets up results that will be returned by Rule.GetPrefix
func (mmGetPrefix *mRuleMockGetPrefix) Return(s1 string) *RuleMock {
	if mmGetPrefix.mock.funcGetPrefix != nil {
		mmGetPrefix.mock.t.Fatalf("RuleMock.GetPrefix mock is already set by Set")
	}

	if mmGetPrefix.defaultExpectation == nil {
		mmGetPrefix.defaultExpectation = &RuleMockGetPrefixExpectation{mock: mmGetPrefix.mock}
	}
	mmGetPrefix.defaultExpectation.results = &RuleMockGetPrefixResults{s1}
	return mmGetPrefix.mock
}

//Set uses given function f to mock the Rule.GetPrefix method
func (mmGetPrefix *mRuleMockGetPrefix) Set(f func() (s1 string)) *RuleMock {
	if mmGetPrefix.defaultExpectation != nil {
		mmGetPrefix.mock.t.Fatalf("Default expectation is already set for the Rule.GetPrefix method")
	}

	if len(mmGetPrefix.expectations) > 0 {
		mmGetPrefix.mock.t.Fatalf("Some expectations are already set for the Rule.GetPrefix method")
	}

	mmGetPrefix.mock.funcGetPrefix = f
	return mmGetPrefix.mock
}

// GetPrefix implements configuration.Rule
func (mmGetPrefix *RuleMock) GetPrefix() (s1 string) {
	mm_atomic.AddUint64(&mmGetPrefix.beforeGetPrefixCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPrefix.afterGetPrefixCounter, 1)

	if mmGetPrefix.inspectFuncGetPrefix != nil {
		mmGetPrefix.inspectFuncGetPrefix()
	}

	if mmGetPrefix.GetPrefixMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPrefix.GetPrefixMock.defaultExpectation.Counter, 1)

		mm_results := mmGetPrefix.GetPrefixMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPrefix.t.Fatal("No results are set for the RuleMock.GetPrefix")
		}
		return (*mm_results).s1
	}
	if mmGetPrefix.funcGetPrefix != nil {
		return mmGetPrefix.funcGetPrefix()
	}
	mmGetPrefix.t.Fatalf("Unexpected call to RuleMock.GetPrefix.")
	return
}

// GetPrefixAfterCounter returns a count of finished RuleMock.GetPrefix invocations
func (mmGetPrefix *RuleMock) GetPrefixAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPrefix.afterGetPrefixCounter)
}

// GetPrefixBeforeCounter returns a count of RuleMock.GetPrefix invocations
func (mmGetPrefix *RuleMock) GetPrefixBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPrefix.beforeGetPrefixCounter)
}

// MinimockGetPrefixDone returns true if the count of the GetPrefix invocations corresponds
// the number of defined expectations
func (m *RuleMock) MinimockGetPrefixDone() bool {
	for _, e := range m.GetPrefixMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPrefixMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPrefixCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPrefix != nil && mm_atomic.LoadUint64(&m.afterGetPrefixCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetPrefixInspect logs each unmet expectation
func (m *RuleMock) MinimockGetPrefixInspect() {
	for _, e := range m.GetPrefixMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RuleMock.GetPrefix")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPrefixMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPrefixCounter) < 1 {
		m.t.Error("Expected call to RuleMock.GetPrefix")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPrefix != nil && mm_atomic.LoadUint64(&m.afterGetPrefixCounter) < 1 {
		m.t.Error("Expected call to RuleMock.GetPrefix")
	}
}

type mRuleMockGetType struct {
	mock               *RuleMock
	defaultExpectation *RuleMockGetTypeExpectation
	expectations       []*RuleMockGetTypeExpectation
}

// RuleMockGetTypeExpectation specifies expectation struct of the Rule.GetType
type RuleMockGetTypeExpectation struct {
	mock *RuleMock

	results *RuleMockGetTypeResults
	Counter uint64
}

// RuleMockGetTypeResults contains results of the Rule.GetType
type RuleMockGetTypeResults struct {
	s1 string
}

// Expect sets up expected params for Rule.GetType
func (mmGetType *mRuleMockGetType) Expect() *mRuleMockGetType {
	if mmGetType.mock.funcGetType != nil {
		mmGetType.mock.t.Fatalf("RuleMock.GetType mock is already set by Set")
	}

	if mmGetType.defaultExpectation == nil {
		mmGetType.defaultExpectation = &RuleMockGetTypeExpectation{}
	}

	return mmGetType
}

// Inspect accepts an inspector function that has same arguments as the Rule.GetType
func (mmGetType *mRuleMockGetType) Inspect(f func()) *mRuleMockGetType {
	if mmGetType.mock.inspectFuncGetType != nil {
		mmGetType.mock.t.Fatalf("Inspect function is already set for RuleMock.GetType")
	}

	mmGetType.mock.inspectFuncGetType = f

	return mmGetType
}

// Return sets up results that will be returned by Rule.GetType
func (mmGetType *mRuleMockGetType) Return(s1 string) *RuleMock {
	if mmGetType.mock.funcGetType != nil {
		mmGetType.mock.t.Fatalf("RuleMock.GetType mock is already set by Set")
	}

	if mmGetType.defaultExpectation == nil {
		mmGetType.defaultExpectation = &RuleMockGetTypeExpectation{mock: mmGetType.mock}
	}
	mmGetType.defaultExpectation.results = &RuleMockGetTypeResults{s1}
	return mmGetType.mock
}

//Set uses given function f to mock the Rule.GetType method
func (mmGetType *mRuleMockGetType) Set(f func() (s1 string)) *RuleMock {
	if mmGetType.defaultExpectation != nil {
		mmGetType.mock.t.Fatalf("Default expectation is already set for the Rule.GetType method")
	}

	if len(mmGetType.expectations) > 0 {
		mmGetType.mock.t.Fatalf("Some expectations are already set for the Rule.GetType method")
	}

	mmGetType.mock.funcGetType = f
	return mmGetType.mock
}

// GetType implements configuration.Rule
func (mmGetType *RuleMock) GetType() (s1 string) {
	mm_atomic.AddUint64(&mmGetType.beforeGetTypeCounter, 1)
	defer mm_atomic.AddUint64(&mmGetType.afterGetTypeCounter, 1)

	if mmGetType.inspectFuncGetType != nil {
		mmGetType.inspectFuncGetType()
	}

	if mmGetType.GetTypeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetType.GetTypeMock.defaultExpectation.Counter, 1)

		mm_results := mmGetType.GetTypeMock.defaultExpectation.results
		if mm_results == nil {
			mmGetType.t.Fatal("No results are set for the RuleMock.GetType")
		}
		return (*mm_results).s1
	}
	if mmGetType.funcGetType != nil {
		return mmGetType.funcGetType()
	}
	mmGetType.t.Fatalf("Unexpected call to RuleMock.GetType.")
	return
}

// GetTypeAfterCounter returns a count of finished RuleMock.GetType invocations
func (mmGetType *RuleMock) GetTypeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetType.afterGetTypeCounter)
}

// GetTypeBeforeCounter returns a count of RuleMock.GetType invocations
func (mmGetType *RuleMock) GetTypeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetType.beforeGetTypeCounter)
}

// MinimockGetTypeDone returns true if the count of the GetType invocations corresponds
// the number of defined expectations
func (m *RuleMock) MinimockGetTypeDone() bool {
	for _, e := range m.GetTypeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetTypeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetTypeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetType != nil && mm_atomic.LoadUint64(&m.afterGetTypeCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetTypeInspect logs each unmet expectation
func (m *RuleMock) MinimockGetTypeInspect() {
	for _, e := range m.GetTypeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RuleMock.GetType")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetTypeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetTypeCounter) < 1 {
		m.t.Error("Expected call to RuleMock.GetType")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetType != nil && mm_atomic.LoadUint64(&m.afterGetTypeCounter) < 1 {
		m.t.Error("Expected call to RuleMock.GetType")
	}
}

type mRuleMockInit struct {
	mock               *RuleMock
	defaultExpectation *RuleMockInitExpectation
	expectations       []*RuleMockInitExpectation

	callArgs []*RuleMockInitParams
	mutex    sync.RWMutex
}

// RuleMockInitExpectation specifies expectation struct of the Rule.Init
type RuleMockInitExpectation struct {
	mock   *RuleMock
	params *RuleMockInitParams

	Counter uint64
}

// RuleMockInitParams contains parameters of the Rule.Init
type RuleMockInitParams struct {
	options []rules.RuleOption
}

// Expect sets up expected params for Rule.Init
func (mmInit *mRuleMockInit) Expect(options ...rules.RuleOption) *mRuleMockInit {
	if mmInit.mock.funcInit != nil {
		mmInit.mock.t.Fatalf("RuleMock.Init mock is already set by Set")
	}

	if mmInit.defaultExpectation == nil {
		mmInit.defaultExpectation = &RuleMockInitExpectation{}
	}

	mmInit.defaultExpectation.params = &RuleMockInitParams{options}
	for _, e := range mmInit.expectations {
		if minimock.Equal(e.params, mmInit.defaultExpectation.params) {
			mmInit.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmInit.defaultExpectation.params)
		}
	}

	return mmInit
}

// Inspect accepts an inspector function that has same arguments as the Rule.Init
func (mmInit *mRuleMockInit) Inspect(f func(options ...rules.RuleOption)) *mRuleMockInit {
	if mmInit.mock.inspectFuncInit != nil {
		mmInit.mock.t.Fatalf("Inspect function is already set for RuleMock.Init")
	}

	mmInit.mock.inspectFuncInit = f

	return mmInit
}

// Return sets up results that will be returned by Rule.Init
func (mmInit *mRuleMockInit) Return() *RuleMock {
	if mmInit.mock.funcInit != nil {
		mmInit.mock.t.Fatalf("RuleMock.Init mock is already set by Set")
	}

	if mmInit.defaultExpectation == nil {
		mmInit.defaultExpectation = &RuleMockInitExpectation{mock: mmInit.mock}
	}

	return mmInit.mock
}

//Set uses given function f to mock the Rule.Init method
func (mmInit *mRuleMockInit) Set(f func(options ...rules.RuleOption)) *RuleMock {
	if mmInit.defaultExpectation != nil {
		mmInit.mock.t.Fatalf("Default expectation is already set for the Rule.Init method")
	}

	if len(mmInit.expectations) > 0 {
		mmInit.mock.t.Fatalf("Some expectations are already set for the Rule.Init method")
	}

	mmInit.mock.funcInit = f
	return mmInit.mock
}

// Init implements configuration.Rule
func (mmInit *RuleMock) Init(options ...rules.RuleOption) {
	mm_atomic.AddUint64(&mmInit.beforeInitCounter, 1)
	defer mm_atomic.AddUint64(&mmInit.afterInitCounter, 1)

	if mmInit.inspectFuncInit != nil {
		mmInit.inspectFuncInit(options...)
	}

	mm_params := &RuleMockInitParams{options}

	// Record call args
	mmInit.InitMock.mutex.Lock()
	mmInit.InitMock.callArgs = append(mmInit.InitMock.callArgs, mm_params)
	mmInit.InitMock.mutex.Unlock()

	for _, e := range mmInit.InitMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmInit.InitMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInit.InitMock.defaultExpectation.Counter, 1)
		mm_want := mmInit.InitMock.defaultExpectation.params
		mm_got := RuleMockInitParams{options}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmInit.t.Errorf("RuleMock.Init got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmInit.funcInit != nil {
		mmInit.funcInit(options...)
		return
	}
	mmInit.t.Fatalf("Unexpected call to RuleMock.Init. %v", options)

}

// InitAfterCounter returns a count of finished RuleMock.Init invocations
func (mmInit *RuleMock) InitAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInit.afterInitCounter)
}

// InitBeforeCounter returns a count of RuleMock.Init invocations
func (mmInit *RuleMock) InitBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInit.beforeInitCounter)
}

// Calls returns a list of arguments used in each call to RuleMock.Init.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmInit *mRuleMockInit) Calls() []*RuleMockInitParams {
	mmInit.mutex.RLock()

	argCopy := make([]*RuleMockInitParams, len(mmInit.callArgs))
	copy(argCopy, mmInit.callArgs)

	mmInit.mutex.RUnlock()

	return argCopy
}

// MinimockInitDone returns true if the count of the Init invocations corresponds
// the number of defined expectations
func (m *RuleMock) MinimockInitDone() bool {
	for _, e := range m.InitMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InitMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInitCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInit != nil && mm_atomic.LoadUint64(&m.afterInitCounter) < 1 {
		return false
	}
	return true
}

// MinimockInitInspect logs each unmet expectation
func (m *RuleMock) MinimockInitInspect() {
	for _, e := range m.InitMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RuleMock.Init with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InitMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInitCounter) < 1 {
		if m.InitMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RuleMock.Init")
		} else {
			m.t.Errorf("Expected call to RuleMock.Init with params: %#v", *m.InitMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInit != nil && mm_atomic.LoadUint64(&m.afterInitCounter) < 1 {
		m.t.Error("Expected call to RuleMock.Init")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RuleMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCheckInspect()

		m.MinimockCompileInspect()

		m.MinimockGetContitionInspect()

		m.MinimockGetPositionInspect()

		m.MinimockGetPrefixInspect()

		m.MinimockGetTypeInspect()

		m.MinimockInitInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RuleMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RuleMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCheckDone() &&
		m.MinimockCompileDone() &&
		m.MinimockGetContitionDone() &&
		m.MinimockGetPositionDone() &&
		m.MinimockGetPrefixDone() &&
		m.MinimockGetTypeDone() &&
		m.MinimockInitDone()
}
