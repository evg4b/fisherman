package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i fisherman/infrastructure.FileSystem -o ./testing/mocks/file_system_mock.go

import (
	"os"
	"sync"
	mm_atomic "sync/atomic"
	"time"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/spf13/afero"
)

// FileSystemMock implements infrastructure.FileSystem
type FileSystemMock struct {
	t minimock.Tester

	funcChmod          func(name string, mode os.FileMode) (err error)
	inspectFuncChmod   func(name string, mode os.FileMode)
	afterChmodCounter  uint64
	beforeChmodCounter uint64
	ChmodMock          mFileSystemMockChmod

	funcChown          func(name string, uid int, gid int) (err error)
	inspectFuncChown   func(name string, uid int, gid int)
	afterChownCounter  uint64
	beforeChownCounter uint64
	ChownMock          mFileSystemMockChown

	funcChtimes          func(name string, atime time.Time, mtime time.Time) (err error)
	inspectFuncChtimes   func(name string, atime time.Time, mtime time.Time)
	afterChtimesCounter  uint64
	beforeChtimesCounter uint64
	ChtimesMock          mFileSystemMockChtimes

	funcCreate          func(name string) (f1 afero.File, err error)
	inspectFuncCreate   func(name string)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mFileSystemMockCreate

	funcMkdir          func(name string, perm os.FileMode) (err error)
	inspectFuncMkdir   func(name string, perm os.FileMode)
	afterMkdirCounter  uint64
	beforeMkdirCounter uint64
	MkdirMock          mFileSystemMockMkdir

	funcMkdirAll          func(path string, perm os.FileMode) (err error)
	inspectFuncMkdirAll   func(path string, perm os.FileMode)
	afterMkdirAllCounter  uint64
	beforeMkdirAllCounter uint64
	MkdirAllMock          mFileSystemMockMkdirAll

	funcName          func() (s1 string)
	inspectFuncName   func()
	afterNameCounter  uint64
	beforeNameCounter uint64
	NameMock          mFileSystemMockName

	funcOpen          func(name string) (f1 afero.File, err error)
	inspectFuncOpen   func(name string)
	afterOpenCounter  uint64
	beforeOpenCounter uint64
	OpenMock          mFileSystemMockOpen

	funcOpenFile          func(name string, flag int, perm os.FileMode) (f1 afero.File, err error)
	inspectFuncOpenFile   func(name string, flag int, perm os.FileMode)
	afterOpenFileCounter  uint64
	beforeOpenFileCounter uint64
	OpenFileMock          mFileSystemMockOpenFile

	funcRemove          func(name string) (err error)
	inspectFuncRemove   func(name string)
	afterRemoveCounter  uint64
	beforeRemoveCounter uint64
	RemoveMock          mFileSystemMockRemove

	funcRemoveAll          func(path string) (err error)
	inspectFuncRemoveAll   func(path string)
	afterRemoveAllCounter  uint64
	beforeRemoveAllCounter uint64
	RemoveAllMock          mFileSystemMockRemoveAll

	funcRename          func(oldname string, newname string) (err error)
	inspectFuncRename   func(oldname string, newname string)
	afterRenameCounter  uint64
	beforeRenameCounter uint64
	RenameMock          mFileSystemMockRename

	funcStat          func(name string) (f1 os.FileInfo, err error)
	inspectFuncStat   func(name string)
	afterStatCounter  uint64
	beforeStatCounter uint64
	StatMock          mFileSystemMockStat
}

// NewFileSystemMock returns a mock for infrastructure.FileSystem
func NewFileSystemMock(t minimock.Tester) *FileSystemMock {
	m := &FileSystemMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ChmodMock = mFileSystemMockChmod{mock: m}
	m.ChmodMock.callArgs = []*FileSystemMockChmodParams{}

	m.ChownMock = mFileSystemMockChown{mock: m}
	m.ChownMock.callArgs = []*FileSystemMockChownParams{}

	m.ChtimesMock = mFileSystemMockChtimes{mock: m}
	m.ChtimesMock.callArgs = []*FileSystemMockChtimesParams{}

	m.CreateMock = mFileSystemMockCreate{mock: m}
	m.CreateMock.callArgs = []*FileSystemMockCreateParams{}

	m.MkdirMock = mFileSystemMockMkdir{mock: m}
	m.MkdirMock.callArgs = []*FileSystemMockMkdirParams{}

	m.MkdirAllMock = mFileSystemMockMkdirAll{mock: m}
	m.MkdirAllMock.callArgs = []*FileSystemMockMkdirAllParams{}

	m.NameMock = mFileSystemMockName{mock: m}

	m.OpenMock = mFileSystemMockOpen{mock: m}
	m.OpenMock.callArgs = []*FileSystemMockOpenParams{}

	m.OpenFileMock = mFileSystemMockOpenFile{mock: m}
	m.OpenFileMock.callArgs = []*FileSystemMockOpenFileParams{}

	m.RemoveMock = mFileSystemMockRemove{mock: m}
	m.RemoveMock.callArgs = []*FileSystemMockRemoveParams{}

	m.RemoveAllMock = mFileSystemMockRemoveAll{mock: m}
	m.RemoveAllMock.callArgs = []*FileSystemMockRemoveAllParams{}

	m.RenameMock = mFileSystemMockRename{mock: m}
	m.RenameMock.callArgs = []*FileSystemMockRenameParams{}

	m.StatMock = mFileSystemMockStat{mock: m}
	m.StatMock.callArgs = []*FileSystemMockStatParams{}

	return m
}

type mFileSystemMockChmod struct {
	mock               *FileSystemMock
	defaultExpectation *FileSystemMockChmodExpectation
	expectations       []*FileSystemMockChmodExpectation

	callArgs []*FileSystemMockChmodParams
	mutex    sync.RWMutex
}

// FileSystemMockChmodExpectation specifies expectation struct of the FileSystem.Chmod
type FileSystemMockChmodExpectation struct {
	mock    *FileSystemMock
	params  *FileSystemMockChmodParams
	results *FileSystemMockChmodResults
	Counter uint64
}

// FileSystemMockChmodParams contains parameters of the FileSystem.Chmod
type FileSystemMockChmodParams struct {
	name string
	mode os.FileMode
}

// FileSystemMockChmodResults contains results of the FileSystem.Chmod
type FileSystemMockChmodResults struct {
	err error
}

// Expect sets up expected params for FileSystem.Chmod
func (mmChmod *mFileSystemMockChmod) Expect(name string, mode os.FileMode) *mFileSystemMockChmod {
	if mmChmod.mock.funcChmod != nil {
		mmChmod.mock.t.Fatalf("FileSystemMock.Chmod mock is already set by Set")
	}

	if mmChmod.defaultExpectation == nil {
		mmChmod.defaultExpectation = &FileSystemMockChmodExpectation{}
	}

	mmChmod.defaultExpectation.params = &FileSystemMockChmodParams{name, mode}
	for _, e := range mmChmod.expectations {
		if minimock.Equal(e.params, mmChmod.defaultExpectation.params) {
			mmChmod.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmChmod.defaultExpectation.params)
		}
	}

	return mmChmod
}

// Inspect accepts an inspector function that has same arguments as the FileSystem.Chmod
func (mmChmod *mFileSystemMockChmod) Inspect(f func(name string, mode os.FileMode)) *mFileSystemMockChmod {
	if mmChmod.mock.inspectFuncChmod != nil {
		mmChmod.mock.t.Fatalf("Inspect function is already set for FileSystemMock.Chmod")
	}

	mmChmod.mock.inspectFuncChmod = f

	return mmChmod
}

// Return sets up results that will be returned by FileSystem.Chmod
func (mmChmod *mFileSystemMockChmod) Return(err error) *FileSystemMock {
	if mmChmod.mock.funcChmod != nil {
		mmChmod.mock.t.Fatalf("FileSystemMock.Chmod mock is already set by Set")
	}

	if mmChmod.defaultExpectation == nil {
		mmChmod.defaultExpectation = &FileSystemMockChmodExpectation{mock: mmChmod.mock}
	}
	mmChmod.defaultExpectation.results = &FileSystemMockChmodResults{err}
	return mmChmod.mock
}

//Set uses given function f to mock the FileSystem.Chmod method
func (mmChmod *mFileSystemMockChmod) Set(f func(name string, mode os.FileMode) (err error)) *FileSystemMock {
	if mmChmod.defaultExpectation != nil {
		mmChmod.mock.t.Fatalf("Default expectation is already set for the FileSystem.Chmod method")
	}

	if len(mmChmod.expectations) > 0 {
		mmChmod.mock.t.Fatalf("Some expectations are already set for the FileSystem.Chmod method")
	}

	mmChmod.mock.funcChmod = f
	return mmChmod.mock
}

// When sets expectation for the FileSystem.Chmod which will trigger the result defined by the following
// Then helper
func (mmChmod *mFileSystemMockChmod) When(name string, mode os.FileMode) *FileSystemMockChmodExpectation {
	if mmChmod.mock.funcChmod != nil {
		mmChmod.mock.t.Fatalf("FileSystemMock.Chmod mock is already set by Set")
	}

	expectation := &FileSystemMockChmodExpectation{
		mock:   mmChmod.mock,
		params: &FileSystemMockChmodParams{name, mode},
	}
	mmChmod.expectations = append(mmChmod.expectations, expectation)
	return expectation
}

// Then sets up FileSystem.Chmod return parameters for the expectation previously defined by the When method
func (e *FileSystemMockChmodExpectation) Then(err error) *FileSystemMock {
	e.results = &FileSystemMockChmodResults{err}
	return e.mock
}

// Chmod implements infrastructure.FileSystem
func (mmChmod *FileSystemMock) Chmod(name string, mode os.FileMode) (err error) {
	mm_atomic.AddUint64(&mmChmod.beforeChmodCounter, 1)
	defer mm_atomic.AddUint64(&mmChmod.afterChmodCounter, 1)

	if mmChmod.inspectFuncChmod != nil {
		mmChmod.inspectFuncChmod(name, mode)
	}

	mm_params := &FileSystemMockChmodParams{name, mode}

	// Record call args
	mmChmod.ChmodMock.mutex.Lock()
	mmChmod.ChmodMock.callArgs = append(mmChmod.ChmodMock.callArgs, mm_params)
	mmChmod.ChmodMock.mutex.Unlock()

	for _, e := range mmChmod.ChmodMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmChmod.ChmodMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmChmod.ChmodMock.defaultExpectation.Counter, 1)
		mm_want := mmChmod.ChmodMock.defaultExpectation.params
		mm_got := FileSystemMockChmodParams{name, mode}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmChmod.t.Errorf("FileSystemMock.Chmod got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmChmod.ChmodMock.defaultExpectation.results
		if mm_results == nil {
			mmChmod.t.Fatal("No results are set for the FileSystemMock.Chmod")
		}
		return (*mm_results).err
	}
	if mmChmod.funcChmod != nil {
		return mmChmod.funcChmod(name, mode)
	}
	mmChmod.t.Fatalf("Unexpected call to FileSystemMock.Chmod. %v %v", name, mode)
	return
}

// ChmodAfterCounter returns a count of finished FileSystemMock.Chmod invocations
func (mmChmod *FileSystemMock) ChmodAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmChmod.afterChmodCounter)
}

// ChmodBeforeCounter returns a count of FileSystemMock.Chmod invocations
func (mmChmod *FileSystemMock) ChmodBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmChmod.beforeChmodCounter)
}

// Calls returns a list of arguments used in each call to FileSystemMock.Chmod.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmChmod *mFileSystemMockChmod) Calls() []*FileSystemMockChmodParams {
	mmChmod.mutex.RLock()

	argCopy := make([]*FileSystemMockChmodParams, len(mmChmod.callArgs))
	copy(argCopy, mmChmod.callArgs)

	mmChmod.mutex.RUnlock()

	return argCopy
}

// MinimockChmodDone returns true if the count of the Chmod invocations corresponds
// the number of defined expectations
func (m *FileSystemMock) MinimockChmodDone() bool {
	for _, e := range m.ChmodMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ChmodMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterChmodCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcChmod != nil && mm_atomic.LoadUint64(&m.afterChmodCounter) < 1 {
		return false
	}
	return true
}

// MinimockChmodInspect logs each unmet expectation
func (m *FileSystemMock) MinimockChmodInspect() {
	for _, e := range m.ChmodMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FileSystemMock.Chmod with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ChmodMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterChmodCounter) < 1 {
		if m.ChmodMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FileSystemMock.Chmod")
		} else {
			m.t.Errorf("Expected call to FileSystemMock.Chmod with params: %#v", *m.ChmodMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcChmod != nil && mm_atomic.LoadUint64(&m.afterChmodCounter) < 1 {
		m.t.Error("Expected call to FileSystemMock.Chmod")
	}
}

type mFileSystemMockChown struct {
	mock               *FileSystemMock
	defaultExpectation *FileSystemMockChownExpectation
	expectations       []*FileSystemMockChownExpectation

	callArgs []*FileSystemMockChownParams
	mutex    sync.RWMutex
}

// FileSystemMockChownExpectation specifies expectation struct of the FileSystem.Chown
type FileSystemMockChownExpectation struct {
	mock    *FileSystemMock
	params  *FileSystemMockChownParams
	results *FileSystemMockChownResults
	Counter uint64
}

// FileSystemMockChownParams contains parameters of the FileSystem.Chown
type FileSystemMockChownParams struct {
	name string
	uid  int
	gid  int
}

// FileSystemMockChownResults contains results of the FileSystem.Chown
type FileSystemMockChownResults struct {
	err error
}

// Expect sets up expected params for FileSystem.Chown
func (mmChown *mFileSystemMockChown) Expect(name string, uid int, gid int) *mFileSystemMockChown {
	if mmChown.mock.funcChown != nil {
		mmChown.mock.t.Fatalf("FileSystemMock.Chown mock is already set by Set")
	}

	if mmChown.defaultExpectation == nil {
		mmChown.defaultExpectation = &FileSystemMockChownExpectation{}
	}

	mmChown.defaultExpectation.params = &FileSystemMockChownParams{name, uid, gid}
	for _, e := range mmChown.expectations {
		if minimock.Equal(e.params, mmChown.defaultExpectation.params) {
			mmChown.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmChown.defaultExpectation.params)
		}
	}

	return mmChown
}

// Inspect accepts an inspector function that has same arguments as the FileSystem.Chown
func (mmChown *mFileSystemMockChown) Inspect(f func(name string, uid int, gid int)) *mFileSystemMockChown {
	if mmChown.mock.inspectFuncChown != nil {
		mmChown.mock.t.Fatalf("Inspect function is already set for FileSystemMock.Chown")
	}

	mmChown.mock.inspectFuncChown = f

	return mmChown
}

// Return sets up results that will be returned by FileSystem.Chown
func (mmChown *mFileSystemMockChown) Return(err error) *FileSystemMock {
	if mmChown.mock.funcChown != nil {
		mmChown.mock.t.Fatalf("FileSystemMock.Chown mock is already set by Set")
	}

	if mmChown.defaultExpectation == nil {
		mmChown.defaultExpectation = &FileSystemMockChownExpectation{mock: mmChown.mock}
	}
	mmChown.defaultExpectation.results = &FileSystemMockChownResults{err}
	return mmChown.mock
}

//Set uses given function f to mock the FileSystem.Chown method
func (mmChown *mFileSystemMockChown) Set(f func(name string, uid int, gid int) (err error)) *FileSystemMock {
	if mmChown.defaultExpectation != nil {
		mmChown.mock.t.Fatalf("Default expectation is already set for the FileSystem.Chown method")
	}

	if len(mmChown.expectations) > 0 {
		mmChown.mock.t.Fatalf("Some expectations are already set for the FileSystem.Chown method")
	}

	mmChown.mock.funcChown = f
	return mmChown.mock
}

// When sets expectation for the FileSystem.Chown which will trigger the result defined by the following
// Then helper
func (mmChown *mFileSystemMockChown) When(name string, uid int, gid int) *FileSystemMockChownExpectation {
	if mmChown.mock.funcChown != nil {
		mmChown.mock.t.Fatalf("FileSystemMock.Chown mock is already set by Set")
	}

	expectation := &FileSystemMockChownExpectation{
		mock:   mmChown.mock,
		params: &FileSystemMockChownParams{name, uid, gid},
	}
	mmChown.expectations = append(mmChown.expectations, expectation)
	return expectation
}

// Then sets up FileSystem.Chown return parameters for the expectation previously defined by the When method
func (e *FileSystemMockChownExpectation) Then(err error) *FileSystemMock {
	e.results = &FileSystemMockChownResults{err}
	return e.mock
}

// Chown implements infrastructure.FileSystem
func (mmChown *FileSystemMock) Chown(name string, uid int, gid int) (err error) {
	mm_atomic.AddUint64(&mmChown.beforeChownCounter, 1)
	defer mm_atomic.AddUint64(&mmChown.afterChownCounter, 1)

	if mmChown.inspectFuncChown != nil {
		mmChown.inspectFuncChown(name, uid, gid)
	}

	mm_params := &FileSystemMockChownParams{name, uid, gid}

	// Record call args
	mmChown.ChownMock.mutex.Lock()
	mmChown.ChownMock.callArgs = append(mmChown.ChownMock.callArgs, mm_params)
	mmChown.ChownMock.mutex.Unlock()

	for _, e := range mmChown.ChownMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmChown.ChownMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmChown.ChownMock.defaultExpectation.Counter, 1)
		mm_want := mmChown.ChownMock.defaultExpectation.params
		mm_got := FileSystemMockChownParams{name, uid, gid}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmChown.t.Errorf("FileSystemMock.Chown got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmChown.ChownMock.defaultExpectation.results
		if mm_results == nil {
			mmChown.t.Fatal("No results are set for the FileSystemMock.Chown")
		}
		return (*mm_results).err
	}
	if mmChown.funcChown != nil {
		return mmChown.funcChown(name, uid, gid)
	}
	mmChown.t.Fatalf("Unexpected call to FileSystemMock.Chown. %v %v %v", name, uid, gid)
	return
}

// ChownAfterCounter returns a count of finished FileSystemMock.Chown invocations
func (mmChown *FileSystemMock) ChownAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmChown.afterChownCounter)
}

// ChownBeforeCounter returns a count of FileSystemMock.Chown invocations
func (mmChown *FileSystemMock) ChownBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmChown.beforeChownCounter)
}

// Calls returns a list of arguments used in each call to FileSystemMock.Chown.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmChown *mFileSystemMockChown) Calls() []*FileSystemMockChownParams {
	mmChown.mutex.RLock()

	argCopy := make([]*FileSystemMockChownParams, len(mmChown.callArgs))
	copy(argCopy, mmChown.callArgs)

	mmChown.mutex.RUnlock()

	return argCopy
}

// MinimockChownDone returns true if the count of the Chown invocations corresponds
// the number of defined expectations
func (m *FileSystemMock) MinimockChownDone() bool {
	for _, e := range m.ChownMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ChownMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterChownCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcChown != nil && mm_atomic.LoadUint64(&m.afterChownCounter) < 1 {
		return false
	}
	return true
}

// MinimockChownInspect logs each unmet expectation
func (m *FileSystemMock) MinimockChownInspect() {
	for _, e := range m.ChownMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FileSystemMock.Chown with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ChownMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterChownCounter) < 1 {
		if m.ChownMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FileSystemMock.Chown")
		} else {
			m.t.Errorf("Expected call to FileSystemMock.Chown with params: %#v", *m.ChownMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcChown != nil && mm_atomic.LoadUint64(&m.afterChownCounter) < 1 {
		m.t.Error("Expected call to FileSystemMock.Chown")
	}
}

type mFileSystemMockChtimes struct {
	mock               *FileSystemMock
	defaultExpectation *FileSystemMockChtimesExpectation
	expectations       []*FileSystemMockChtimesExpectation

	callArgs []*FileSystemMockChtimesParams
	mutex    sync.RWMutex
}

// FileSystemMockChtimesExpectation specifies expectation struct of the FileSystem.Chtimes
type FileSystemMockChtimesExpectation struct {
	mock    *FileSystemMock
	params  *FileSystemMockChtimesParams
	results *FileSystemMockChtimesResults
	Counter uint64
}

// FileSystemMockChtimesParams contains parameters of the FileSystem.Chtimes
type FileSystemMockChtimesParams struct {
	name  string
	atime time.Time
	mtime time.Time
}

// FileSystemMockChtimesResults contains results of the FileSystem.Chtimes
type FileSystemMockChtimesResults struct {
	err error
}

// Expect sets up expected params for FileSystem.Chtimes
func (mmChtimes *mFileSystemMockChtimes) Expect(name string, atime time.Time, mtime time.Time) *mFileSystemMockChtimes {
	if mmChtimes.mock.funcChtimes != nil {
		mmChtimes.mock.t.Fatalf("FileSystemMock.Chtimes mock is already set by Set")
	}

	if mmChtimes.defaultExpectation == nil {
		mmChtimes.defaultExpectation = &FileSystemMockChtimesExpectation{}
	}

	mmChtimes.defaultExpectation.params = &FileSystemMockChtimesParams{name, atime, mtime}
	for _, e := range mmChtimes.expectations {
		if minimock.Equal(e.params, mmChtimes.defaultExpectation.params) {
			mmChtimes.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmChtimes.defaultExpectation.params)
		}
	}

	return mmChtimes
}

// Inspect accepts an inspector function that has same arguments as the FileSystem.Chtimes
func (mmChtimes *mFileSystemMockChtimes) Inspect(f func(name string, atime time.Time, mtime time.Time)) *mFileSystemMockChtimes {
	if mmChtimes.mock.inspectFuncChtimes != nil {
		mmChtimes.mock.t.Fatalf("Inspect function is already set for FileSystemMock.Chtimes")
	}

	mmChtimes.mock.inspectFuncChtimes = f

	return mmChtimes
}

// Return sets up results that will be returned by FileSystem.Chtimes
func (mmChtimes *mFileSystemMockChtimes) Return(err error) *FileSystemMock {
	if mmChtimes.mock.funcChtimes != nil {
		mmChtimes.mock.t.Fatalf("FileSystemMock.Chtimes mock is already set by Set")
	}

	if mmChtimes.defaultExpectation == nil {
		mmChtimes.defaultExpectation = &FileSystemMockChtimesExpectation{mock: mmChtimes.mock}
	}
	mmChtimes.defaultExpectation.results = &FileSystemMockChtimesResults{err}
	return mmChtimes.mock
}

//Set uses given function f to mock the FileSystem.Chtimes method
func (mmChtimes *mFileSystemMockChtimes) Set(f func(name string, atime time.Time, mtime time.Time) (err error)) *FileSystemMock {
	if mmChtimes.defaultExpectation != nil {
		mmChtimes.mock.t.Fatalf("Default expectation is already set for the FileSystem.Chtimes method")
	}

	if len(mmChtimes.expectations) > 0 {
		mmChtimes.mock.t.Fatalf("Some expectations are already set for the FileSystem.Chtimes method")
	}

	mmChtimes.mock.funcChtimes = f
	return mmChtimes.mock
}

// When sets expectation for the FileSystem.Chtimes which will trigger the result defined by the following
// Then helper
func (mmChtimes *mFileSystemMockChtimes) When(name string, atime time.Time, mtime time.Time) *FileSystemMockChtimesExpectation {
	if mmChtimes.mock.funcChtimes != nil {
		mmChtimes.mock.t.Fatalf("FileSystemMock.Chtimes mock is already set by Set")
	}

	expectation := &FileSystemMockChtimesExpectation{
		mock:   mmChtimes.mock,
		params: &FileSystemMockChtimesParams{name, atime, mtime},
	}
	mmChtimes.expectations = append(mmChtimes.expectations, expectation)
	return expectation
}

// Then sets up FileSystem.Chtimes return parameters for the expectation previously defined by the When method
func (e *FileSystemMockChtimesExpectation) Then(err error) *FileSystemMock {
	e.results = &FileSystemMockChtimesResults{err}
	return e.mock
}

// Chtimes implements infrastructure.FileSystem
func (mmChtimes *FileSystemMock) Chtimes(name string, atime time.Time, mtime time.Time) (err error) {
	mm_atomic.AddUint64(&mmChtimes.beforeChtimesCounter, 1)
	defer mm_atomic.AddUint64(&mmChtimes.afterChtimesCounter, 1)

	if mmChtimes.inspectFuncChtimes != nil {
		mmChtimes.inspectFuncChtimes(name, atime, mtime)
	}

	mm_params := &FileSystemMockChtimesParams{name, atime, mtime}

	// Record call args
	mmChtimes.ChtimesMock.mutex.Lock()
	mmChtimes.ChtimesMock.callArgs = append(mmChtimes.ChtimesMock.callArgs, mm_params)
	mmChtimes.ChtimesMock.mutex.Unlock()

	for _, e := range mmChtimes.ChtimesMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmChtimes.ChtimesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmChtimes.ChtimesMock.defaultExpectation.Counter, 1)
		mm_want := mmChtimes.ChtimesMock.defaultExpectation.params
		mm_got := FileSystemMockChtimesParams{name, atime, mtime}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmChtimes.t.Errorf("FileSystemMock.Chtimes got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmChtimes.ChtimesMock.defaultExpectation.results
		if mm_results == nil {
			mmChtimes.t.Fatal("No results are set for the FileSystemMock.Chtimes")
		}
		return (*mm_results).err
	}
	if mmChtimes.funcChtimes != nil {
		return mmChtimes.funcChtimes(name, atime, mtime)
	}
	mmChtimes.t.Fatalf("Unexpected call to FileSystemMock.Chtimes. %v %v %v", name, atime, mtime)
	return
}

// ChtimesAfterCounter returns a count of finished FileSystemMock.Chtimes invocations
func (mmChtimes *FileSystemMock) ChtimesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmChtimes.afterChtimesCounter)
}

// ChtimesBeforeCounter returns a count of FileSystemMock.Chtimes invocations
func (mmChtimes *FileSystemMock) ChtimesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmChtimes.beforeChtimesCounter)
}

// Calls returns a list of arguments used in each call to FileSystemMock.Chtimes.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmChtimes *mFileSystemMockChtimes) Calls() []*FileSystemMockChtimesParams {
	mmChtimes.mutex.RLock()

	argCopy := make([]*FileSystemMockChtimesParams, len(mmChtimes.callArgs))
	copy(argCopy, mmChtimes.callArgs)

	mmChtimes.mutex.RUnlock()

	return argCopy
}

// MinimockChtimesDone returns true if the count of the Chtimes invocations corresponds
// the number of defined expectations
func (m *FileSystemMock) MinimockChtimesDone() bool {
	for _, e := range m.ChtimesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ChtimesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterChtimesCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcChtimes != nil && mm_atomic.LoadUint64(&m.afterChtimesCounter) < 1 {
		return false
	}
	return true
}

// MinimockChtimesInspect logs each unmet expectation
func (m *FileSystemMock) MinimockChtimesInspect() {
	for _, e := range m.ChtimesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FileSystemMock.Chtimes with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ChtimesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterChtimesCounter) < 1 {
		if m.ChtimesMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FileSystemMock.Chtimes")
		} else {
			m.t.Errorf("Expected call to FileSystemMock.Chtimes with params: %#v", *m.ChtimesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcChtimes != nil && mm_atomic.LoadUint64(&m.afterChtimesCounter) < 1 {
		m.t.Error("Expected call to FileSystemMock.Chtimes")
	}
}

type mFileSystemMockCreate struct {
	mock               *FileSystemMock
	defaultExpectation *FileSystemMockCreateExpectation
	expectations       []*FileSystemMockCreateExpectation

	callArgs []*FileSystemMockCreateParams
	mutex    sync.RWMutex
}

// FileSystemMockCreateExpectation specifies expectation struct of the FileSystem.Create
type FileSystemMockCreateExpectation struct {
	mock    *FileSystemMock
	params  *FileSystemMockCreateParams
	results *FileSystemMockCreateResults
	Counter uint64
}

// FileSystemMockCreateParams contains parameters of the FileSystem.Create
type FileSystemMockCreateParams struct {
	name string
}

// FileSystemMockCreateResults contains results of the FileSystem.Create
type FileSystemMockCreateResults struct {
	f1  afero.File
	err error
}

// Expect sets up expected params for FileSystem.Create
func (mmCreate *mFileSystemMockCreate) Expect(name string) *mFileSystemMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("FileSystemMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &FileSystemMockCreateExpectation{}
	}

	mmCreate.defaultExpectation.params = &FileSystemMockCreateParams{name}
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the FileSystem.Create
func (mmCreate *mFileSystemMockCreate) Inspect(f func(name string)) *mFileSystemMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for FileSystemMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by FileSystem.Create
func (mmCreate *mFileSystemMockCreate) Return(f1 afero.File, err error) *FileSystemMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("FileSystemMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &FileSystemMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &FileSystemMockCreateResults{f1, err}
	return mmCreate.mock
}

//Set uses given function f to mock the FileSystem.Create method
func (mmCreate *mFileSystemMockCreate) Set(f func(name string) (f1 afero.File, err error)) *FileSystemMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the FileSystem.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the FileSystem.Create method")
	}

	mmCreate.mock.funcCreate = f
	return mmCreate.mock
}

// When sets expectation for the FileSystem.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mFileSystemMockCreate) When(name string) *FileSystemMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("FileSystemMock.Create mock is already set by Set")
	}

	expectation := &FileSystemMockCreateExpectation{
		mock:   mmCreate.mock,
		params: &FileSystemMockCreateParams{name},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up FileSystem.Create return parameters for the expectation previously defined by the When method
func (e *FileSystemMockCreateExpectation) Then(f1 afero.File, err error) *FileSystemMock {
	e.results = &FileSystemMockCreateResults{f1, err}
	return e.mock
}

// Create implements infrastructure.FileSystem
func (mmCreate *FileSystemMock) Create(name string) (f1 afero.File, err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(name)
	}

	mm_params := &FileSystemMockCreateParams{name}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.f1, e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_got := FileSystemMockCreateParams{name}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("FileSystemMock.Create got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the FileSystemMock.Create")
		}
		return (*mm_results).f1, (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(name)
	}
	mmCreate.t.Fatalf("Unexpected call to FileSystemMock.Create. %v", name)
	return
}

// CreateAfterCounter returns a count of finished FileSystemMock.Create invocations
func (mmCreate *FileSystemMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of FileSystemMock.Create invocations
func (mmCreate *FileSystemMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to FileSystemMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mFileSystemMockCreate) Calls() []*FileSystemMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*FileSystemMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *FileSystemMock) MinimockCreateDone() bool {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateInspect logs each unmet expectation
func (m *FileSystemMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FileSystemMock.Create with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FileSystemMock.Create")
		} else {
			m.t.Errorf("Expected call to FileSystemMock.Create with params: %#v", *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		m.t.Error("Expected call to FileSystemMock.Create")
	}
}

type mFileSystemMockMkdir struct {
	mock               *FileSystemMock
	defaultExpectation *FileSystemMockMkdirExpectation
	expectations       []*FileSystemMockMkdirExpectation

	callArgs []*FileSystemMockMkdirParams
	mutex    sync.RWMutex
}

// FileSystemMockMkdirExpectation specifies expectation struct of the FileSystem.Mkdir
type FileSystemMockMkdirExpectation struct {
	mock    *FileSystemMock
	params  *FileSystemMockMkdirParams
	results *FileSystemMockMkdirResults
	Counter uint64
}

// FileSystemMockMkdirParams contains parameters of the FileSystem.Mkdir
type FileSystemMockMkdirParams struct {
	name string
	perm os.FileMode
}

// FileSystemMockMkdirResults contains results of the FileSystem.Mkdir
type FileSystemMockMkdirResults struct {
	err error
}

// Expect sets up expected params for FileSystem.Mkdir
func (mmMkdir *mFileSystemMockMkdir) Expect(name string, perm os.FileMode) *mFileSystemMockMkdir {
	if mmMkdir.mock.funcMkdir != nil {
		mmMkdir.mock.t.Fatalf("FileSystemMock.Mkdir mock is already set by Set")
	}

	if mmMkdir.defaultExpectation == nil {
		mmMkdir.defaultExpectation = &FileSystemMockMkdirExpectation{}
	}

	mmMkdir.defaultExpectation.params = &FileSystemMockMkdirParams{name, perm}
	for _, e := range mmMkdir.expectations {
		if minimock.Equal(e.params, mmMkdir.defaultExpectation.params) {
			mmMkdir.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmMkdir.defaultExpectation.params)
		}
	}

	return mmMkdir
}

// Inspect accepts an inspector function that has same arguments as the FileSystem.Mkdir
func (mmMkdir *mFileSystemMockMkdir) Inspect(f func(name string, perm os.FileMode)) *mFileSystemMockMkdir {
	if mmMkdir.mock.inspectFuncMkdir != nil {
		mmMkdir.mock.t.Fatalf("Inspect function is already set for FileSystemMock.Mkdir")
	}

	mmMkdir.mock.inspectFuncMkdir = f

	return mmMkdir
}

// Return sets up results that will be returned by FileSystem.Mkdir
func (mmMkdir *mFileSystemMockMkdir) Return(err error) *FileSystemMock {
	if mmMkdir.mock.funcMkdir != nil {
		mmMkdir.mock.t.Fatalf("FileSystemMock.Mkdir mock is already set by Set")
	}

	if mmMkdir.defaultExpectation == nil {
		mmMkdir.defaultExpectation = &FileSystemMockMkdirExpectation{mock: mmMkdir.mock}
	}
	mmMkdir.defaultExpectation.results = &FileSystemMockMkdirResults{err}
	return mmMkdir.mock
}

//Set uses given function f to mock the FileSystem.Mkdir method
func (mmMkdir *mFileSystemMockMkdir) Set(f func(name string, perm os.FileMode) (err error)) *FileSystemMock {
	if mmMkdir.defaultExpectation != nil {
		mmMkdir.mock.t.Fatalf("Default expectation is already set for the FileSystem.Mkdir method")
	}

	if len(mmMkdir.expectations) > 0 {
		mmMkdir.mock.t.Fatalf("Some expectations are already set for the FileSystem.Mkdir method")
	}

	mmMkdir.mock.funcMkdir = f
	return mmMkdir.mock
}

// When sets expectation for the FileSystem.Mkdir which will trigger the result defined by the following
// Then helper
func (mmMkdir *mFileSystemMockMkdir) When(name string, perm os.FileMode) *FileSystemMockMkdirExpectation {
	if mmMkdir.mock.funcMkdir != nil {
		mmMkdir.mock.t.Fatalf("FileSystemMock.Mkdir mock is already set by Set")
	}

	expectation := &FileSystemMockMkdirExpectation{
		mock:   mmMkdir.mock,
		params: &FileSystemMockMkdirParams{name, perm},
	}
	mmMkdir.expectations = append(mmMkdir.expectations, expectation)
	return expectation
}

// Then sets up FileSystem.Mkdir return parameters for the expectation previously defined by the When method
func (e *FileSystemMockMkdirExpectation) Then(err error) *FileSystemMock {
	e.results = &FileSystemMockMkdirResults{err}
	return e.mock
}

// Mkdir implements infrastructure.FileSystem
func (mmMkdir *FileSystemMock) Mkdir(name string, perm os.FileMode) (err error) {
	mm_atomic.AddUint64(&mmMkdir.beforeMkdirCounter, 1)
	defer mm_atomic.AddUint64(&mmMkdir.afterMkdirCounter, 1)

	if mmMkdir.inspectFuncMkdir != nil {
		mmMkdir.inspectFuncMkdir(name, perm)
	}

	mm_params := &FileSystemMockMkdirParams{name, perm}

	// Record call args
	mmMkdir.MkdirMock.mutex.Lock()
	mmMkdir.MkdirMock.callArgs = append(mmMkdir.MkdirMock.callArgs, mm_params)
	mmMkdir.MkdirMock.mutex.Unlock()

	for _, e := range mmMkdir.MkdirMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmMkdir.MkdirMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmMkdir.MkdirMock.defaultExpectation.Counter, 1)
		mm_want := mmMkdir.MkdirMock.defaultExpectation.params
		mm_got := FileSystemMockMkdirParams{name, perm}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmMkdir.t.Errorf("FileSystemMock.Mkdir got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmMkdir.MkdirMock.defaultExpectation.results
		if mm_results == nil {
			mmMkdir.t.Fatal("No results are set for the FileSystemMock.Mkdir")
		}
		return (*mm_results).err
	}
	if mmMkdir.funcMkdir != nil {
		return mmMkdir.funcMkdir(name, perm)
	}
	mmMkdir.t.Fatalf("Unexpected call to FileSystemMock.Mkdir. %v %v", name, perm)
	return
}

// MkdirAfterCounter returns a count of finished FileSystemMock.Mkdir invocations
func (mmMkdir *FileSystemMock) MkdirAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMkdir.afterMkdirCounter)
}

// MkdirBeforeCounter returns a count of FileSystemMock.Mkdir invocations
func (mmMkdir *FileSystemMock) MkdirBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMkdir.beforeMkdirCounter)
}

// Calls returns a list of arguments used in each call to FileSystemMock.Mkdir.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmMkdir *mFileSystemMockMkdir) Calls() []*FileSystemMockMkdirParams {
	mmMkdir.mutex.RLock()

	argCopy := make([]*FileSystemMockMkdirParams, len(mmMkdir.callArgs))
	copy(argCopy, mmMkdir.callArgs)

	mmMkdir.mutex.RUnlock()

	return argCopy
}

// MinimockMkdirDone returns true if the count of the Mkdir invocations corresponds
// the number of defined expectations
func (m *FileSystemMock) MinimockMkdirDone() bool {
	for _, e := range m.MkdirMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MkdirMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMkdirCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMkdir != nil && mm_atomic.LoadUint64(&m.afterMkdirCounter) < 1 {
		return false
	}
	return true
}

// MinimockMkdirInspect logs each unmet expectation
func (m *FileSystemMock) MinimockMkdirInspect() {
	for _, e := range m.MkdirMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FileSystemMock.Mkdir with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MkdirMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMkdirCounter) < 1 {
		if m.MkdirMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FileSystemMock.Mkdir")
		} else {
			m.t.Errorf("Expected call to FileSystemMock.Mkdir with params: %#v", *m.MkdirMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMkdir != nil && mm_atomic.LoadUint64(&m.afterMkdirCounter) < 1 {
		m.t.Error("Expected call to FileSystemMock.Mkdir")
	}
}

type mFileSystemMockMkdirAll struct {
	mock               *FileSystemMock
	defaultExpectation *FileSystemMockMkdirAllExpectation
	expectations       []*FileSystemMockMkdirAllExpectation

	callArgs []*FileSystemMockMkdirAllParams
	mutex    sync.RWMutex
}

// FileSystemMockMkdirAllExpectation specifies expectation struct of the FileSystem.MkdirAll
type FileSystemMockMkdirAllExpectation struct {
	mock    *FileSystemMock
	params  *FileSystemMockMkdirAllParams
	results *FileSystemMockMkdirAllResults
	Counter uint64
}

// FileSystemMockMkdirAllParams contains parameters of the FileSystem.MkdirAll
type FileSystemMockMkdirAllParams struct {
	path string
	perm os.FileMode
}

// FileSystemMockMkdirAllResults contains results of the FileSystem.MkdirAll
type FileSystemMockMkdirAllResults struct {
	err error
}

// Expect sets up expected params for FileSystem.MkdirAll
func (mmMkdirAll *mFileSystemMockMkdirAll) Expect(path string, perm os.FileMode) *mFileSystemMockMkdirAll {
	if mmMkdirAll.mock.funcMkdirAll != nil {
		mmMkdirAll.mock.t.Fatalf("FileSystemMock.MkdirAll mock is already set by Set")
	}

	if mmMkdirAll.defaultExpectation == nil {
		mmMkdirAll.defaultExpectation = &FileSystemMockMkdirAllExpectation{}
	}

	mmMkdirAll.defaultExpectation.params = &FileSystemMockMkdirAllParams{path, perm}
	for _, e := range mmMkdirAll.expectations {
		if minimock.Equal(e.params, mmMkdirAll.defaultExpectation.params) {
			mmMkdirAll.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmMkdirAll.defaultExpectation.params)
		}
	}

	return mmMkdirAll
}

// Inspect accepts an inspector function that has same arguments as the FileSystem.MkdirAll
func (mmMkdirAll *mFileSystemMockMkdirAll) Inspect(f func(path string, perm os.FileMode)) *mFileSystemMockMkdirAll {
	if mmMkdirAll.mock.inspectFuncMkdirAll != nil {
		mmMkdirAll.mock.t.Fatalf("Inspect function is already set for FileSystemMock.MkdirAll")
	}

	mmMkdirAll.mock.inspectFuncMkdirAll = f

	return mmMkdirAll
}

// Return sets up results that will be returned by FileSystem.MkdirAll
func (mmMkdirAll *mFileSystemMockMkdirAll) Return(err error) *FileSystemMock {
	if mmMkdirAll.mock.funcMkdirAll != nil {
		mmMkdirAll.mock.t.Fatalf("FileSystemMock.MkdirAll mock is already set by Set")
	}

	if mmMkdirAll.defaultExpectation == nil {
		mmMkdirAll.defaultExpectation = &FileSystemMockMkdirAllExpectation{mock: mmMkdirAll.mock}
	}
	mmMkdirAll.defaultExpectation.results = &FileSystemMockMkdirAllResults{err}
	return mmMkdirAll.mock
}

//Set uses given function f to mock the FileSystem.MkdirAll method
func (mmMkdirAll *mFileSystemMockMkdirAll) Set(f func(path string, perm os.FileMode) (err error)) *FileSystemMock {
	if mmMkdirAll.defaultExpectation != nil {
		mmMkdirAll.mock.t.Fatalf("Default expectation is already set for the FileSystem.MkdirAll method")
	}

	if len(mmMkdirAll.expectations) > 0 {
		mmMkdirAll.mock.t.Fatalf("Some expectations are already set for the FileSystem.MkdirAll method")
	}

	mmMkdirAll.mock.funcMkdirAll = f
	return mmMkdirAll.mock
}

// When sets expectation for the FileSystem.MkdirAll which will trigger the result defined by the following
// Then helper
func (mmMkdirAll *mFileSystemMockMkdirAll) When(path string, perm os.FileMode) *FileSystemMockMkdirAllExpectation {
	if mmMkdirAll.mock.funcMkdirAll != nil {
		mmMkdirAll.mock.t.Fatalf("FileSystemMock.MkdirAll mock is already set by Set")
	}

	expectation := &FileSystemMockMkdirAllExpectation{
		mock:   mmMkdirAll.mock,
		params: &FileSystemMockMkdirAllParams{path, perm},
	}
	mmMkdirAll.expectations = append(mmMkdirAll.expectations, expectation)
	return expectation
}

// Then sets up FileSystem.MkdirAll return parameters for the expectation previously defined by the When method
func (e *FileSystemMockMkdirAllExpectation) Then(err error) *FileSystemMock {
	e.results = &FileSystemMockMkdirAllResults{err}
	return e.mock
}

// MkdirAll implements infrastructure.FileSystem
func (mmMkdirAll *FileSystemMock) MkdirAll(path string, perm os.FileMode) (err error) {
	mm_atomic.AddUint64(&mmMkdirAll.beforeMkdirAllCounter, 1)
	defer mm_atomic.AddUint64(&mmMkdirAll.afterMkdirAllCounter, 1)

	if mmMkdirAll.inspectFuncMkdirAll != nil {
		mmMkdirAll.inspectFuncMkdirAll(path, perm)
	}

	mm_params := &FileSystemMockMkdirAllParams{path, perm}

	// Record call args
	mmMkdirAll.MkdirAllMock.mutex.Lock()
	mmMkdirAll.MkdirAllMock.callArgs = append(mmMkdirAll.MkdirAllMock.callArgs, mm_params)
	mmMkdirAll.MkdirAllMock.mutex.Unlock()

	for _, e := range mmMkdirAll.MkdirAllMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmMkdirAll.MkdirAllMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmMkdirAll.MkdirAllMock.defaultExpectation.Counter, 1)
		mm_want := mmMkdirAll.MkdirAllMock.defaultExpectation.params
		mm_got := FileSystemMockMkdirAllParams{path, perm}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmMkdirAll.t.Errorf("FileSystemMock.MkdirAll got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmMkdirAll.MkdirAllMock.defaultExpectation.results
		if mm_results == nil {
			mmMkdirAll.t.Fatal("No results are set for the FileSystemMock.MkdirAll")
		}
		return (*mm_results).err
	}
	if mmMkdirAll.funcMkdirAll != nil {
		return mmMkdirAll.funcMkdirAll(path, perm)
	}
	mmMkdirAll.t.Fatalf("Unexpected call to FileSystemMock.MkdirAll. %v %v", path, perm)
	return
}

// MkdirAllAfterCounter returns a count of finished FileSystemMock.MkdirAll invocations
func (mmMkdirAll *FileSystemMock) MkdirAllAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMkdirAll.afterMkdirAllCounter)
}

// MkdirAllBeforeCounter returns a count of FileSystemMock.MkdirAll invocations
func (mmMkdirAll *FileSystemMock) MkdirAllBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMkdirAll.beforeMkdirAllCounter)
}

// Calls returns a list of arguments used in each call to FileSystemMock.MkdirAll.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmMkdirAll *mFileSystemMockMkdirAll) Calls() []*FileSystemMockMkdirAllParams {
	mmMkdirAll.mutex.RLock()

	argCopy := make([]*FileSystemMockMkdirAllParams, len(mmMkdirAll.callArgs))
	copy(argCopy, mmMkdirAll.callArgs)

	mmMkdirAll.mutex.RUnlock()

	return argCopy
}

// MinimockMkdirAllDone returns true if the count of the MkdirAll invocations corresponds
// the number of defined expectations
func (m *FileSystemMock) MinimockMkdirAllDone() bool {
	for _, e := range m.MkdirAllMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MkdirAllMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMkdirAllCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMkdirAll != nil && mm_atomic.LoadUint64(&m.afterMkdirAllCounter) < 1 {
		return false
	}
	return true
}

// MinimockMkdirAllInspect logs each unmet expectation
func (m *FileSystemMock) MinimockMkdirAllInspect() {
	for _, e := range m.MkdirAllMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FileSystemMock.MkdirAll with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MkdirAllMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMkdirAllCounter) < 1 {
		if m.MkdirAllMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FileSystemMock.MkdirAll")
		} else {
			m.t.Errorf("Expected call to FileSystemMock.MkdirAll with params: %#v", *m.MkdirAllMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMkdirAll != nil && mm_atomic.LoadUint64(&m.afterMkdirAllCounter) < 1 {
		m.t.Error("Expected call to FileSystemMock.MkdirAll")
	}
}

type mFileSystemMockName struct {
	mock               *FileSystemMock
	defaultExpectation *FileSystemMockNameExpectation
	expectations       []*FileSystemMockNameExpectation
}

// FileSystemMockNameExpectation specifies expectation struct of the FileSystem.Name
type FileSystemMockNameExpectation struct {
	mock *FileSystemMock

	results *FileSystemMockNameResults
	Counter uint64
}

// FileSystemMockNameResults contains results of the FileSystem.Name
type FileSystemMockNameResults struct {
	s1 string
}

// Expect sets up expected params for FileSystem.Name
func (mmName *mFileSystemMockName) Expect() *mFileSystemMockName {
	if mmName.mock.funcName != nil {
		mmName.mock.t.Fatalf("FileSystemMock.Name mock is already set by Set")
	}

	if mmName.defaultExpectation == nil {
		mmName.defaultExpectation = &FileSystemMockNameExpectation{}
	}

	return mmName
}

// Inspect accepts an inspector function that has same arguments as the FileSystem.Name
func (mmName *mFileSystemMockName) Inspect(f func()) *mFileSystemMockName {
	if mmName.mock.inspectFuncName != nil {
		mmName.mock.t.Fatalf("Inspect function is already set for FileSystemMock.Name")
	}

	mmName.mock.inspectFuncName = f

	return mmName
}

// Return sets up results that will be returned by FileSystem.Name
func (mmName *mFileSystemMockName) Return(s1 string) *FileSystemMock {
	if mmName.mock.funcName != nil {
		mmName.mock.t.Fatalf("FileSystemMock.Name mock is already set by Set")
	}

	if mmName.defaultExpectation == nil {
		mmName.defaultExpectation = &FileSystemMockNameExpectation{mock: mmName.mock}
	}
	mmName.defaultExpectation.results = &FileSystemMockNameResults{s1}
	return mmName.mock
}

//Set uses given function f to mock the FileSystem.Name method
func (mmName *mFileSystemMockName) Set(f func() (s1 string)) *FileSystemMock {
	if mmName.defaultExpectation != nil {
		mmName.mock.t.Fatalf("Default expectation is already set for the FileSystem.Name method")
	}

	if len(mmName.expectations) > 0 {
		mmName.mock.t.Fatalf("Some expectations are already set for the FileSystem.Name method")
	}

	mmName.mock.funcName = f
	return mmName.mock
}

// Name implements infrastructure.FileSystem
func (mmName *FileSystemMock) Name() (s1 string) {
	mm_atomic.AddUint64(&mmName.beforeNameCounter, 1)
	defer mm_atomic.AddUint64(&mmName.afterNameCounter, 1)

	if mmName.inspectFuncName != nil {
		mmName.inspectFuncName()
	}

	if mmName.NameMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmName.NameMock.defaultExpectation.Counter, 1)

		mm_results := mmName.NameMock.defaultExpectation.results
		if mm_results == nil {
			mmName.t.Fatal("No results are set for the FileSystemMock.Name")
		}
		return (*mm_results).s1
	}
	if mmName.funcName != nil {
		return mmName.funcName()
	}
	mmName.t.Fatalf("Unexpected call to FileSystemMock.Name.")
	return
}

// NameAfterCounter returns a count of finished FileSystemMock.Name invocations
func (mmName *FileSystemMock) NameAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmName.afterNameCounter)
}

// NameBeforeCounter returns a count of FileSystemMock.Name invocations
func (mmName *FileSystemMock) NameBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmName.beforeNameCounter)
}

// MinimockNameDone returns true if the count of the Name invocations corresponds
// the number of defined expectations
func (m *FileSystemMock) MinimockNameDone() bool {
	for _, e := range m.NameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.NameMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterNameCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcName != nil && mm_atomic.LoadUint64(&m.afterNameCounter) < 1 {
		return false
	}
	return true
}

// MinimockNameInspect logs each unmet expectation
func (m *FileSystemMock) MinimockNameInspect() {
	for _, e := range m.NameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to FileSystemMock.Name")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.NameMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterNameCounter) < 1 {
		m.t.Error("Expected call to FileSystemMock.Name")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcName != nil && mm_atomic.LoadUint64(&m.afterNameCounter) < 1 {
		m.t.Error("Expected call to FileSystemMock.Name")
	}
}

type mFileSystemMockOpen struct {
	mock               *FileSystemMock
	defaultExpectation *FileSystemMockOpenExpectation
	expectations       []*FileSystemMockOpenExpectation

	callArgs []*FileSystemMockOpenParams
	mutex    sync.RWMutex
}

// FileSystemMockOpenExpectation specifies expectation struct of the FileSystem.Open
type FileSystemMockOpenExpectation struct {
	mock    *FileSystemMock
	params  *FileSystemMockOpenParams
	results *FileSystemMockOpenResults
	Counter uint64
}

// FileSystemMockOpenParams contains parameters of the FileSystem.Open
type FileSystemMockOpenParams struct {
	name string
}

// FileSystemMockOpenResults contains results of the FileSystem.Open
type FileSystemMockOpenResults struct {
	f1  afero.File
	err error
}

// Expect sets up expected params for FileSystem.Open
func (mmOpen *mFileSystemMockOpen) Expect(name string) *mFileSystemMockOpen {
	if mmOpen.mock.funcOpen != nil {
		mmOpen.mock.t.Fatalf("FileSystemMock.Open mock is already set by Set")
	}

	if mmOpen.defaultExpectation == nil {
		mmOpen.defaultExpectation = &FileSystemMockOpenExpectation{}
	}

	mmOpen.defaultExpectation.params = &FileSystemMockOpenParams{name}
	for _, e := range mmOpen.expectations {
		if minimock.Equal(e.params, mmOpen.defaultExpectation.params) {
			mmOpen.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmOpen.defaultExpectation.params)
		}
	}

	return mmOpen
}

// Inspect accepts an inspector function that has same arguments as the FileSystem.Open
func (mmOpen *mFileSystemMockOpen) Inspect(f func(name string)) *mFileSystemMockOpen {
	if mmOpen.mock.inspectFuncOpen != nil {
		mmOpen.mock.t.Fatalf("Inspect function is already set for FileSystemMock.Open")
	}

	mmOpen.mock.inspectFuncOpen = f

	return mmOpen
}

// Return sets up results that will be returned by FileSystem.Open
func (mmOpen *mFileSystemMockOpen) Return(f1 afero.File, err error) *FileSystemMock {
	if mmOpen.mock.funcOpen != nil {
		mmOpen.mock.t.Fatalf("FileSystemMock.Open mock is already set by Set")
	}

	if mmOpen.defaultExpectation == nil {
		mmOpen.defaultExpectation = &FileSystemMockOpenExpectation{mock: mmOpen.mock}
	}
	mmOpen.defaultExpectation.results = &FileSystemMockOpenResults{f1, err}
	return mmOpen.mock
}

//Set uses given function f to mock the FileSystem.Open method
func (mmOpen *mFileSystemMockOpen) Set(f func(name string) (f1 afero.File, err error)) *FileSystemMock {
	if mmOpen.defaultExpectation != nil {
		mmOpen.mock.t.Fatalf("Default expectation is already set for the FileSystem.Open method")
	}

	if len(mmOpen.expectations) > 0 {
		mmOpen.mock.t.Fatalf("Some expectations are already set for the FileSystem.Open method")
	}

	mmOpen.mock.funcOpen = f
	return mmOpen.mock
}

// When sets expectation for the FileSystem.Open which will trigger the result defined by the following
// Then helper
func (mmOpen *mFileSystemMockOpen) When(name string) *FileSystemMockOpenExpectation {
	if mmOpen.mock.funcOpen != nil {
		mmOpen.mock.t.Fatalf("FileSystemMock.Open mock is already set by Set")
	}

	expectation := &FileSystemMockOpenExpectation{
		mock:   mmOpen.mock,
		params: &FileSystemMockOpenParams{name},
	}
	mmOpen.expectations = append(mmOpen.expectations, expectation)
	return expectation
}

// Then sets up FileSystem.Open return parameters for the expectation previously defined by the When method
func (e *FileSystemMockOpenExpectation) Then(f1 afero.File, err error) *FileSystemMock {
	e.results = &FileSystemMockOpenResults{f1, err}
	return e.mock
}

// Open implements infrastructure.FileSystem
func (mmOpen *FileSystemMock) Open(name string) (f1 afero.File, err error) {
	mm_atomic.AddUint64(&mmOpen.beforeOpenCounter, 1)
	defer mm_atomic.AddUint64(&mmOpen.afterOpenCounter, 1)

	if mmOpen.inspectFuncOpen != nil {
		mmOpen.inspectFuncOpen(name)
	}

	mm_params := &FileSystemMockOpenParams{name}

	// Record call args
	mmOpen.OpenMock.mutex.Lock()
	mmOpen.OpenMock.callArgs = append(mmOpen.OpenMock.callArgs, mm_params)
	mmOpen.OpenMock.mutex.Unlock()

	for _, e := range mmOpen.OpenMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.f1, e.results.err
		}
	}

	if mmOpen.OpenMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmOpen.OpenMock.defaultExpectation.Counter, 1)
		mm_want := mmOpen.OpenMock.defaultExpectation.params
		mm_got := FileSystemMockOpenParams{name}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmOpen.t.Errorf("FileSystemMock.Open got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmOpen.OpenMock.defaultExpectation.results
		if mm_results == nil {
			mmOpen.t.Fatal("No results are set for the FileSystemMock.Open")
		}
		return (*mm_results).f1, (*mm_results).err
	}
	if mmOpen.funcOpen != nil {
		return mmOpen.funcOpen(name)
	}
	mmOpen.t.Fatalf("Unexpected call to FileSystemMock.Open. %v", name)
	return
}

// OpenAfterCounter returns a count of finished FileSystemMock.Open invocations
func (mmOpen *FileSystemMock) OpenAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOpen.afterOpenCounter)
}

// OpenBeforeCounter returns a count of FileSystemMock.Open invocations
func (mmOpen *FileSystemMock) OpenBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOpen.beforeOpenCounter)
}

// Calls returns a list of arguments used in each call to FileSystemMock.Open.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmOpen *mFileSystemMockOpen) Calls() []*FileSystemMockOpenParams {
	mmOpen.mutex.RLock()

	argCopy := make([]*FileSystemMockOpenParams, len(mmOpen.callArgs))
	copy(argCopy, mmOpen.callArgs)

	mmOpen.mutex.RUnlock()

	return argCopy
}

// MinimockOpenDone returns true if the count of the Open invocations corresponds
// the number of defined expectations
func (m *FileSystemMock) MinimockOpenDone() bool {
	for _, e := range m.OpenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OpenMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOpenCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOpen != nil && mm_atomic.LoadUint64(&m.afterOpenCounter) < 1 {
		return false
	}
	return true
}

// MinimockOpenInspect logs each unmet expectation
func (m *FileSystemMock) MinimockOpenInspect() {
	for _, e := range m.OpenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FileSystemMock.Open with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OpenMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOpenCounter) < 1 {
		if m.OpenMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FileSystemMock.Open")
		} else {
			m.t.Errorf("Expected call to FileSystemMock.Open with params: %#v", *m.OpenMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOpen != nil && mm_atomic.LoadUint64(&m.afterOpenCounter) < 1 {
		m.t.Error("Expected call to FileSystemMock.Open")
	}
}

type mFileSystemMockOpenFile struct {
	mock               *FileSystemMock
	defaultExpectation *FileSystemMockOpenFileExpectation
	expectations       []*FileSystemMockOpenFileExpectation

	callArgs []*FileSystemMockOpenFileParams
	mutex    sync.RWMutex
}

// FileSystemMockOpenFileExpectation specifies expectation struct of the FileSystem.OpenFile
type FileSystemMockOpenFileExpectation struct {
	mock    *FileSystemMock
	params  *FileSystemMockOpenFileParams
	results *FileSystemMockOpenFileResults
	Counter uint64
}

// FileSystemMockOpenFileParams contains parameters of the FileSystem.OpenFile
type FileSystemMockOpenFileParams struct {
	name string
	flag int
	perm os.FileMode
}

// FileSystemMockOpenFileResults contains results of the FileSystem.OpenFile
type FileSystemMockOpenFileResults struct {
	f1  afero.File
	err error
}

// Expect sets up expected params for FileSystem.OpenFile
func (mmOpenFile *mFileSystemMockOpenFile) Expect(name string, flag int, perm os.FileMode) *mFileSystemMockOpenFile {
	if mmOpenFile.mock.funcOpenFile != nil {
		mmOpenFile.mock.t.Fatalf("FileSystemMock.OpenFile mock is already set by Set")
	}

	if mmOpenFile.defaultExpectation == nil {
		mmOpenFile.defaultExpectation = &FileSystemMockOpenFileExpectation{}
	}

	mmOpenFile.defaultExpectation.params = &FileSystemMockOpenFileParams{name, flag, perm}
	for _, e := range mmOpenFile.expectations {
		if minimock.Equal(e.params, mmOpenFile.defaultExpectation.params) {
			mmOpenFile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmOpenFile.defaultExpectation.params)
		}
	}

	return mmOpenFile
}

// Inspect accepts an inspector function that has same arguments as the FileSystem.OpenFile
func (mmOpenFile *mFileSystemMockOpenFile) Inspect(f func(name string, flag int, perm os.FileMode)) *mFileSystemMockOpenFile {
	if mmOpenFile.mock.inspectFuncOpenFile != nil {
		mmOpenFile.mock.t.Fatalf("Inspect function is already set for FileSystemMock.OpenFile")
	}

	mmOpenFile.mock.inspectFuncOpenFile = f

	return mmOpenFile
}

// Return sets up results that will be returned by FileSystem.OpenFile
func (mmOpenFile *mFileSystemMockOpenFile) Return(f1 afero.File, err error) *FileSystemMock {
	if mmOpenFile.mock.funcOpenFile != nil {
		mmOpenFile.mock.t.Fatalf("FileSystemMock.OpenFile mock is already set by Set")
	}

	if mmOpenFile.defaultExpectation == nil {
		mmOpenFile.defaultExpectation = &FileSystemMockOpenFileExpectation{mock: mmOpenFile.mock}
	}
	mmOpenFile.defaultExpectation.results = &FileSystemMockOpenFileResults{f1, err}
	return mmOpenFile.mock
}

//Set uses given function f to mock the FileSystem.OpenFile method
func (mmOpenFile *mFileSystemMockOpenFile) Set(f func(name string, flag int, perm os.FileMode) (f1 afero.File, err error)) *FileSystemMock {
	if mmOpenFile.defaultExpectation != nil {
		mmOpenFile.mock.t.Fatalf("Default expectation is already set for the FileSystem.OpenFile method")
	}

	if len(mmOpenFile.expectations) > 0 {
		mmOpenFile.mock.t.Fatalf("Some expectations are already set for the FileSystem.OpenFile method")
	}

	mmOpenFile.mock.funcOpenFile = f
	return mmOpenFile.mock
}

// When sets expectation for the FileSystem.OpenFile which will trigger the result defined by the following
// Then helper
func (mmOpenFile *mFileSystemMockOpenFile) When(name string, flag int, perm os.FileMode) *FileSystemMockOpenFileExpectation {
	if mmOpenFile.mock.funcOpenFile != nil {
		mmOpenFile.mock.t.Fatalf("FileSystemMock.OpenFile mock is already set by Set")
	}

	expectation := &FileSystemMockOpenFileExpectation{
		mock:   mmOpenFile.mock,
		params: &FileSystemMockOpenFileParams{name, flag, perm},
	}
	mmOpenFile.expectations = append(mmOpenFile.expectations, expectation)
	return expectation
}

// Then sets up FileSystem.OpenFile return parameters for the expectation previously defined by the When method
func (e *FileSystemMockOpenFileExpectation) Then(f1 afero.File, err error) *FileSystemMock {
	e.results = &FileSystemMockOpenFileResults{f1, err}
	return e.mock
}

// OpenFile implements infrastructure.FileSystem
func (mmOpenFile *FileSystemMock) OpenFile(name string, flag int, perm os.FileMode) (f1 afero.File, err error) {
	mm_atomic.AddUint64(&mmOpenFile.beforeOpenFileCounter, 1)
	defer mm_atomic.AddUint64(&mmOpenFile.afterOpenFileCounter, 1)

	if mmOpenFile.inspectFuncOpenFile != nil {
		mmOpenFile.inspectFuncOpenFile(name, flag, perm)
	}

	mm_params := &FileSystemMockOpenFileParams{name, flag, perm}

	// Record call args
	mmOpenFile.OpenFileMock.mutex.Lock()
	mmOpenFile.OpenFileMock.callArgs = append(mmOpenFile.OpenFileMock.callArgs, mm_params)
	mmOpenFile.OpenFileMock.mutex.Unlock()

	for _, e := range mmOpenFile.OpenFileMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.f1, e.results.err
		}
	}

	if mmOpenFile.OpenFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmOpenFile.OpenFileMock.defaultExpectation.Counter, 1)
		mm_want := mmOpenFile.OpenFileMock.defaultExpectation.params
		mm_got := FileSystemMockOpenFileParams{name, flag, perm}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmOpenFile.t.Errorf("FileSystemMock.OpenFile got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmOpenFile.OpenFileMock.defaultExpectation.results
		if mm_results == nil {
			mmOpenFile.t.Fatal("No results are set for the FileSystemMock.OpenFile")
		}
		return (*mm_results).f1, (*mm_results).err
	}
	if mmOpenFile.funcOpenFile != nil {
		return mmOpenFile.funcOpenFile(name, flag, perm)
	}
	mmOpenFile.t.Fatalf("Unexpected call to FileSystemMock.OpenFile. %v %v %v", name, flag, perm)
	return
}

// OpenFileAfterCounter returns a count of finished FileSystemMock.OpenFile invocations
func (mmOpenFile *FileSystemMock) OpenFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOpenFile.afterOpenFileCounter)
}

// OpenFileBeforeCounter returns a count of FileSystemMock.OpenFile invocations
func (mmOpenFile *FileSystemMock) OpenFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOpenFile.beforeOpenFileCounter)
}

// Calls returns a list of arguments used in each call to FileSystemMock.OpenFile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmOpenFile *mFileSystemMockOpenFile) Calls() []*FileSystemMockOpenFileParams {
	mmOpenFile.mutex.RLock()

	argCopy := make([]*FileSystemMockOpenFileParams, len(mmOpenFile.callArgs))
	copy(argCopy, mmOpenFile.callArgs)

	mmOpenFile.mutex.RUnlock()

	return argCopy
}

// MinimockOpenFileDone returns true if the count of the OpenFile invocations corresponds
// the number of defined expectations
func (m *FileSystemMock) MinimockOpenFileDone() bool {
	for _, e := range m.OpenFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OpenFileMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOpenFileCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOpenFile != nil && mm_atomic.LoadUint64(&m.afterOpenFileCounter) < 1 {
		return false
	}
	return true
}

// MinimockOpenFileInspect logs each unmet expectation
func (m *FileSystemMock) MinimockOpenFileInspect() {
	for _, e := range m.OpenFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FileSystemMock.OpenFile with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OpenFileMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOpenFileCounter) < 1 {
		if m.OpenFileMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FileSystemMock.OpenFile")
		} else {
			m.t.Errorf("Expected call to FileSystemMock.OpenFile with params: %#v", *m.OpenFileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOpenFile != nil && mm_atomic.LoadUint64(&m.afterOpenFileCounter) < 1 {
		m.t.Error("Expected call to FileSystemMock.OpenFile")
	}
}

type mFileSystemMockRemove struct {
	mock               *FileSystemMock
	defaultExpectation *FileSystemMockRemoveExpectation
	expectations       []*FileSystemMockRemoveExpectation

	callArgs []*FileSystemMockRemoveParams
	mutex    sync.RWMutex
}

// FileSystemMockRemoveExpectation specifies expectation struct of the FileSystem.Remove
type FileSystemMockRemoveExpectation struct {
	mock    *FileSystemMock
	params  *FileSystemMockRemoveParams
	results *FileSystemMockRemoveResults
	Counter uint64
}

// FileSystemMockRemoveParams contains parameters of the FileSystem.Remove
type FileSystemMockRemoveParams struct {
	name string
}

// FileSystemMockRemoveResults contains results of the FileSystem.Remove
type FileSystemMockRemoveResults struct {
	err error
}

// Expect sets up expected params for FileSystem.Remove
func (mmRemove *mFileSystemMockRemove) Expect(name string) *mFileSystemMockRemove {
	if mmRemove.mock.funcRemove != nil {
		mmRemove.mock.t.Fatalf("FileSystemMock.Remove mock is already set by Set")
	}

	if mmRemove.defaultExpectation == nil {
		mmRemove.defaultExpectation = &FileSystemMockRemoveExpectation{}
	}

	mmRemove.defaultExpectation.params = &FileSystemMockRemoveParams{name}
	for _, e := range mmRemove.expectations {
		if minimock.Equal(e.params, mmRemove.defaultExpectation.params) {
			mmRemove.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRemove.defaultExpectation.params)
		}
	}

	return mmRemove
}

// Inspect accepts an inspector function that has same arguments as the FileSystem.Remove
func (mmRemove *mFileSystemMockRemove) Inspect(f func(name string)) *mFileSystemMockRemove {
	if mmRemove.mock.inspectFuncRemove != nil {
		mmRemove.mock.t.Fatalf("Inspect function is already set for FileSystemMock.Remove")
	}

	mmRemove.mock.inspectFuncRemove = f

	return mmRemove
}

// Return sets up results that will be returned by FileSystem.Remove
func (mmRemove *mFileSystemMockRemove) Return(err error) *FileSystemMock {
	if mmRemove.mock.funcRemove != nil {
		mmRemove.mock.t.Fatalf("FileSystemMock.Remove mock is already set by Set")
	}

	if mmRemove.defaultExpectation == nil {
		mmRemove.defaultExpectation = &FileSystemMockRemoveExpectation{mock: mmRemove.mock}
	}
	mmRemove.defaultExpectation.results = &FileSystemMockRemoveResults{err}
	return mmRemove.mock
}

//Set uses given function f to mock the FileSystem.Remove method
func (mmRemove *mFileSystemMockRemove) Set(f func(name string) (err error)) *FileSystemMock {
	if mmRemove.defaultExpectation != nil {
		mmRemove.mock.t.Fatalf("Default expectation is already set for the FileSystem.Remove method")
	}

	if len(mmRemove.expectations) > 0 {
		mmRemove.mock.t.Fatalf("Some expectations are already set for the FileSystem.Remove method")
	}

	mmRemove.mock.funcRemove = f
	return mmRemove.mock
}

// When sets expectation for the FileSystem.Remove which will trigger the result defined by the following
// Then helper
func (mmRemove *mFileSystemMockRemove) When(name string) *FileSystemMockRemoveExpectation {
	if mmRemove.mock.funcRemove != nil {
		mmRemove.mock.t.Fatalf("FileSystemMock.Remove mock is already set by Set")
	}

	expectation := &FileSystemMockRemoveExpectation{
		mock:   mmRemove.mock,
		params: &FileSystemMockRemoveParams{name},
	}
	mmRemove.expectations = append(mmRemove.expectations, expectation)
	return expectation
}

// Then sets up FileSystem.Remove return parameters for the expectation previously defined by the When method
func (e *FileSystemMockRemoveExpectation) Then(err error) *FileSystemMock {
	e.results = &FileSystemMockRemoveResults{err}
	return e.mock
}

// Remove implements infrastructure.FileSystem
func (mmRemove *FileSystemMock) Remove(name string) (err error) {
	mm_atomic.AddUint64(&mmRemove.beforeRemoveCounter, 1)
	defer mm_atomic.AddUint64(&mmRemove.afterRemoveCounter, 1)

	if mmRemove.inspectFuncRemove != nil {
		mmRemove.inspectFuncRemove(name)
	}

	mm_params := &FileSystemMockRemoveParams{name}

	// Record call args
	mmRemove.RemoveMock.mutex.Lock()
	mmRemove.RemoveMock.callArgs = append(mmRemove.RemoveMock.callArgs, mm_params)
	mmRemove.RemoveMock.mutex.Unlock()

	for _, e := range mmRemove.RemoveMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRemove.RemoveMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRemove.RemoveMock.defaultExpectation.Counter, 1)
		mm_want := mmRemove.RemoveMock.defaultExpectation.params
		mm_got := FileSystemMockRemoveParams{name}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRemove.t.Errorf("FileSystemMock.Remove got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRemove.RemoveMock.defaultExpectation.results
		if mm_results == nil {
			mmRemove.t.Fatal("No results are set for the FileSystemMock.Remove")
		}
		return (*mm_results).err
	}
	if mmRemove.funcRemove != nil {
		return mmRemove.funcRemove(name)
	}
	mmRemove.t.Fatalf("Unexpected call to FileSystemMock.Remove. %v", name)
	return
}

// RemoveAfterCounter returns a count of finished FileSystemMock.Remove invocations
func (mmRemove *FileSystemMock) RemoveAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemove.afterRemoveCounter)
}

// RemoveBeforeCounter returns a count of FileSystemMock.Remove invocations
func (mmRemove *FileSystemMock) RemoveBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemove.beforeRemoveCounter)
}

// Calls returns a list of arguments used in each call to FileSystemMock.Remove.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRemove *mFileSystemMockRemove) Calls() []*FileSystemMockRemoveParams {
	mmRemove.mutex.RLock()

	argCopy := make([]*FileSystemMockRemoveParams, len(mmRemove.callArgs))
	copy(argCopy, mmRemove.callArgs)

	mmRemove.mutex.RUnlock()

	return argCopy
}

// MinimockRemoveDone returns true if the count of the Remove invocations corresponds
// the number of defined expectations
func (m *FileSystemMock) MinimockRemoveDone() bool {
	for _, e := range m.RemoveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RemoveMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRemoveCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemove != nil && mm_atomic.LoadUint64(&m.afterRemoveCounter) < 1 {
		return false
	}
	return true
}

// MinimockRemoveInspect logs each unmet expectation
func (m *FileSystemMock) MinimockRemoveInspect() {
	for _, e := range m.RemoveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FileSystemMock.Remove with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RemoveMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRemoveCounter) < 1 {
		if m.RemoveMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FileSystemMock.Remove")
		} else {
			m.t.Errorf("Expected call to FileSystemMock.Remove with params: %#v", *m.RemoveMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemove != nil && mm_atomic.LoadUint64(&m.afterRemoveCounter) < 1 {
		m.t.Error("Expected call to FileSystemMock.Remove")
	}
}

type mFileSystemMockRemoveAll struct {
	mock               *FileSystemMock
	defaultExpectation *FileSystemMockRemoveAllExpectation
	expectations       []*FileSystemMockRemoveAllExpectation

	callArgs []*FileSystemMockRemoveAllParams
	mutex    sync.RWMutex
}

// FileSystemMockRemoveAllExpectation specifies expectation struct of the FileSystem.RemoveAll
type FileSystemMockRemoveAllExpectation struct {
	mock    *FileSystemMock
	params  *FileSystemMockRemoveAllParams
	results *FileSystemMockRemoveAllResults
	Counter uint64
}

// FileSystemMockRemoveAllParams contains parameters of the FileSystem.RemoveAll
type FileSystemMockRemoveAllParams struct {
	path string
}

// FileSystemMockRemoveAllResults contains results of the FileSystem.RemoveAll
type FileSystemMockRemoveAllResults struct {
	err error
}

// Expect sets up expected params for FileSystem.RemoveAll
func (mmRemoveAll *mFileSystemMockRemoveAll) Expect(path string) *mFileSystemMockRemoveAll {
	if mmRemoveAll.mock.funcRemoveAll != nil {
		mmRemoveAll.mock.t.Fatalf("FileSystemMock.RemoveAll mock is already set by Set")
	}

	if mmRemoveAll.defaultExpectation == nil {
		mmRemoveAll.defaultExpectation = &FileSystemMockRemoveAllExpectation{}
	}

	mmRemoveAll.defaultExpectation.params = &FileSystemMockRemoveAllParams{path}
	for _, e := range mmRemoveAll.expectations {
		if minimock.Equal(e.params, mmRemoveAll.defaultExpectation.params) {
			mmRemoveAll.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRemoveAll.defaultExpectation.params)
		}
	}

	return mmRemoveAll
}

// Inspect accepts an inspector function that has same arguments as the FileSystem.RemoveAll
func (mmRemoveAll *mFileSystemMockRemoveAll) Inspect(f func(path string)) *mFileSystemMockRemoveAll {
	if mmRemoveAll.mock.inspectFuncRemoveAll != nil {
		mmRemoveAll.mock.t.Fatalf("Inspect function is already set for FileSystemMock.RemoveAll")
	}

	mmRemoveAll.mock.inspectFuncRemoveAll = f

	return mmRemoveAll
}

// Return sets up results that will be returned by FileSystem.RemoveAll
func (mmRemoveAll *mFileSystemMockRemoveAll) Return(err error) *FileSystemMock {
	if mmRemoveAll.mock.funcRemoveAll != nil {
		mmRemoveAll.mock.t.Fatalf("FileSystemMock.RemoveAll mock is already set by Set")
	}

	if mmRemoveAll.defaultExpectation == nil {
		mmRemoveAll.defaultExpectation = &FileSystemMockRemoveAllExpectation{mock: mmRemoveAll.mock}
	}
	mmRemoveAll.defaultExpectation.results = &FileSystemMockRemoveAllResults{err}
	return mmRemoveAll.mock
}

//Set uses given function f to mock the FileSystem.RemoveAll method
func (mmRemoveAll *mFileSystemMockRemoveAll) Set(f func(path string) (err error)) *FileSystemMock {
	if mmRemoveAll.defaultExpectation != nil {
		mmRemoveAll.mock.t.Fatalf("Default expectation is already set for the FileSystem.RemoveAll method")
	}

	if len(mmRemoveAll.expectations) > 0 {
		mmRemoveAll.mock.t.Fatalf("Some expectations are already set for the FileSystem.RemoveAll method")
	}

	mmRemoveAll.mock.funcRemoveAll = f
	return mmRemoveAll.mock
}

// When sets expectation for the FileSystem.RemoveAll which will trigger the result defined by the following
// Then helper
func (mmRemoveAll *mFileSystemMockRemoveAll) When(path string) *FileSystemMockRemoveAllExpectation {
	if mmRemoveAll.mock.funcRemoveAll != nil {
		mmRemoveAll.mock.t.Fatalf("FileSystemMock.RemoveAll mock is already set by Set")
	}

	expectation := &FileSystemMockRemoveAllExpectation{
		mock:   mmRemoveAll.mock,
		params: &FileSystemMockRemoveAllParams{path},
	}
	mmRemoveAll.expectations = append(mmRemoveAll.expectations, expectation)
	return expectation
}

// Then sets up FileSystem.RemoveAll return parameters for the expectation previously defined by the When method
func (e *FileSystemMockRemoveAllExpectation) Then(err error) *FileSystemMock {
	e.results = &FileSystemMockRemoveAllResults{err}
	return e.mock
}

// RemoveAll implements infrastructure.FileSystem
func (mmRemoveAll *FileSystemMock) RemoveAll(path string) (err error) {
	mm_atomic.AddUint64(&mmRemoveAll.beforeRemoveAllCounter, 1)
	defer mm_atomic.AddUint64(&mmRemoveAll.afterRemoveAllCounter, 1)

	if mmRemoveAll.inspectFuncRemoveAll != nil {
		mmRemoveAll.inspectFuncRemoveAll(path)
	}

	mm_params := &FileSystemMockRemoveAllParams{path}

	// Record call args
	mmRemoveAll.RemoveAllMock.mutex.Lock()
	mmRemoveAll.RemoveAllMock.callArgs = append(mmRemoveAll.RemoveAllMock.callArgs, mm_params)
	mmRemoveAll.RemoveAllMock.mutex.Unlock()

	for _, e := range mmRemoveAll.RemoveAllMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRemoveAll.RemoveAllMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRemoveAll.RemoveAllMock.defaultExpectation.Counter, 1)
		mm_want := mmRemoveAll.RemoveAllMock.defaultExpectation.params
		mm_got := FileSystemMockRemoveAllParams{path}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRemoveAll.t.Errorf("FileSystemMock.RemoveAll got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRemoveAll.RemoveAllMock.defaultExpectation.results
		if mm_results == nil {
			mmRemoveAll.t.Fatal("No results are set for the FileSystemMock.RemoveAll")
		}
		return (*mm_results).err
	}
	if mmRemoveAll.funcRemoveAll != nil {
		return mmRemoveAll.funcRemoveAll(path)
	}
	mmRemoveAll.t.Fatalf("Unexpected call to FileSystemMock.RemoveAll. %v", path)
	return
}

// RemoveAllAfterCounter returns a count of finished FileSystemMock.RemoveAll invocations
func (mmRemoveAll *FileSystemMock) RemoveAllAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveAll.afterRemoveAllCounter)
}

// RemoveAllBeforeCounter returns a count of FileSystemMock.RemoveAll invocations
func (mmRemoveAll *FileSystemMock) RemoveAllBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveAll.beforeRemoveAllCounter)
}

// Calls returns a list of arguments used in each call to FileSystemMock.RemoveAll.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRemoveAll *mFileSystemMockRemoveAll) Calls() []*FileSystemMockRemoveAllParams {
	mmRemoveAll.mutex.RLock()

	argCopy := make([]*FileSystemMockRemoveAllParams, len(mmRemoveAll.callArgs))
	copy(argCopy, mmRemoveAll.callArgs)

	mmRemoveAll.mutex.RUnlock()

	return argCopy
}

// MinimockRemoveAllDone returns true if the count of the RemoveAll invocations corresponds
// the number of defined expectations
func (m *FileSystemMock) MinimockRemoveAllDone() bool {
	for _, e := range m.RemoveAllMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RemoveAllMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRemoveAllCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemoveAll != nil && mm_atomic.LoadUint64(&m.afterRemoveAllCounter) < 1 {
		return false
	}
	return true
}

// MinimockRemoveAllInspect logs each unmet expectation
func (m *FileSystemMock) MinimockRemoveAllInspect() {
	for _, e := range m.RemoveAllMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FileSystemMock.RemoveAll with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RemoveAllMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRemoveAllCounter) < 1 {
		if m.RemoveAllMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FileSystemMock.RemoveAll")
		} else {
			m.t.Errorf("Expected call to FileSystemMock.RemoveAll with params: %#v", *m.RemoveAllMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemoveAll != nil && mm_atomic.LoadUint64(&m.afterRemoveAllCounter) < 1 {
		m.t.Error("Expected call to FileSystemMock.RemoveAll")
	}
}

type mFileSystemMockRename struct {
	mock               *FileSystemMock
	defaultExpectation *FileSystemMockRenameExpectation
	expectations       []*FileSystemMockRenameExpectation

	callArgs []*FileSystemMockRenameParams
	mutex    sync.RWMutex
}

// FileSystemMockRenameExpectation specifies expectation struct of the FileSystem.Rename
type FileSystemMockRenameExpectation struct {
	mock    *FileSystemMock
	params  *FileSystemMockRenameParams
	results *FileSystemMockRenameResults
	Counter uint64
}

// FileSystemMockRenameParams contains parameters of the FileSystem.Rename
type FileSystemMockRenameParams struct {
	oldname string
	newname string
}

// FileSystemMockRenameResults contains results of the FileSystem.Rename
type FileSystemMockRenameResults struct {
	err error
}

// Expect sets up expected params for FileSystem.Rename
func (mmRename *mFileSystemMockRename) Expect(oldname string, newname string) *mFileSystemMockRename {
	if mmRename.mock.funcRename != nil {
		mmRename.mock.t.Fatalf("FileSystemMock.Rename mock is already set by Set")
	}

	if mmRename.defaultExpectation == nil {
		mmRename.defaultExpectation = &FileSystemMockRenameExpectation{}
	}

	mmRename.defaultExpectation.params = &FileSystemMockRenameParams{oldname, newname}
	for _, e := range mmRename.expectations {
		if minimock.Equal(e.params, mmRename.defaultExpectation.params) {
			mmRename.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRename.defaultExpectation.params)
		}
	}

	return mmRename
}

// Inspect accepts an inspector function that has same arguments as the FileSystem.Rename
func (mmRename *mFileSystemMockRename) Inspect(f func(oldname string, newname string)) *mFileSystemMockRename {
	if mmRename.mock.inspectFuncRename != nil {
		mmRename.mock.t.Fatalf("Inspect function is already set for FileSystemMock.Rename")
	}

	mmRename.mock.inspectFuncRename = f

	return mmRename
}

// Return sets up results that will be returned by FileSystem.Rename
func (mmRename *mFileSystemMockRename) Return(err error) *FileSystemMock {
	if mmRename.mock.funcRename != nil {
		mmRename.mock.t.Fatalf("FileSystemMock.Rename mock is already set by Set")
	}

	if mmRename.defaultExpectation == nil {
		mmRename.defaultExpectation = &FileSystemMockRenameExpectation{mock: mmRename.mock}
	}
	mmRename.defaultExpectation.results = &FileSystemMockRenameResults{err}
	return mmRename.mock
}

//Set uses given function f to mock the FileSystem.Rename method
func (mmRename *mFileSystemMockRename) Set(f func(oldname string, newname string) (err error)) *FileSystemMock {
	if mmRename.defaultExpectation != nil {
		mmRename.mock.t.Fatalf("Default expectation is already set for the FileSystem.Rename method")
	}

	if len(mmRename.expectations) > 0 {
		mmRename.mock.t.Fatalf("Some expectations are already set for the FileSystem.Rename method")
	}

	mmRename.mock.funcRename = f
	return mmRename.mock
}

// When sets expectation for the FileSystem.Rename which will trigger the result defined by the following
// Then helper
func (mmRename *mFileSystemMockRename) When(oldname string, newname string) *FileSystemMockRenameExpectation {
	if mmRename.mock.funcRename != nil {
		mmRename.mock.t.Fatalf("FileSystemMock.Rename mock is already set by Set")
	}

	expectation := &FileSystemMockRenameExpectation{
		mock:   mmRename.mock,
		params: &FileSystemMockRenameParams{oldname, newname},
	}
	mmRename.expectations = append(mmRename.expectations, expectation)
	return expectation
}

// Then sets up FileSystem.Rename return parameters for the expectation previously defined by the When method
func (e *FileSystemMockRenameExpectation) Then(err error) *FileSystemMock {
	e.results = &FileSystemMockRenameResults{err}
	return e.mock
}

// Rename implements infrastructure.FileSystem
func (mmRename *FileSystemMock) Rename(oldname string, newname string) (err error) {
	mm_atomic.AddUint64(&mmRename.beforeRenameCounter, 1)
	defer mm_atomic.AddUint64(&mmRename.afterRenameCounter, 1)

	if mmRename.inspectFuncRename != nil {
		mmRename.inspectFuncRename(oldname, newname)
	}

	mm_params := &FileSystemMockRenameParams{oldname, newname}

	// Record call args
	mmRename.RenameMock.mutex.Lock()
	mmRename.RenameMock.callArgs = append(mmRename.RenameMock.callArgs, mm_params)
	mmRename.RenameMock.mutex.Unlock()

	for _, e := range mmRename.RenameMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRename.RenameMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRename.RenameMock.defaultExpectation.Counter, 1)
		mm_want := mmRename.RenameMock.defaultExpectation.params
		mm_got := FileSystemMockRenameParams{oldname, newname}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRename.t.Errorf("FileSystemMock.Rename got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRename.RenameMock.defaultExpectation.results
		if mm_results == nil {
			mmRename.t.Fatal("No results are set for the FileSystemMock.Rename")
		}
		return (*mm_results).err
	}
	if mmRename.funcRename != nil {
		return mmRename.funcRename(oldname, newname)
	}
	mmRename.t.Fatalf("Unexpected call to FileSystemMock.Rename. %v %v", oldname, newname)
	return
}

// RenameAfterCounter returns a count of finished FileSystemMock.Rename invocations
func (mmRename *FileSystemMock) RenameAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRename.afterRenameCounter)
}

// RenameBeforeCounter returns a count of FileSystemMock.Rename invocations
func (mmRename *FileSystemMock) RenameBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRename.beforeRenameCounter)
}

// Calls returns a list of arguments used in each call to FileSystemMock.Rename.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRename *mFileSystemMockRename) Calls() []*FileSystemMockRenameParams {
	mmRename.mutex.RLock()

	argCopy := make([]*FileSystemMockRenameParams, len(mmRename.callArgs))
	copy(argCopy, mmRename.callArgs)

	mmRename.mutex.RUnlock()

	return argCopy
}

// MinimockRenameDone returns true if the count of the Rename invocations corresponds
// the number of defined expectations
func (m *FileSystemMock) MinimockRenameDone() bool {
	for _, e := range m.RenameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RenameMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRenameCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRename != nil && mm_atomic.LoadUint64(&m.afterRenameCounter) < 1 {
		return false
	}
	return true
}

// MinimockRenameInspect logs each unmet expectation
func (m *FileSystemMock) MinimockRenameInspect() {
	for _, e := range m.RenameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FileSystemMock.Rename with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RenameMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRenameCounter) < 1 {
		if m.RenameMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FileSystemMock.Rename")
		} else {
			m.t.Errorf("Expected call to FileSystemMock.Rename with params: %#v", *m.RenameMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRename != nil && mm_atomic.LoadUint64(&m.afterRenameCounter) < 1 {
		m.t.Error("Expected call to FileSystemMock.Rename")
	}
}

type mFileSystemMockStat struct {
	mock               *FileSystemMock
	defaultExpectation *FileSystemMockStatExpectation
	expectations       []*FileSystemMockStatExpectation

	callArgs []*FileSystemMockStatParams
	mutex    sync.RWMutex
}

// FileSystemMockStatExpectation specifies expectation struct of the FileSystem.Stat
type FileSystemMockStatExpectation struct {
	mock    *FileSystemMock
	params  *FileSystemMockStatParams
	results *FileSystemMockStatResults
	Counter uint64
}

// FileSystemMockStatParams contains parameters of the FileSystem.Stat
type FileSystemMockStatParams struct {
	name string
}

// FileSystemMockStatResults contains results of the FileSystem.Stat
type FileSystemMockStatResults struct {
	f1  os.FileInfo
	err error
}

// Expect sets up expected params for FileSystem.Stat
func (mmStat *mFileSystemMockStat) Expect(name string) *mFileSystemMockStat {
	if mmStat.mock.funcStat != nil {
		mmStat.mock.t.Fatalf("FileSystemMock.Stat mock is already set by Set")
	}

	if mmStat.defaultExpectation == nil {
		mmStat.defaultExpectation = &FileSystemMockStatExpectation{}
	}

	mmStat.defaultExpectation.params = &FileSystemMockStatParams{name}
	for _, e := range mmStat.expectations {
		if minimock.Equal(e.params, mmStat.defaultExpectation.params) {
			mmStat.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmStat.defaultExpectation.params)
		}
	}

	return mmStat
}

// Inspect accepts an inspector function that has same arguments as the FileSystem.Stat
func (mmStat *mFileSystemMockStat) Inspect(f func(name string)) *mFileSystemMockStat {
	if mmStat.mock.inspectFuncStat != nil {
		mmStat.mock.t.Fatalf("Inspect function is already set for FileSystemMock.Stat")
	}

	mmStat.mock.inspectFuncStat = f

	return mmStat
}

// Return sets up results that will be returned by FileSystem.Stat
func (mmStat *mFileSystemMockStat) Return(f1 os.FileInfo, err error) *FileSystemMock {
	if mmStat.mock.funcStat != nil {
		mmStat.mock.t.Fatalf("FileSystemMock.Stat mock is already set by Set")
	}

	if mmStat.defaultExpectation == nil {
		mmStat.defaultExpectation = &FileSystemMockStatExpectation{mock: mmStat.mock}
	}
	mmStat.defaultExpectation.results = &FileSystemMockStatResults{f1, err}
	return mmStat.mock
}

//Set uses given function f to mock the FileSystem.Stat method
func (mmStat *mFileSystemMockStat) Set(f func(name string) (f1 os.FileInfo, err error)) *FileSystemMock {
	if mmStat.defaultExpectation != nil {
		mmStat.mock.t.Fatalf("Default expectation is already set for the FileSystem.Stat method")
	}

	if len(mmStat.expectations) > 0 {
		mmStat.mock.t.Fatalf("Some expectations are already set for the FileSystem.Stat method")
	}

	mmStat.mock.funcStat = f
	return mmStat.mock
}

// When sets expectation for the FileSystem.Stat which will trigger the result defined by the following
// Then helper
func (mmStat *mFileSystemMockStat) When(name string) *FileSystemMockStatExpectation {
	if mmStat.mock.funcStat != nil {
		mmStat.mock.t.Fatalf("FileSystemMock.Stat mock is already set by Set")
	}

	expectation := &FileSystemMockStatExpectation{
		mock:   mmStat.mock,
		params: &FileSystemMockStatParams{name},
	}
	mmStat.expectations = append(mmStat.expectations, expectation)
	return expectation
}

// Then sets up FileSystem.Stat return parameters for the expectation previously defined by the When method
func (e *FileSystemMockStatExpectation) Then(f1 os.FileInfo, err error) *FileSystemMock {
	e.results = &FileSystemMockStatResults{f1, err}
	return e.mock
}

// Stat implements infrastructure.FileSystem
func (mmStat *FileSystemMock) Stat(name string) (f1 os.FileInfo, err error) {
	mm_atomic.AddUint64(&mmStat.beforeStatCounter, 1)
	defer mm_atomic.AddUint64(&mmStat.afterStatCounter, 1)

	if mmStat.inspectFuncStat != nil {
		mmStat.inspectFuncStat(name)
	}

	mm_params := &FileSystemMockStatParams{name}

	// Record call args
	mmStat.StatMock.mutex.Lock()
	mmStat.StatMock.callArgs = append(mmStat.StatMock.callArgs, mm_params)
	mmStat.StatMock.mutex.Unlock()

	for _, e := range mmStat.StatMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.f1, e.results.err
		}
	}

	if mmStat.StatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmStat.StatMock.defaultExpectation.Counter, 1)
		mm_want := mmStat.StatMock.defaultExpectation.params
		mm_got := FileSystemMockStatParams{name}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmStat.t.Errorf("FileSystemMock.Stat got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmStat.StatMock.defaultExpectation.results
		if mm_results == nil {
			mmStat.t.Fatal("No results are set for the FileSystemMock.Stat")
		}
		return (*mm_results).f1, (*mm_results).err
	}
	if mmStat.funcStat != nil {
		return mmStat.funcStat(name)
	}
	mmStat.t.Fatalf("Unexpected call to FileSystemMock.Stat. %v", name)
	return
}

// StatAfterCounter returns a count of finished FileSystemMock.Stat invocations
func (mmStat *FileSystemMock) StatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStat.afterStatCounter)
}

// StatBeforeCounter returns a count of FileSystemMock.Stat invocations
func (mmStat *FileSystemMock) StatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStat.beforeStatCounter)
}

// Calls returns a list of arguments used in each call to FileSystemMock.Stat.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmStat *mFileSystemMockStat) Calls() []*FileSystemMockStatParams {
	mmStat.mutex.RLock()

	argCopy := make([]*FileSystemMockStatParams, len(mmStat.callArgs))
	copy(argCopy, mmStat.callArgs)

	mmStat.mutex.RUnlock()

	return argCopy
}

// MinimockStatDone returns true if the count of the Stat invocations corresponds
// the number of defined expectations
func (m *FileSystemMock) MinimockStatDone() bool {
	for _, e := range m.StatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStatCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStat != nil && mm_atomic.LoadUint64(&m.afterStatCounter) < 1 {
		return false
	}
	return true
}

// MinimockStatInspect logs each unmet expectation
func (m *FileSystemMock) MinimockStatInspect() {
	for _, e := range m.StatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FileSystemMock.Stat with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStatCounter) < 1 {
		if m.StatMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FileSystemMock.Stat")
		} else {
			m.t.Errorf("Expected call to FileSystemMock.Stat with params: %#v", *m.StatMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStat != nil && mm_atomic.LoadUint64(&m.afterStatCounter) < 1 {
		m.t.Error("Expected call to FileSystemMock.Stat")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *FileSystemMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockChmodInspect()

		m.MinimockChownInspect()

		m.MinimockChtimesInspect()

		m.MinimockCreateInspect()

		m.MinimockMkdirInspect()

		m.MinimockMkdirAllInspect()

		m.MinimockNameInspect()

		m.MinimockOpenInspect()

		m.MinimockOpenFileInspect()

		m.MinimockRemoveInspect()

		m.MinimockRemoveAllInspect()

		m.MinimockRenameInspect()

		m.MinimockStatInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *FileSystemMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *FileSystemMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockChmodDone() &&
		m.MinimockChownDone() &&
		m.MinimockChtimesDone() &&
		m.MinimockCreateDone() &&
		m.MinimockMkdirDone() &&
		m.MinimockMkdirAllDone() &&
		m.MinimockNameDone() &&
		m.MinimockOpenDone() &&
		m.MinimockOpenFileDone() &&
		m.MinimockRemoveDone() &&
		m.MinimockRemoveAllDone() &&
		m.MinimockRenameDone() &&
		m.MinimockStatDone()
}
