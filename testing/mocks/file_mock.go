package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/go-git/go-billy/v5.File -o ./testing/mocks/file_mock.go -n FileMock

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// FileMock implements billy.File
type FileMock struct {
	t minimock.Tester

	funcClose          func() (err error)
	inspectFuncClose   func()
	afterCloseCounter  uint64
	beforeCloseCounter uint64
	CloseMock          mFileMockClose

	funcLock          func() (err error)
	inspectFuncLock   func()
	afterLockCounter  uint64
	beforeLockCounter uint64
	LockMock          mFileMockLock

	funcName          func() (s1 string)
	inspectFuncName   func()
	afterNameCounter  uint64
	beforeNameCounter uint64
	NameMock          mFileMockName

	funcRead          func(p []byte) (n int, err error)
	inspectFuncRead   func(p []byte)
	afterReadCounter  uint64
	beforeReadCounter uint64
	ReadMock          mFileMockRead

	funcReadAt          func(p []byte, off int64) (n int, err error)
	inspectFuncReadAt   func(p []byte, off int64)
	afterReadAtCounter  uint64
	beforeReadAtCounter uint64
	ReadAtMock          mFileMockReadAt

	funcSeek          func(offset int64, whence int) (i1 int64, err error)
	inspectFuncSeek   func(offset int64, whence int)
	afterSeekCounter  uint64
	beforeSeekCounter uint64
	SeekMock          mFileMockSeek

	funcTruncate          func(size int64) (err error)
	inspectFuncTruncate   func(size int64)
	afterTruncateCounter  uint64
	beforeTruncateCounter uint64
	TruncateMock          mFileMockTruncate

	funcUnlock          func() (err error)
	inspectFuncUnlock   func()
	afterUnlockCounter  uint64
	beforeUnlockCounter uint64
	UnlockMock          mFileMockUnlock

	funcWrite          func(p []byte) (n int, err error)
	inspectFuncWrite   func(p []byte)
	afterWriteCounter  uint64
	beforeWriteCounter uint64
	WriteMock          mFileMockWrite
}

// NewFileMock returns a mock for billy.File
func NewFileMock(t minimock.Tester) *FileMock {
	m := &FileMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CloseMock = mFileMockClose{mock: m}

	m.LockMock = mFileMockLock{mock: m}

	m.NameMock = mFileMockName{mock: m}

	m.ReadMock = mFileMockRead{mock: m}
	m.ReadMock.callArgs = []*FileMockReadParams{}

	m.ReadAtMock = mFileMockReadAt{mock: m}
	m.ReadAtMock.callArgs = []*FileMockReadAtParams{}

	m.SeekMock = mFileMockSeek{mock: m}
	m.SeekMock.callArgs = []*FileMockSeekParams{}

	m.TruncateMock = mFileMockTruncate{mock: m}
	m.TruncateMock.callArgs = []*FileMockTruncateParams{}

	m.UnlockMock = mFileMockUnlock{mock: m}

	m.WriteMock = mFileMockWrite{mock: m}
	m.WriteMock.callArgs = []*FileMockWriteParams{}

	return m
}

type mFileMockClose struct {
	mock               *FileMock
	defaultExpectation *FileMockCloseExpectation
	expectations       []*FileMockCloseExpectation
}

// FileMockCloseExpectation specifies expectation struct of the File.Close
type FileMockCloseExpectation struct {
	mock *FileMock

	results *FileMockCloseResults
	Counter uint64
}

// FileMockCloseResults contains results of the File.Close
type FileMockCloseResults struct {
	err error
}

// Expect sets up expected params for File.Close
func (mmClose *mFileMockClose) Expect() *mFileMockClose {
	if mmClose.mock.funcClose != nil {
		mmClose.mock.t.Fatalf("FileMock.Close mock is already set by Set")
	}

	if mmClose.defaultExpectation == nil {
		mmClose.defaultExpectation = &FileMockCloseExpectation{}
	}

	return mmClose
}

// Inspect accepts an inspector function that has same arguments as the File.Close
func (mmClose *mFileMockClose) Inspect(f func()) *mFileMockClose {
	if mmClose.mock.inspectFuncClose != nil {
		mmClose.mock.t.Fatalf("Inspect function is already set for FileMock.Close")
	}

	mmClose.mock.inspectFuncClose = f

	return mmClose
}

// Return sets up results that will be returned by File.Close
func (mmClose *mFileMockClose) Return(err error) *FileMock {
	if mmClose.mock.funcClose != nil {
		mmClose.mock.t.Fatalf("FileMock.Close mock is already set by Set")
	}

	if mmClose.defaultExpectation == nil {
		mmClose.defaultExpectation = &FileMockCloseExpectation{mock: mmClose.mock}
	}
	mmClose.defaultExpectation.results = &FileMockCloseResults{err}
	return mmClose.mock
}

// Set uses given function f to mock the File.Close method
func (mmClose *mFileMockClose) Set(f func() (err error)) *FileMock {
	if mmClose.defaultExpectation != nil {
		mmClose.mock.t.Fatalf("Default expectation is already set for the File.Close method")
	}

	if len(mmClose.expectations) > 0 {
		mmClose.mock.t.Fatalf("Some expectations are already set for the File.Close method")
	}

	mmClose.mock.funcClose = f
	return mmClose.mock
}

// Close implements billy.File
func (mmClose *FileMock) Close() (err error) {
	mm_atomic.AddUint64(&mmClose.beforeCloseCounter, 1)
	defer mm_atomic.AddUint64(&mmClose.afterCloseCounter, 1)

	if mmClose.inspectFuncClose != nil {
		mmClose.inspectFuncClose()
	}

	if mmClose.CloseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmClose.CloseMock.defaultExpectation.Counter, 1)

		mm_results := mmClose.CloseMock.defaultExpectation.results
		if mm_results == nil {
			mmClose.t.Fatal("No results are set for the FileMock.Close")
		}
		return (*mm_results).err
	}
	if mmClose.funcClose != nil {
		return mmClose.funcClose()
	}
	mmClose.t.Fatalf("Unexpected call to FileMock.Close.")
	return
}

// CloseAfterCounter returns a count of finished FileMock.Close invocations
func (mmClose *FileMock) CloseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClose.afterCloseCounter)
}

// CloseBeforeCounter returns a count of FileMock.Close invocations
func (mmClose *FileMock) CloseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClose.beforeCloseCounter)
}

// MinimockCloseDone returns true if the count of the Close invocations corresponds
// the number of defined expectations
func (m *FileMock) MinimockCloseDone() bool {
	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CloseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClose != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		return false
	}
	return true
}

// MinimockCloseInspect logs each unmet expectation
func (m *FileMock) MinimockCloseInspect() {
	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to FileMock.Close")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CloseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		m.t.Error("Expected call to FileMock.Close")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClose != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		m.t.Error("Expected call to FileMock.Close")
	}
}

type mFileMockLock struct {
	mock               *FileMock
	defaultExpectation *FileMockLockExpectation
	expectations       []*FileMockLockExpectation
}

// FileMockLockExpectation specifies expectation struct of the File.Lock
type FileMockLockExpectation struct {
	mock *FileMock

	results *FileMockLockResults
	Counter uint64
}

// FileMockLockResults contains results of the File.Lock
type FileMockLockResults struct {
	err error
}

// Expect sets up expected params for File.Lock
func (mmLock *mFileMockLock) Expect() *mFileMockLock {
	if mmLock.mock.funcLock != nil {
		mmLock.mock.t.Fatalf("FileMock.Lock mock is already set by Set")
	}

	if mmLock.defaultExpectation == nil {
		mmLock.defaultExpectation = &FileMockLockExpectation{}
	}

	return mmLock
}

// Inspect accepts an inspector function that has same arguments as the File.Lock
func (mmLock *mFileMockLock) Inspect(f func()) *mFileMockLock {
	if mmLock.mock.inspectFuncLock != nil {
		mmLock.mock.t.Fatalf("Inspect function is already set for FileMock.Lock")
	}

	mmLock.mock.inspectFuncLock = f

	return mmLock
}

// Return sets up results that will be returned by File.Lock
func (mmLock *mFileMockLock) Return(err error) *FileMock {
	if mmLock.mock.funcLock != nil {
		mmLock.mock.t.Fatalf("FileMock.Lock mock is already set by Set")
	}

	if mmLock.defaultExpectation == nil {
		mmLock.defaultExpectation = &FileMockLockExpectation{mock: mmLock.mock}
	}
	mmLock.defaultExpectation.results = &FileMockLockResults{err}
	return mmLock.mock
}

// Set uses given function f to mock the File.Lock method
func (mmLock *mFileMockLock) Set(f func() (err error)) *FileMock {
	if mmLock.defaultExpectation != nil {
		mmLock.mock.t.Fatalf("Default expectation is already set for the File.Lock method")
	}

	if len(mmLock.expectations) > 0 {
		mmLock.mock.t.Fatalf("Some expectations are already set for the File.Lock method")
	}

	mmLock.mock.funcLock = f
	return mmLock.mock
}

// Lock implements billy.File
func (mmLock *FileMock) Lock() (err error) {
	mm_atomic.AddUint64(&mmLock.beforeLockCounter, 1)
	defer mm_atomic.AddUint64(&mmLock.afterLockCounter, 1)

	if mmLock.inspectFuncLock != nil {
		mmLock.inspectFuncLock()
	}

	if mmLock.LockMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLock.LockMock.defaultExpectation.Counter, 1)

		mm_results := mmLock.LockMock.defaultExpectation.results
		if mm_results == nil {
			mmLock.t.Fatal("No results are set for the FileMock.Lock")
		}
		return (*mm_results).err
	}
	if mmLock.funcLock != nil {
		return mmLock.funcLock()
	}
	mmLock.t.Fatalf("Unexpected call to FileMock.Lock.")
	return
}

// LockAfterCounter returns a count of finished FileMock.Lock invocations
func (mmLock *FileMock) LockAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLock.afterLockCounter)
}

// LockBeforeCounter returns a count of FileMock.Lock invocations
func (mmLock *FileMock) LockBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLock.beforeLockCounter)
}

// MinimockLockDone returns true if the count of the Lock invocations corresponds
// the number of defined expectations
func (m *FileMock) MinimockLockDone() bool {
	for _, e := range m.LockMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LockMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLockCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLock != nil && mm_atomic.LoadUint64(&m.afterLockCounter) < 1 {
		return false
	}
	return true
}

// MinimockLockInspect logs each unmet expectation
func (m *FileMock) MinimockLockInspect() {
	for _, e := range m.LockMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to FileMock.Lock")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LockMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLockCounter) < 1 {
		m.t.Error("Expected call to FileMock.Lock")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLock != nil && mm_atomic.LoadUint64(&m.afterLockCounter) < 1 {
		m.t.Error("Expected call to FileMock.Lock")
	}
}

type mFileMockName struct {
	mock               *FileMock
	defaultExpectation *FileMockNameExpectation
	expectations       []*FileMockNameExpectation
}

// FileMockNameExpectation specifies expectation struct of the File.Name
type FileMockNameExpectation struct {
	mock *FileMock

	results *FileMockNameResults
	Counter uint64
}

// FileMockNameResults contains results of the File.Name
type FileMockNameResults struct {
	s1 string
}

// Expect sets up expected params for File.Name
func (mmName *mFileMockName) Expect() *mFileMockName {
	if mmName.mock.funcName != nil {
		mmName.mock.t.Fatalf("FileMock.Name mock is already set by Set")
	}

	if mmName.defaultExpectation == nil {
		mmName.defaultExpectation = &FileMockNameExpectation{}
	}

	return mmName
}

// Inspect accepts an inspector function that has same arguments as the File.Name
func (mmName *mFileMockName) Inspect(f func()) *mFileMockName {
	if mmName.mock.inspectFuncName != nil {
		mmName.mock.t.Fatalf("Inspect function is already set for FileMock.Name")
	}

	mmName.mock.inspectFuncName = f

	return mmName
}

// Return sets up results that will be returned by File.Name
func (mmName *mFileMockName) Return(s1 string) *FileMock {
	if mmName.mock.funcName != nil {
		mmName.mock.t.Fatalf("FileMock.Name mock is already set by Set")
	}

	if mmName.defaultExpectation == nil {
		mmName.defaultExpectation = &FileMockNameExpectation{mock: mmName.mock}
	}
	mmName.defaultExpectation.results = &FileMockNameResults{s1}
	return mmName.mock
}

// Set uses given function f to mock the File.Name method
func (mmName *mFileMockName) Set(f func() (s1 string)) *FileMock {
	if mmName.defaultExpectation != nil {
		mmName.mock.t.Fatalf("Default expectation is already set for the File.Name method")
	}

	if len(mmName.expectations) > 0 {
		mmName.mock.t.Fatalf("Some expectations are already set for the File.Name method")
	}

	mmName.mock.funcName = f
	return mmName.mock
}

// Name implements billy.File
func (mmName *FileMock) Name() (s1 string) {
	mm_atomic.AddUint64(&mmName.beforeNameCounter, 1)
	defer mm_atomic.AddUint64(&mmName.afterNameCounter, 1)

	if mmName.inspectFuncName != nil {
		mmName.inspectFuncName()
	}

	if mmName.NameMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmName.NameMock.defaultExpectation.Counter, 1)

		mm_results := mmName.NameMock.defaultExpectation.results
		if mm_results == nil {
			mmName.t.Fatal("No results are set for the FileMock.Name")
		}
		return (*mm_results).s1
	}
	if mmName.funcName != nil {
		return mmName.funcName()
	}
	mmName.t.Fatalf("Unexpected call to FileMock.Name.")
	return
}

// NameAfterCounter returns a count of finished FileMock.Name invocations
func (mmName *FileMock) NameAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmName.afterNameCounter)
}

// NameBeforeCounter returns a count of FileMock.Name invocations
func (mmName *FileMock) NameBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmName.beforeNameCounter)
}

// MinimockNameDone returns true if the count of the Name invocations corresponds
// the number of defined expectations
func (m *FileMock) MinimockNameDone() bool {
	for _, e := range m.NameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.NameMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterNameCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcName != nil && mm_atomic.LoadUint64(&m.afterNameCounter) < 1 {
		return false
	}
	return true
}

// MinimockNameInspect logs each unmet expectation
func (m *FileMock) MinimockNameInspect() {
	for _, e := range m.NameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to FileMock.Name")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.NameMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterNameCounter) < 1 {
		m.t.Error("Expected call to FileMock.Name")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcName != nil && mm_atomic.LoadUint64(&m.afterNameCounter) < 1 {
		m.t.Error("Expected call to FileMock.Name")
	}
}

type mFileMockRead struct {
	mock               *FileMock
	defaultExpectation *FileMockReadExpectation
	expectations       []*FileMockReadExpectation

	callArgs []*FileMockReadParams
	mutex    sync.RWMutex
}

// FileMockReadExpectation specifies expectation struct of the File.Read
type FileMockReadExpectation struct {
	mock    *FileMock
	params  *FileMockReadParams
	results *FileMockReadResults
	Counter uint64
}

// FileMockReadParams contains parameters of the File.Read
type FileMockReadParams struct {
	p []byte
}

// FileMockReadResults contains results of the File.Read
type FileMockReadResults struct {
	n   int
	err error
}

// Expect sets up expected params for File.Read
func (mmRead *mFileMockRead) Expect(p []byte) *mFileMockRead {
	if mmRead.mock.funcRead != nil {
		mmRead.mock.t.Fatalf("FileMock.Read mock is already set by Set")
	}

	if mmRead.defaultExpectation == nil {
		mmRead.defaultExpectation = &FileMockReadExpectation{}
	}

	mmRead.defaultExpectation.params = &FileMockReadParams{p}
	for _, e := range mmRead.expectations {
		if minimock.Equal(e.params, mmRead.defaultExpectation.params) {
			mmRead.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRead.defaultExpectation.params)
		}
	}

	return mmRead
}

// Inspect accepts an inspector function that has same arguments as the File.Read
func (mmRead *mFileMockRead) Inspect(f func(p []byte)) *mFileMockRead {
	if mmRead.mock.inspectFuncRead != nil {
		mmRead.mock.t.Fatalf("Inspect function is already set for FileMock.Read")
	}

	mmRead.mock.inspectFuncRead = f

	return mmRead
}

// Return sets up results that will be returned by File.Read
func (mmRead *mFileMockRead) Return(n int, err error) *FileMock {
	if mmRead.mock.funcRead != nil {
		mmRead.mock.t.Fatalf("FileMock.Read mock is already set by Set")
	}

	if mmRead.defaultExpectation == nil {
		mmRead.defaultExpectation = &FileMockReadExpectation{mock: mmRead.mock}
	}
	mmRead.defaultExpectation.results = &FileMockReadResults{n, err}
	return mmRead.mock
}

// Set uses given function f to mock the File.Read method
func (mmRead *mFileMockRead) Set(f func(p []byte) (n int, err error)) *FileMock {
	if mmRead.defaultExpectation != nil {
		mmRead.mock.t.Fatalf("Default expectation is already set for the File.Read method")
	}

	if len(mmRead.expectations) > 0 {
		mmRead.mock.t.Fatalf("Some expectations are already set for the File.Read method")
	}

	mmRead.mock.funcRead = f
	return mmRead.mock
}

// When sets expectation for the File.Read which will trigger the result defined by the following
// Then helper
func (mmRead *mFileMockRead) When(p []byte) *FileMockReadExpectation {
	if mmRead.mock.funcRead != nil {
		mmRead.mock.t.Fatalf("FileMock.Read mock is already set by Set")
	}

	expectation := &FileMockReadExpectation{
		mock:   mmRead.mock,
		params: &FileMockReadParams{p},
	}
	mmRead.expectations = append(mmRead.expectations, expectation)
	return expectation
}

// Then sets up File.Read return parameters for the expectation previously defined by the When method
func (e *FileMockReadExpectation) Then(n int, err error) *FileMock {
	e.results = &FileMockReadResults{n, err}
	return e.mock
}

// Read implements billy.File
func (mmRead *FileMock) Read(p []byte) (n int, err error) {
	mm_atomic.AddUint64(&mmRead.beforeReadCounter, 1)
	defer mm_atomic.AddUint64(&mmRead.afterReadCounter, 1)

	if mmRead.inspectFuncRead != nil {
		mmRead.inspectFuncRead(p)
	}

	mm_params := &FileMockReadParams{p}

	// Record call args
	mmRead.ReadMock.mutex.Lock()
	mmRead.ReadMock.callArgs = append(mmRead.ReadMock.callArgs, mm_params)
	mmRead.ReadMock.mutex.Unlock()

	for _, e := range mmRead.ReadMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.n, e.results.err
		}
	}

	if mmRead.ReadMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRead.ReadMock.defaultExpectation.Counter, 1)
		mm_want := mmRead.ReadMock.defaultExpectation.params
		mm_got := FileMockReadParams{p}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRead.t.Errorf("FileMock.Read got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRead.ReadMock.defaultExpectation.results
		if mm_results == nil {
			mmRead.t.Fatal("No results are set for the FileMock.Read")
		}
		return (*mm_results).n, (*mm_results).err
	}
	if mmRead.funcRead != nil {
		return mmRead.funcRead(p)
	}
	mmRead.t.Fatalf("Unexpected call to FileMock.Read. %v", p)
	return
}

// ReadAfterCounter returns a count of finished FileMock.Read invocations
func (mmRead *FileMock) ReadAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRead.afterReadCounter)
}

// ReadBeforeCounter returns a count of FileMock.Read invocations
func (mmRead *FileMock) ReadBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRead.beforeReadCounter)
}

// Calls returns a list of arguments used in each call to FileMock.Read.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRead *mFileMockRead) Calls() []*FileMockReadParams {
	mmRead.mutex.RLock()

	argCopy := make([]*FileMockReadParams, len(mmRead.callArgs))
	copy(argCopy, mmRead.callArgs)

	mmRead.mutex.RUnlock()

	return argCopy
}

// MinimockReadDone returns true if the count of the Read invocations corresponds
// the number of defined expectations
func (m *FileMock) MinimockReadDone() bool {
	for _, e := range m.ReadMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReadMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReadCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRead != nil && mm_atomic.LoadUint64(&m.afterReadCounter) < 1 {
		return false
	}
	return true
}

// MinimockReadInspect logs each unmet expectation
func (m *FileMock) MinimockReadInspect() {
	for _, e := range m.ReadMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FileMock.Read with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReadMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReadCounter) < 1 {
		if m.ReadMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FileMock.Read")
		} else {
			m.t.Errorf("Expected call to FileMock.Read with params: %#v", *m.ReadMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRead != nil && mm_atomic.LoadUint64(&m.afterReadCounter) < 1 {
		m.t.Error("Expected call to FileMock.Read")
	}
}

type mFileMockReadAt struct {
	mock               *FileMock
	defaultExpectation *FileMockReadAtExpectation
	expectations       []*FileMockReadAtExpectation

	callArgs []*FileMockReadAtParams
	mutex    sync.RWMutex
}

// FileMockReadAtExpectation specifies expectation struct of the File.ReadAt
type FileMockReadAtExpectation struct {
	mock    *FileMock
	params  *FileMockReadAtParams
	results *FileMockReadAtResults
	Counter uint64
}

// FileMockReadAtParams contains parameters of the File.ReadAt
type FileMockReadAtParams struct {
	p   []byte
	off int64
}

// FileMockReadAtResults contains results of the File.ReadAt
type FileMockReadAtResults struct {
	n   int
	err error
}

// Expect sets up expected params for File.ReadAt
func (mmReadAt *mFileMockReadAt) Expect(p []byte, off int64) *mFileMockReadAt {
	if mmReadAt.mock.funcReadAt != nil {
		mmReadAt.mock.t.Fatalf("FileMock.ReadAt mock is already set by Set")
	}

	if mmReadAt.defaultExpectation == nil {
		mmReadAt.defaultExpectation = &FileMockReadAtExpectation{}
	}

	mmReadAt.defaultExpectation.params = &FileMockReadAtParams{p, off}
	for _, e := range mmReadAt.expectations {
		if minimock.Equal(e.params, mmReadAt.defaultExpectation.params) {
			mmReadAt.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReadAt.defaultExpectation.params)
		}
	}

	return mmReadAt
}

// Inspect accepts an inspector function that has same arguments as the File.ReadAt
func (mmReadAt *mFileMockReadAt) Inspect(f func(p []byte, off int64)) *mFileMockReadAt {
	if mmReadAt.mock.inspectFuncReadAt != nil {
		mmReadAt.mock.t.Fatalf("Inspect function is already set for FileMock.ReadAt")
	}

	mmReadAt.mock.inspectFuncReadAt = f

	return mmReadAt
}

// Return sets up results that will be returned by File.ReadAt
func (mmReadAt *mFileMockReadAt) Return(n int, err error) *FileMock {
	if mmReadAt.mock.funcReadAt != nil {
		mmReadAt.mock.t.Fatalf("FileMock.ReadAt mock is already set by Set")
	}

	if mmReadAt.defaultExpectation == nil {
		mmReadAt.defaultExpectation = &FileMockReadAtExpectation{mock: mmReadAt.mock}
	}
	mmReadAt.defaultExpectation.results = &FileMockReadAtResults{n, err}
	return mmReadAt.mock
}

// Set uses given function f to mock the File.ReadAt method
func (mmReadAt *mFileMockReadAt) Set(f func(p []byte, off int64) (n int, err error)) *FileMock {
	if mmReadAt.defaultExpectation != nil {
		mmReadAt.mock.t.Fatalf("Default expectation is already set for the File.ReadAt method")
	}

	if len(mmReadAt.expectations) > 0 {
		mmReadAt.mock.t.Fatalf("Some expectations are already set for the File.ReadAt method")
	}

	mmReadAt.mock.funcReadAt = f
	return mmReadAt.mock
}

// When sets expectation for the File.ReadAt which will trigger the result defined by the following
// Then helper
func (mmReadAt *mFileMockReadAt) When(p []byte, off int64) *FileMockReadAtExpectation {
	if mmReadAt.mock.funcReadAt != nil {
		mmReadAt.mock.t.Fatalf("FileMock.ReadAt mock is already set by Set")
	}

	expectation := &FileMockReadAtExpectation{
		mock:   mmReadAt.mock,
		params: &FileMockReadAtParams{p, off},
	}
	mmReadAt.expectations = append(mmReadAt.expectations, expectation)
	return expectation
}

// Then sets up File.ReadAt return parameters for the expectation previously defined by the When method
func (e *FileMockReadAtExpectation) Then(n int, err error) *FileMock {
	e.results = &FileMockReadAtResults{n, err}
	return e.mock
}

// ReadAt implements billy.File
func (mmReadAt *FileMock) ReadAt(p []byte, off int64) (n int, err error) {
	mm_atomic.AddUint64(&mmReadAt.beforeReadAtCounter, 1)
	defer mm_atomic.AddUint64(&mmReadAt.afterReadAtCounter, 1)

	if mmReadAt.inspectFuncReadAt != nil {
		mmReadAt.inspectFuncReadAt(p, off)
	}

	mm_params := &FileMockReadAtParams{p, off}

	// Record call args
	mmReadAt.ReadAtMock.mutex.Lock()
	mmReadAt.ReadAtMock.callArgs = append(mmReadAt.ReadAtMock.callArgs, mm_params)
	mmReadAt.ReadAtMock.mutex.Unlock()

	for _, e := range mmReadAt.ReadAtMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.n, e.results.err
		}
	}

	if mmReadAt.ReadAtMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReadAt.ReadAtMock.defaultExpectation.Counter, 1)
		mm_want := mmReadAt.ReadAtMock.defaultExpectation.params
		mm_got := FileMockReadAtParams{p, off}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReadAt.t.Errorf("FileMock.ReadAt got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReadAt.ReadAtMock.defaultExpectation.results
		if mm_results == nil {
			mmReadAt.t.Fatal("No results are set for the FileMock.ReadAt")
		}
		return (*mm_results).n, (*mm_results).err
	}
	if mmReadAt.funcReadAt != nil {
		return mmReadAt.funcReadAt(p, off)
	}
	mmReadAt.t.Fatalf("Unexpected call to FileMock.ReadAt. %v %v", p, off)
	return
}

// ReadAtAfterCounter returns a count of finished FileMock.ReadAt invocations
func (mmReadAt *FileMock) ReadAtAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReadAt.afterReadAtCounter)
}

// ReadAtBeforeCounter returns a count of FileMock.ReadAt invocations
func (mmReadAt *FileMock) ReadAtBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReadAt.beforeReadAtCounter)
}

// Calls returns a list of arguments used in each call to FileMock.ReadAt.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReadAt *mFileMockReadAt) Calls() []*FileMockReadAtParams {
	mmReadAt.mutex.RLock()

	argCopy := make([]*FileMockReadAtParams, len(mmReadAt.callArgs))
	copy(argCopy, mmReadAt.callArgs)

	mmReadAt.mutex.RUnlock()

	return argCopy
}

// MinimockReadAtDone returns true if the count of the ReadAt invocations corresponds
// the number of defined expectations
func (m *FileMock) MinimockReadAtDone() bool {
	for _, e := range m.ReadAtMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReadAtMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReadAtCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReadAt != nil && mm_atomic.LoadUint64(&m.afterReadAtCounter) < 1 {
		return false
	}
	return true
}

// MinimockReadAtInspect logs each unmet expectation
func (m *FileMock) MinimockReadAtInspect() {
	for _, e := range m.ReadAtMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FileMock.ReadAt with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReadAtMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReadAtCounter) < 1 {
		if m.ReadAtMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FileMock.ReadAt")
		} else {
			m.t.Errorf("Expected call to FileMock.ReadAt with params: %#v", *m.ReadAtMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReadAt != nil && mm_atomic.LoadUint64(&m.afterReadAtCounter) < 1 {
		m.t.Error("Expected call to FileMock.ReadAt")
	}
}

type mFileMockSeek struct {
	mock               *FileMock
	defaultExpectation *FileMockSeekExpectation
	expectations       []*FileMockSeekExpectation

	callArgs []*FileMockSeekParams
	mutex    sync.RWMutex
}

// FileMockSeekExpectation specifies expectation struct of the File.Seek
type FileMockSeekExpectation struct {
	mock    *FileMock
	params  *FileMockSeekParams
	results *FileMockSeekResults
	Counter uint64
}

// FileMockSeekParams contains parameters of the File.Seek
type FileMockSeekParams struct {
	offset int64
	whence int
}

// FileMockSeekResults contains results of the File.Seek
type FileMockSeekResults struct {
	i1  int64
	err error
}

// Expect sets up expected params for File.Seek
func (mmSeek *mFileMockSeek) Expect(offset int64, whence int) *mFileMockSeek {
	if mmSeek.mock.funcSeek != nil {
		mmSeek.mock.t.Fatalf("FileMock.Seek mock is already set by Set")
	}

	if mmSeek.defaultExpectation == nil {
		mmSeek.defaultExpectation = &FileMockSeekExpectation{}
	}

	mmSeek.defaultExpectation.params = &FileMockSeekParams{offset, whence}
	for _, e := range mmSeek.expectations {
		if minimock.Equal(e.params, mmSeek.defaultExpectation.params) {
			mmSeek.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSeek.defaultExpectation.params)
		}
	}

	return mmSeek
}

// Inspect accepts an inspector function that has same arguments as the File.Seek
func (mmSeek *mFileMockSeek) Inspect(f func(offset int64, whence int)) *mFileMockSeek {
	if mmSeek.mock.inspectFuncSeek != nil {
		mmSeek.mock.t.Fatalf("Inspect function is already set for FileMock.Seek")
	}

	mmSeek.mock.inspectFuncSeek = f

	return mmSeek
}

// Return sets up results that will be returned by File.Seek
func (mmSeek *mFileMockSeek) Return(i1 int64, err error) *FileMock {
	if mmSeek.mock.funcSeek != nil {
		mmSeek.mock.t.Fatalf("FileMock.Seek mock is already set by Set")
	}

	if mmSeek.defaultExpectation == nil {
		mmSeek.defaultExpectation = &FileMockSeekExpectation{mock: mmSeek.mock}
	}
	mmSeek.defaultExpectation.results = &FileMockSeekResults{i1, err}
	return mmSeek.mock
}

// Set uses given function f to mock the File.Seek method
func (mmSeek *mFileMockSeek) Set(f func(offset int64, whence int) (i1 int64, err error)) *FileMock {
	if mmSeek.defaultExpectation != nil {
		mmSeek.mock.t.Fatalf("Default expectation is already set for the File.Seek method")
	}

	if len(mmSeek.expectations) > 0 {
		mmSeek.mock.t.Fatalf("Some expectations are already set for the File.Seek method")
	}

	mmSeek.mock.funcSeek = f
	return mmSeek.mock
}

// When sets expectation for the File.Seek which will trigger the result defined by the following
// Then helper
func (mmSeek *mFileMockSeek) When(offset int64, whence int) *FileMockSeekExpectation {
	if mmSeek.mock.funcSeek != nil {
		mmSeek.mock.t.Fatalf("FileMock.Seek mock is already set by Set")
	}

	expectation := &FileMockSeekExpectation{
		mock:   mmSeek.mock,
		params: &FileMockSeekParams{offset, whence},
	}
	mmSeek.expectations = append(mmSeek.expectations, expectation)
	return expectation
}

// Then sets up File.Seek return parameters for the expectation previously defined by the When method
func (e *FileMockSeekExpectation) Then(i1 int64, err error) *FileMock {
	e.results = &FileMockSeekResults{i1, err}
	return e.mock
}

// Seek implements billy.File
func (mmSeek *FileMock) Seek(offset int64, whence int) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmSeek.beforeSeekCounter, 1)
	defer mm_atomic.AddUint64(&mmSeek.afterSeekCounter, 1)

	if mmSeek.inspectFuncSeek != nil {
		mmSeek.inspectFuncSeek(offset, whence)
	}

	mm_params := &FileMockSeekParams{offset, whence}

	// Record call args
	mmSeek.SeekMock.mutex.Lock()
	mmSeek.SeekMock.callArgs = append(mmSeek.SeekMock.callArgs, mm_params)
	mmSeek.SeekMock.mutex.Unlock()

	for _, e := range mmSeek.SeekMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmSeek.SeekMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSeek.SeekMock.defaultExpectation.Counter, 1)
		mm_want := mmSeek.SeekMock.defaultExpectation.params
		mm_got := FileMockSeekParams{offset, whence}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSeek.t.Errorf("FileMock.Seek got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSeek.SeekMock.defaultExpectation.results
		if mm_results == nil {
			mmSeek.t.Fatal("No results are set for the FileMock.Seek")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmSeek.funcSeek != nil {
		return mmSeek.funcSeek(offset, whence)
	}
	mmSeek.t.Fatalf("Unexpected call to FileMock.Seek. %v %v", offset, whence)
	return
}

// SeekAfterCounter returns a count of finished FileMock.Seek invocations
func (mmSeek *FileMock) SeekAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSeek.afterSeekCounter)
}

// SeekBeforeCounter returns a count of FileMock.Seek invocations
func (mmSeek *FileMock) SeekBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSeek.beforeSeekCounter)
}

// Calls returns a list of arguments used in each call to FileMock.Seek.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSeek *mFileMockSeek) Calls() []*FileMockSeekParams {
	mmSeek.mutex.RLock()

	argCopy := make([]*FileMockSeekParams, len(mmSeek.callArgs))
	copy(argCopy, mmSeek.callArgs)

	mmSeek.mutex.RUnlock()

	return argCopy
}

// MinimockSeekDone returns true if the count of the Seek invocations corresponds
// the number of defined expectations
func (m *FileMock) MinimockSeekDone() bool {
	for _, e := range m.SeekMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SeekMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSeekCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSeek != nil && mm_atomic.LoadUint64(&m.afterSeekCounter) < 1 {
		return false
	}
	return true
}

// MinimockSeekInspect logs each unmet expectation
func (m *FileMock) MinimockSeekInspect() {
	for _, e := range m.SeekMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FileMock.Seek with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SeekMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSeekCounter) < 1 {
		if m.SeekMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FileMock.Seek")
		} else {
			m.t.Errorf("Expected call to FileMock.Seek with params: %#v", *m.SeekMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSeek != nil && mm_atomic.LoadUint64(&m.afterSeekCounter) < 1 {
		m.t.Error("Expected call to FileMock.Seek")
	}
}

type mFileMockTruncate struct {
	mock               *FileMock
	defaultExpectation *FileMockTruncateExpectation
	expectations       []*FileMockTruncateExpectation

	callArgs []*FileMockTruncateParams
	mutex    sync.RWMutex
}

// FileMockTruncateExpectation specifies expectation struct of the File.Truncate
type FileMockTruncateExpectation struct {
	mock    *FileMock
	params  *FileMockTruncateParams
	results *FileMockTruncateResults
	Counter uint64
}

// FileMockTruncateParams contains parameters of the File.Truncate
type FileMockTruncateParams struct {
	size int64
}

// FileMockTruncateResults contains results of the File.Truncate
type FileMockTruncateResults struct {
	err error
}

// Expect sets up expected params for File.Truncate
func (mmTruncate *mFileMockTruncate) Expect(size int64) *mFileMockTruncate {
	if mmTruncate.mock.funcTruncate != nil {
		mmTruncate.mock.t.Fatalf("FileMock.Truncate mock is already set by Set")
	}

	if mmTruncate.defaultExpectation == nil {
		mmTruncate.defaultExpectation = &FileMockTruncateExpectation{}
	}

	mmTruncate.defaultExpectation.params = &FileMockTruncateParams{size}
	for _, e := range mmTruncate.expectations {
		if minimock.Equal(e.params, mmTruncate.defaultExpectation.params) {
			mmTruncate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmTruncate.defaultExpectation.params)
		}
	}

	return mmTruncate
}

// Inspect accepts an inspector function that has same arguments as the File.Truncate
func (mmTruncate *mFileMockTruncate) Inspect(f func(size int64)) *mFileMockTruncate {
	if mmTruncate.mock.inspectFuncTruncate != nil {
		mmTruncate.mock.t.Fatalf("Inspect function is already set for FileMock.Truncate")
	}

	mmTruncate.mock.inspectFuncTruncate = f

	return mmTruncate
}

// Return sets up results that will be returned by File.Truncate
func (mmTruncate *mFileMockTruncate) Return(err error) *FileMock {
	if mmTruncate.mock.funcTruncate != nil {
		mmTruncate.mock.t.Fatalf("FileMock.Truncate mock is already set by Set")
	}

	if mmTruncate.defaultExpectation == nil {
		mmTruncate.defaultExpectation = &FileMockTruncateExpectation{mock: mmTruncate.mock}
	}
	mmTruncate.defaultExpectation.results = &FileMockTruncateResults{err}
	return mmTruncate.mock
}

// Set uses given function f to mock the File.Truncate method
func (mmTruncate *mFileMockTruncate) Set(f func(size int64) (err error)) *FileMock {
	if mmTruncate.defaultExpectation != nil {
		mmTruncate.mock.t.Fatalf("Default expectation is already set for the File.Truncate method")
	}

	if len(mmTruncate.expectations) > 0 {
		mmTruncate.mock.t.Fatalf("Some expectations are already set for the File.Truncate method")
	}

	mmTruncate.mock.funcTruncate = f
	return mmTruncate.mock
}

// When sets expectation for the File.Truncate which will trigger the result defined by the following
// Then helper
func (mmTruncate *mFileMockTruncate) When(size int64) *FileMockTruncateExpectation {
	if mmTruncate.mock.funcTruncate != nil {
		mmTruncate.mock.t.Fatalf("FileMock.Truncate mock is already set by Set")
	}

	expectation := &FileMockTruncateExpectation{
		mock:   mmTruncate.mock,
		params: &FileMockTruncateParams{size},
	}
	mmTruncate.expectations = append(mmTruncate.expectations, expectation)
	return expectation
}

// Then sets up File.Truncate return parameters for the expectation previously defined by the When method
func (e *FileMockTruncateExpectation) Then(err error) *FileMock {
	e.results = &FileMockTruncateResults{err}
	return e.mock
}

// Truncate implements billy.File
func (mmTruncate *FileMock) Truncate(size int64) (err error) {
	mm_atomic.AddUint64(&mmTruncate.beforeTruncateCounter, 1)
	defer mm_atomic.AddUint64(&mmTruncate.afterTruncateCounter, 1)

	if mmTruncate.inspectFuncTruncate != nil {
		mmTruncate.inspectFuncTruncate(size)
	}

	mm_params := &FileMockTruncateParams{size}

	// Record call args
	mmTruncate.TruncateMock.mutex.Lock()
	mmTruncate.TruncateMock.callArgs = append(mmTruncate.TruncateMock.callArgs, mm_params)
	mmTruncate.TruncateMock.mutex.Unlock()

	for _, e := range mmTruncate.TruncateMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmTruncate.TruncateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTruncate.TruncateMock.defaultExpectation.Counter, 1)
		mm_want := mmTruncate.TruncateMock.defaultExpectation.params
		mm_got := FileMockTruncateParams{size}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmTruncate.t.Errorf("FileMock.Truncate got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmTruncate.TruncateMock.defaultExpectation.results
		if mm_results == nil {
			mmTruncate.t.Fatal("No results are set for the FileMock.Truncate")
		}
		return (*mm_results).err
	}
	if mmTruncate.funcTruncate != nil {
		return mmTruncate.funcTruncate(size)
	}
	mmTruncate.t.Fatalf("Unexpected call to FileMock.Truncate. %v", size)
	return
}

// TruncateAfterCounter returns a count of finished FileMock.Truncate invocations
func (mmTruncate *FileMock) TruncateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTruncate.afterTruncateCounter)
}

// TruncateBeforeCounter returns a count of FileMock.Truncate invocations
func (mmTruncate *FileMock) TruncateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTruncate.beforeTruncateCounter)
}

// Calls returns a list of arguments used in each call to FileMock.Truncate.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmTruncate *mFileMockTruncate) Calls() []*FileMockTruncateParams {
	mmTruncate.mutex.RLock()

	argCopy := make([]*FileMockTruncateParams, len(mmTruncate.callArgs))
	copy(argCopy, mmTruncate.callArgs)

	mmTruncate.mutex.RUnlock()

	return argCopy
}

// MinimockTruncateDone returns true if the count of the Truncate invocations corresponds
// the number of defined expectations
func (m *FileMock) MinimockTruncateDone() bool {
	for _, e := range m.TruncateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TruncateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTruncateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTruncate != nil && mm_atomic.LoadUint64(&m.afterTruncateCounter) < 1 {
		return false
	}
	return true
}

// MinimockTruncateInspect logs each unmet expectation
func (m *FileMock) MinimockTruncateInspect() {
	for _, e := range m.TruncateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FileMock.Truncate with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TruncateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTruncateCounter) < 1 {
		if m.TruncateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FileMock.Truncate")
		} else {
			m.t.Errorf("Expected call to FileMock.Truncate with params: %#v", *m.TruncateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTruncate != nil && mm_atomic.LoadUint64(&m.afterTruncateCounter) < 1 {
		m.t.Error("Expected call to FileMock.Truncate")
	}
}

type mFileMockUnlock struct {
	mock               *FileMock
	defaultExpectation *FileMockUnlockExpectation
	expectations       []*FileMockUnlockExpectation
}

// FileMockUnlockExpectation specifies expectation struct of the File.Unlock
type FileMockUnlockExpectation struct {
	mock *FileMock

	results *FileMockUnlockResults
	Counter uint64
}

// FileMockUnlockResults contains results of the File.Unlock
type FileMockUnlockResults struct {
	err error
}

// Expect sets up expected params for File.Unlock
func (mmUnlock *mFileMockUnlock) Expect() *mFileMockUnlock {
	if mmUnlock.mock.funcUnlock != nil {
		mmUnlock.mock.t.Fatalf("FileMock.Unlock mock is already set by Set")
	}

	if mmUnlock.defaultExpectation == nil {
		mmUnlock.defaultExpectation = &FileMockUnlockExpectation{}
	}

	return mmUnlock
}

// Inspect accepts an inspector function that has same arguments as the File.Unlock
func (mmUnlock *mFileMockUnlock) Inspect(f func()) *mFileMockUnlock {
	if mmUnlock.mock.inspectFuncUnlock != nil {
		mmUnlock.mock.t.Fatalf("Inspect function is already set for FileMock.Unlock")
	}

	mmUnlock.mock.inspectFuncUnlock = f

	return mmUnlock
}

// Return sets up results that will be returned by File.Unlock
func (mmUnlock *mFileMockUnlock) Return(err error) *FileMock {
	if mmUnlock.mock.funcUnlock != nil {
		mmUnlock.mock.t.Fatalf("FileMock.Unlock mock is already set by Set")
	}

	if mmUnlock.defaultExpectation == nil {
		mmUnlock.defaultExpectation = &FileMockUnlockExpectation{mock: mmUnlock.mock}
	}
	mmUnlock.defaultExpectation.results = &FileMockUnlockResults{err}
	return mmUnlock.mock
}

// Set uses given function f to mock the File.Unlock method
func (mmUnlock *mFileMockUnlock) Set(f func() (err error)) *FileMock {
	if mmUnlock.defaultExpectation != nil {
		mmUnlock.mock.t.Fatalf("Default expectation is already set for the File.Unlock method")
	}

	if len(mmUnlock.expectations) > 0 {
		mmUnlock.mock.t.Fatalf("Some expectations are already set for the File.Unlock method")
	}

	mmUnlock.mock.funcUnlock = f
	return mmUnlock.mock
}

// Unlock implements billy.File
func (mmUnlock *FileMock) Unlock() (err error) {
	mm_atomic.AddUint64(&mmUnlock.beforeUnlockCounter, 1)
	defer mm_atomic.AddUint64(&mmUnlock.afterUnlockCounter, 1)

	if mmUnlock.inspectFuncUnlock != nil {
		mmUnlock.inspectFuncUnlock()
	}

	if mmUnlock.UnlockMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUnlock.UnlockMock.defaultExpectation.Counter, 1)

		mm_results := mmUnlock.UnlockMock.defaultExpectation.results
		if mm_results == nil {
			mmUnlock.t.Fatal("No results are set for the FileMock.Unlock")
		}
		return (*mm_results).err
	}
	if mmUnlock.funcUnlock != nil {
		return mmUnlock.funcUnlock()
	}
	mmUnlock.t.Fatalf("Unexpected call to FileMock.Unlock.")
	return
}

// UnlockAfterCounter returns a count of finished FileMock.Unlock invocations
func (mmUnlock *FileMock) UnlockAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUnlock.afterUnlockCounter)
}

// UnlockBeforeCounter returns a count of FileMock.Unlock invocations
func (mmUnlock *FileMock) UnlockBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUnlock.beforeUnlockCounter)
}

// MinimockUnlockDone returns true if the count of the Unlock invocations corresponds
// the number of defined expectations
func (m *FileMock) MinimockUnlockDone() bool {
	for _, e := range m.UnlockMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UnlockMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUnlockCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUnlock != nil && mm_atomic.LoadUint64(&m.afterUnlockCounter) < 1 {
		return false
	}
	return true
}

// MinimockUnlockInspect logs each unmet expectation
func (m *FileMock) MinimockUnlockInspect() {
	for _, e := range m.UnlockMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to FileMock.Unlock")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UnlockMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUnlockCounter) < 1 {
		m.t.Error("Expected call to FileMock.Unlock")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUnlock != nil && mm_atomic.LoadUint64(&m.afterUnlockCounter) < 1 {
		m.t.Error("Expected call to FileMock.Unlock")
	}
}

type mFileMockWrite struct {
	mock               *FileMock
	defaultExpectation *FileMockWriteExpectation
	expectations       []*FileMockWriteExpectation

	callArgs []*FileMockWriteParams
	mutex    sync.RWMutex
}

// FileMockWriteExpectation specifies expectation struct of the File.Write
type FileMockWriteExpectation struct {
	mock    *FileMock
	params  *FileMockWriteParams
	results *FileMockWriteResults
	Counter uint64
}

// FileMockWriteParams contains parameters of the File.Write
type FileMockWriteParams struct {
	p []byte
}

// FileMockWriteResults contains results of the File.Write
type FileMockWriteResults struct {
	n   int
	err error
}

// Expect sets up expected params for File.Write
func (mmWrite *mFileMockWrite) Expect(p []byte) *mFileMockWrite {
	if mmWrite.mock.funcWrite != nil {
		mmWrite.mock.t.Fatalf("FileMock.Write mock is already set by Set")
	}

	if mmWrite.defaultExpectation == nil {
		mmWrite.defaultExpectation = &FileMockWriteExpectation{}
	}

	mmWrite.defaultExpectation.params = &FileMockWriteParams{p}
	for _, e := range mmWrite.expectations {
		if minimock.Equal(e.params, mmWrite.defaultExpectation.params) {
			mmWrite.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWrite.defaultExpectation.params)
		}
	}

	return mmWrite
}

// Inspect accepts an inspector function that has same arguments as the File.Write
func (mmWrite *mFileMockWrite) Inspect(f func(p []byte)) *mFileMockWrite {
	if mmWrite.mock.inspectFuncWrite != nil {
		mmWrite.mock.t.Fatalf("Inspect function is already set for FileMock.Write")
	}

	mmWrite.mock.inspectFuncWrite = f

	return mmWrite
}

// Return sets up results that will be returned by File.Write
func (mmWrite *mFileMockWrite) Return(n int, err error) *FileMock {
	if mmWrite.mock.funcWrite != nil {
		mmWrite.mock.t.Fatalf("FileMock.Write mock is already set by Set")
	}

	if mmWrite.defaultExpectation == nil {
		mmWrite.defaultExpectation = &FileMockWriteExpectation{mock: mmWrite.mock}
	}
	mmWrite.defaultExpectation.results = &FileMockWriteResults{n, err}
	return mmWrite.mock
}

// Set uses given function f to mock the File.Write method
func (mmWrite *mFileMockWrite) Set(f func(p []byte) (n int, err error)) *FileMock {
	if mmWrite.defaultExpectation != nil {
		mmWrite.mock.t.Fatalf("Default expectation is already set for the File.Write method")
	}

	if len(mmWrite.expectations) > 0 {
		mmWrite.mock.t.Fatalf("Some expectations are already set for the File.Write method")
	}

	mmWrite.mock.funcWrite = f
	return mmWrite.mock
}

// When sets expectation for the File.Write which will trigger the result defined by the following
// Then helper
func (mmWrite *mFileMockWrite) When(p []byte) *FileMockWriteExpectation {
	if mmWrite.mock.funcWrite != nil {
		mmWrite.mock.t.Fatalf("FileMock.Write mock is already set by Set")
	}

	expectation := &FileMockWriteExpectation{
		mock:   mmWrite.mock,
		params: &FileMockWriteParams{p},
	}
	mmWrite.expectations = append(mmWrite.expectations, expectation)
	return expectation
}

// Then sets up File.Write return parameters for the expectation previously defined by the When method
func (e *FileMockWriteExpectation) Then(n int, err error) *FileMock {
	e.results = &FileMockWriteResults{n, err}
	return e.mock
}

// Write implements billy.File
func (mmWrite *FileMock) Write(p []byte) (n int, err error) {
	mm_atomic.AddUint64(&mmWrite.beforeWriteCounter, 1)
	defer mm_atomic.AddUint64(&mmWrite.afterWriteCounter, 1)

	if mmWrite.inspectFuncWrite != nil {
		mmWrite.inspectFuncWrite(p)
	}

	mm_params := &FileMockWriteParams{p}

	// Record call args
	mmWrite.WriteMock.mutex.Lock()
	mmWrite.WriteMock.callArgs = append(mmWrite.WriteMock.callArgs, mm_params)
	mmWrite.WriteMock.mutex.Unlock()

	for _, e := range mmWrite.WriteMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.n, e.results.err
		}
	}

	if mmWrite.WriteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWrite.WriteMock.defaultExpectation.Counter, 1)
		mm_want := mmWrite.WriteMock.defaultExpectation.params
		mm_got := FileMockWriteParams{p}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWrite.t.Errorf("FileMock.Write got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmWrite.WriteMock.defaultExpectation.results
		if mm_results == nil {
			mmWrite.t.Fatal("No results are set for the FileMock.Write")
		}
		return (*mm_results).n, (*mm_results).err
	}
	if mmWrite.funcWrite != nil {
		return mmWrite.funcWrite(p)
	}
	mmWrite.t.Fatalf("Unexpected call to FileMock.Write. %v", p)
	return
}

// WriteAfterCounter returns a count of finished FileMock.Write invocations
func (mmWrite *FileMock) WriteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWrite.afterWriteCounter)
}

// WriteBeforeCounter returns a count of FileMock.Write invocations
func (mmWrite *FileMock) WriteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWrite.beforeWriteCounter)
}

// Calls returns a list of arguments used in each call to FileMock.Write.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWrite *mFileMockWrite) Calls() []*FileMockWriteParams {
	mmWrite.mutex.RLock()

	argCopy := make([]*FileMockWriteParams, len(mmWrite.callArgs))
	copy(argCopy, mmWrite.callArgs)

	mmWrite.mutex.RUnlock()

	return argCopy
}

// MinimockWriteDone returns true if the count of the Write invocations corresponds
// the number of defined expectations
func (m *FileMock) MinimockWriteDone() bool {
	for _, e := range m.WriteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WriteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWriteCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWrite != nil && mm_atomic.LoadUint64(&m.afterWriteCounter) < 1 {
		return false
	}
	return true
}

// MinimockWriteInspect logs each unmet expectation
func (m *FileMock) MinimockWriteInspect() {
	for _, e := range m.WriteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FileMock.Write with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WriteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWriteCounter) < 1 {
		if m.WriteMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FileMock.Write")
		} else {
			m.t.Errorf("Expected call to FileMock.Write with params: %#v", *m.WriteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWrite != nil && mm_atomic.LoadUint64(&m.afterWriteCounter) < 1 {
		m.t.Error("Expected call to FileMock.Write")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *FileMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCloseInspect()

		m.MinimockLockInspect()

		m.MinimockNameInspect()

		m.MinimockReadInspect()

		m.MinimockReadAtInspect()

		m.MinimockSeekInspect()

		m.MinimockTruncateInspect()

		m.MinimockUnlockInspect()

		m.MinimockWriteInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *FileMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *FileMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCloseDone() &&
		m.MinimockLockDone() &&
		m.MinimockNameDone() &&
		m.MinimockReadDone() &&
		m.MinimockReadAtDone() &&
		m.MinimockSeekDone() &&
		m.MinimockTruncateDone() &&
		m.MinimockUnlockDone() &&
		m.MinimockWriteDone()
}
