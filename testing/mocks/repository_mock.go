package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i fisherman/internal.Repository -o ./testing/mocks/repository_mock.go

import (
	"fisherman/pkg/vcs"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// RepositoryMock implements internal.Repository
type RepositoryMock struct {
	t minimock.Tester

	funcAddGlob          func(glob string) (err error)
	inspectFuncAddGlob   func(glob string)
	afterAddGlobCounter  uint64
	beforeAddGlobCounter uint64
	AddGlobMock          mRepositoryMockAddGlob

	funcGetCurrentBranch          func() (s1 string, err error)
	inspectFuncGetCurrentBranch   func()
	afterGetCurrentBranchCounter  uint64
	beforeGetCurrentBranchCounter uint64
	GetCurrentBranchMock          mRepositoryMockGetCurrentBranch

	funcGetFilesInIndex          func() (sa1 []string, err error)
	inspectFuncGetFilesInIndex   func()
	afterGetFilesInIndexCounter  uint64
	beforeGetFilesInIndexCounter uint64
	GetFilesInIndexMock          mRepositoryMockGetFilesInIndex

	funcGetIndexChanges          func() (m1 map[string]vcs.Changes, err error)
	inspectFuncGetIndexChanges   func()
	afterGetIndexChangesCounter  uint64
	beforeGetIndexChangesCounter uint64
	GetIndexChangesMock          mRepositoryMockGetIndexChanges

	funcGetLastTag          func() (s1 string, err error)
	inspectFuncGetLastTag   func()
	afterGetLastTagCounter  uint64
	beforeGetLastTagCounter uint64
	GetLastTagMock          mRepositoryMockGetLastTag

	funcGetUser          func() (u1 vcs.User, err error)
	inspectFuncGetUser   func()
	afterGetUserCounter  uint64
	beforeGetUserCounter uint64
	GetUserMock          mRepositoryMockGetUser

	funcRemoveGlob          func(glob string) (err error)
	inspectFuncRemoveGlob   func(glob string)
	afterRemoveGlobCounter  uint64
	beforeRemoveGlobCounter uint64
	RemoveGlobMock          mRepositoryMockRemoveGlob
}

// NewRepositoryMock returns a mock for internal.Repository
func NewRepositoryMock(t minimock.Tester) *RepositoryMock {
	m := &RepositoryMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddGlobMock = mRepositoryMockAddGlob{mock: m}
	m.AddGlobMock.callArgs = []*RepositoryMockAddGlobParams{}

	m.GetCurrentBranchMock = mRepositoryMockGetCurrentBranch{mock: m}

	m.GetFilesInIndexMock = mRepositoryMockGetFilesInIndex{mock: m}

	m.GetIndexChangesMock = mRepositoryMockGetIndexChanges{mock: m}

	m.GetLastTagMock = mRepositoryMockGetLastTag{mock: m}

	m.GetUserMock = mRepositoryMockGetUser{mock: m}

	m.RemoveGlobMock = mRepositoryMockRemoveGlob{mock: m}
	m.RemoveGlobMock.callArgs = []*RepositoryMockRemoveGlobParams{}

	return m
}

type mRepositoryMockAddGlob struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockAddGlobExpectation
	expectations       []*RepositoryMockAddGlobExpectation

	callArgs []*RepositoryMockAddGlobParams
	mutex    sync.RWMutex
}

// RepositoryMockAddGlobExpectation specifies expectation struct of the Repository.AddGlob
type RepositoryMockAddGlobExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockAddGlobParams
	results *RepositoryMockAddGlobResults
	Counter uint64
}

// RepositoryMockAddGlobParams contains parameters of the Repository.AddGlob
type RepositoryMockAddGlobParams struct {
	glob string
}

// RepositoryMockAddGlobResults contains results of the Repository.AddGlob
type RepositoryMockAddGlobResults struct {
	err error
}

// Expect sets up expected params for Repository.AddGlob
func (mmAddGlob *mRepositoryMockAddGlob) Expect(glob string) *mRepositoryMockAddGlob {
	if mmAddGlob.mock.funcAddGlob != nil {
		mmAddGlob.mock.t.Fatalf("RepositoryMock.AddGlob mock is already set by Set")
	}

	if mmAddGlob.defaultExpectation == nil {
		mmAddGlob.defaultExpectation = &RepositoryMockAddGlobExpectation{}
	}

	mmAddGlob.defaultExpectation.params = &RepositoryMockAddGlobParams{glob}
	for _, e := range mmAddGlob.expectations {
		if minimock.Equal(e.params, mmAddGlob.defaultExpectation.params) {
			mmAddGlob.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddGlob.defaultExpectation.params)
		}
	}

	return mmAddGlob
}

// Inspect accepts an inspector function that has same arguments as the Repository.AddGlob
func (mmAddGlob *mRepositoryMockAddGlob) Inspect(f func(glob string)) *mRepositoryMockAddGlob {
	if mmAddGlob.mock.inspectFuncAddGlob != nil {
		mmAddGlob.mock.t.Fatalf("Inspect function is already set for RepositoryMock.AddGlob")
	}

	mmAddGlob.mock.inspectFuncAddGlob = f

	return mmAddGlob
}

// Return sets up results that will be returned by Repository.AddGlob
func (mmAddGlob *mRepositoryMockAddGlob) Return(err error) *RepositoryMock {
	if mmAddGlob.mock.funcAddGlob != nil {
		mmAddGlob.mock.t.Fatalf("RepositoryMock.AddGlob mock is already set by Set")
	}

	if mmAddGlob.defaultExpectation == nil {
		mmAddGlob.defaultExpectation = &RepositoryMockAddGlobExpectation{mock: mmAddGlob.mock}
	}
	mmAddGlob.defaultExpectation.results = &RepositoryMockAddGlobResults{err}
	return mmAddGlob.mock
}

//Set uses given function f to mock the Repository.AddGlob method
func (mmAddGlob *mRepositoryMockAddGlob) Set(f func(glob string) (err error)) *RepositoryMock {
	if mmAddGlob.defaultExpectation != nil {
		mmAddGlob.mock.t.Fatalf("Default expectation is already set for the Repository.AddGlob method")
	}

	if len(mmAddGlob.expectations) > 0 {
		mmAddGlob.mock.t.Fatalf("Some expectations are already set for the Repository.AddGlob method")
	}

	mmAddGlob.mock.funcAddGlob = f
	return mmAddGlob.mock
}

// When sets expectation for the Repository.AddGlob which will trigger the result defined by the following
// Then helper
func (mmAddGlob *mRepositoryMockAddGlob) When(glob string) *RepositoryMockAddGlobExpectation {
	if mmAddGlob.mock.funcAddGlob != nil {
		mmAddGlob.mock.t.Fatalf("RepositoryMock.AddGlob mock is already set by Set")
	}

	expectation := &RepositoryMockAddGlobExpectation{
		mock:   mmAddGlob.mock,
		params: &RepositoryMockAddGlobParams{glob},
	}
	mmAddGlob.expectations = append(mmAddGlob.expectations, expectation)
	return expectation
}

// Then sets up Repository.AddGlob return parameters for the expectation previously defined by the When method
func (e *RepositoryMockAddGlobExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockAddGlobResults{err}
	return e.mock
}

// AddGlob implements internal.Repository
func (mmAddGlob *RepositoryMock) AddGlob(glob string) (err error) {
	mm_atomic.AddUint64(&mmAddGlob.beforeAddGlobCounter, 1)
	defer mm_atomic.AddUint64(&mmAddGlob.afterAddGlobCounter, 1)

	if mmAddGlob.inspectFuncAddGlob != nil {
		mmAddGlob.inspectFuncAddGlob(glob)
	}

	mm_params := &RepositoryMockAddGlobParams{glob}

	// Record call args
	mmAddGlob.AddGlobMock.mutex.Lock()
	mmAddGlob.AddGlobMock.callArgs = append(mmAddGlob.AddGlobMock.callArgs, mm_params)
	mmAddGlob.AddGlobMock.mutex.Unlock()

	for _, e := range mmAddGlob.AddGlobMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddGlob.AddGlobMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddGlob.AddGlobMock.defaultExpectation.Counter, 1)
		mm_want := mmAddGlob.AddGlobMock.defaultExpectation.params
		mm_got := RepositoryMockAddGlobParams{glob}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddGlob.t.Errorf("RepositoryMock.AddGlob got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddGlob.AddGlobMock.defaultExpectation.results
		if mm_results == nil {
			mmAddGlob.t.Fatal("No results are set for the RepositoryMock.AddGlob")
		}
		return (*mm_results).err
	}
	if mmAddGlob.funcAddGlob != nil {
		return mmAddGlob.funcAddGlob(glob)
	}
	mmAddGlob.t.Fatalf("Unexpected call to RepositoryMock.AddGlob. %v", glob)
	return
}

// AddGlobAfterCounter returns a count of finished RepositoryMock.AddGlob invocations
func (mmAddGlob *RepositoryMock) AddGlobAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddGlob.afterAddGlobCounter)
}

// AddGlobBeforeCounter returns a count of RepositoryMock.AddGlob invocations
func (mmAddGlob *RepositoryMock) AddGlobBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddGlob.beforeAddGlobCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.AddGlob.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddGlob *mRepositoryMockAddGlob) Calls() []*RepositoryMockAddGlobParams {
	mmAddGlob.mutex.RLock()

	argCopy := make([]*RepositoryMockAddGlobParams, len(mmAddGlob.callArgs))
	copy(argCopy, mmAddGlob.callArgs)

	mmAddGlob.mutex.RUnlock()

	return argCopy
}

// MinimockAddGlobDone returns true if the count of the AddGlob invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockAddGlobDone() bool {
	for _, e := range m.AddGlobMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddGlobMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddGlobCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddGlob != nil && mm_atomic.LoadUint64(&m.afterAddGlobCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddGlobInspect logs each unmet expectation
func (m *RepositoryMock) MinimockAddGlobInspect() {
	for _, e := range m.AddGlobMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.AddGlob with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddGlobMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddGlobCounter) < 1 {
		if m.AddGlobMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.AddGlob")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.AddGlob with params: %#v", *m.AddGlobMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddGlob != nil && mm_atomic.LoadUint64(&m.afterAddGlobCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.AddGlob")
	}
}

type mRepositoryMockGetCurrentBranch struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetCurrentBranchExpectation
	expectations       []*RepositoryMockGetCurrentBranchExpectation
}

// RepositoryMockGetCurrentBranchExpectation specifies expectation struct of the Repository.GetCurrentBranch
type RepositoryMockGetCurrentBranchExpectation struct {
	mock *RepositoryMock

	results *RepositoryMockGetCurrentBranchResults
	Counter uint64
}

// RepositoryMockGetCurrentBranchResults contains results of the Repository.GetCurrentBranch
type RepositoryMockGetCurrentBranchResults struct {
	s1  string
	err error
}

// Expect sets up expected params for Repository.GetCurrentBranch
func (mmGetCurrentBranch *mRepositoryMockGetCurrentBranch) Expect() *mRepositoryMockGetCurrentBranch {
	if mmGetCurrentBranch.mock.funcGetCurrentBranch != nil {
		mmGetCurrentBranch.mock.t.Fatalf("RepositoryMock.GetCurrentBranch mock is already set by Set")
	}

	if mmGetCurrentBranch.defaultExpectation == nil {
		mmGetCurrentBranch.defaultExpectation = &RepositoryMockGetCurrentBranchExpectation{}
	}

	return mmGetCurrentBranch
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetCurrentBranch
func (mmGetCurrentBranch *mRepositoryMockGetCurrentBranch) Inspect(f func()) *mRepositoryMockGetCurrentBranch {
	if mmGetCurrentBranch.mock.inspectFuncGetCurrentBranch != nil {
		mmGetCurrentBranch.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetCurrentBranch")
	}

	mmGetCurrentBranch.mock.inspectFuncGetCurrentBranch = f

	return mmGetCurrentBranch
}

// Return sets up results that will be returned by Repository.GetCurrentBranch
func (mmGetCurrentBranch *mRepositoryMockGetCurrentBranch) Return(s1 string, err error) *RepositoryMock {
	if mmGetCurrentBranch.mock.funcGetCurrentBranch != nil {
		mmGetCurrentBranch.mock.t.Fatalf("RepositoryMock.GetCurrentBranch mock is already set by Set")
	}

	if mmGetCurrentBranch.defaultExpectation == nil {
		mmGetCurrentBranch.defaultExpectation = &RepositoryMockGetCurrentBranchExpectation{mock: mmGetCurrentBranch.mock}
	}
	mmGetCurrentBranch.defaultExpectation.results = &RepositoryMockGetCurrentBranchResults{s1, err}
	return mmGetCurrentBranch.mock
}

//Set uses given function f to mock the Repository.GetCurrentBranch method
func (mmGetCurrentBranch *mRepositoryMockGetCurrentBranch) Set(f func() (s1 string, err error)) *RepositoryMock {
	if mmGetCurrentBranch.defaultExpectation != nil {
		mmGetCurrentBranch.mock.t.Fatalf("Default expectation is already set for the Repository.GetCurrentBranch method")
	}

	if len(mmGetCurrentBranch.expectations) > 0 {
		mmGetCurrentBranch.mock.t.Fatalf("Some expectations are already set for the Repository.GetCurrentBranch method")
	}

	mmGetCurrentBranch.mock.funcGetCurrentBranch = f
	return mmGetCurrentBranch.mock
}

// GetCurrentBranch implements internal.Repository
func (mmGetCurrentBranch *RepositoryMock) GetCurrentBranch() (s1 string, err error) {
	mm_atomic.AddUint64(&mmGetCurrentBranch.beforeGetCurrentBranchCounter, 1)
	defer mm_atomic.AddUint64(&mmGetCurrentBranch.afterGetCurrentBranchCounter, 1)

	if mmGetCurrentBranch.inspectFuncGetCurrentBranch != nil {
		mmGetCurrentBranch.inspectFuncGetCurrentBranch()
	}

	if mmGetCurrentBranch.GetCurrentBranchMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetCurrentBranch.GetCurrentBranchMock.defaultExpectation.Counter, 1)

		mm_results := mmGetCurrentBranch.GetCurrentBranchMock.defaultExpectation.results
		if mm_results == nil {
			mmGetCurrentBranch.t.Fatal("No results are set for the RepositoryMock.GetCurrentBranch")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmGetCurrentBranch.funcGetCurrentBranch != nil {
		return mmGetCurrentBranch.funcGetCurrentBranch()
	}
	mmGetCurrentBranch.t.Fatalf("Unexpected call to RepositoryMock.GetCurrentBranch.")
	return
}

// GetCurrentBranchAfterCounter returns a count of finished RepositoryMock.GetCurrentBranch invocations
func (mmGetCurrentBranch *RepositoryMock) GetCurrentBranchAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCurrentBranch.afterGetCurrentBranchCounter)
}

// GetCurrentBranchBeforeCounter returns a count of RepositoryMock.GetCurrentBranch invocations
func (mmGetCurrentBranch *RepositoryMock) GetCurrentBranchBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCurrentBranch.beforeGetCurrentBranchCounter)
}

// MinimockGetCurrentBranchDone returns true if the count of the GetCurrentBranch invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetCurrentBranchDone() bool {
	for _, e := range m.GetCurrentBranchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetCurrentBranchMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCurrentBranchCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCurrentBranch != nil && mm_atomic.LoadUint64(&m.afterGetCurrentBranchCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetCurrentBranchInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetCurrentBranchInspect() {
	for _, e := range m.GetCurrentBranchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RepositoryMock.GetCurrentBranch")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetCurrentBranchMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCurrentBranchCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.GetCurrentBranch")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCurrentBranch != nil && mm_atomic.LoadUint64(&m.afterGetCurrentBranchCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.GetCurrentBranch")
	}
}

type mRepositoryMockGetFilesInIndex struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetFilesInIndexExpectation
	expectations       []*RepositoryMockGetFilesInIndexExpectation
}

// RepositoryMockGetFilesInIndexExpectation specifies expectation struct of the Repository.GetFilesInIndex
type RepositoryMockGetFilesInIndexExpectation struct {
	mock *RepositoryMock

	results *RepositoryMockGetFilesInIndexResults
	Counter uint64
}

// RepositoryMockGetFilesInIndexResults contains results of the Repository.GetFilesInIndex
type RepositoryMockGetFilesInIndexResults struct {
	sa1 []string
	err error
}

// Expect sets up expected params for Repository.GetFilesInIndex
func (mmGetFilesInIndex *mRepositoryMockGetFilesInIndex) Expect() *mRepositoryMockGetFilesInIndex {
	if mmGetFilesInIndex.mock.funcGetFilesInIndex != nil {
		mmGetFilesInIndex.mock.t.Fatalf("RepositoryMock.GetFilesInIndex mock is already set by Set")
	}

	if mmGetFilesInIndex.defaultExpectation == nil {
		mmGetFilesInIndex.defaultExpectation = &RepositoryMockGetFilesInIndexExpectation{}
	}

	return mmGetFilesInIndex
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetFilesInIndex
func (mmGetFilesInIndex *mRepositoryMockGetFilesInIndex) Inspect(f func()) *mRepositoryMockGetFilesInIndex {
	if mmGetFilesInIndex.mock.inspectFuncGetFilesInIndex != nil {
		mmGetFilesInIndex.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetFilesInIndex")
	}

	mmGetFilesInIndex.mock.inspectFuncGetFilesInIndex = f

	return mmGetFilesInIndex
}

// Return sets up results that will be returned by Repository.GetFilesInIndex
func (mmGetFilesInIndex *mRepositoryMockGetFilesInIndex) Return(sa1 []string, err error) *RepositoryMock {
	if mmGetFilesInIndex.mock.funcGetFilesInIndex != nil {
		mmGetFilesInIndex.mock.t.Fatalf("RepositoryMock.GetFilesInIndex mock is already set by Set")
	}

	if mmGetFilesInIndex.defaultExpectation == nil {
		mmGetFilesInIndex.defaultExpectation = &RepositoryMockGetFilesInIndexExpectation{mock: mmGetFilesInIndex.mock}
	}
	mmGetFilesInIndex.defaultExpectation.results = &RepositoryMockGetFilesInIndexResults{sa1, err}
	return mmGetFilesInIndex.mock
}

//Set uses given function f to mock the Repository.GetFilesInIndex method
func (mmGetFilesInIndex *mRepositoryMockGetFilesInIndex) Set(f func() (sa1 []string, err error)) *RepositoryMock {
	if mmGetFilesInIndex.defaultExpectation != nil {
		mmGetFilesInIndex.mock.t.Fatalf("Default expectation is already set for the Repository.GetFilesInIndex method")
	}

	if len(mmGetFilesInIndex.expectations) > 0 {
		mmGetFilesInIndex.mock.t.Fatalf("Some expectations are already set for the Repository.GetFilesInIndex method")
	}

	mmGetFilesInIndex.mock.funcGetFilesInIndex = f
	return mmGetFilesInIndex.mock
}

// GetFilesInIndex implements internal.Repository
func (mmGetFilesInIndex *RepositoryMock) GetFilesInIndex() (sa1 []string, err error) {
	mm_atomic.AddUint64(&mmGetFilesInIndex.beforeGetFilesInIndexCounter, 1)
	defer mm_atomic.AddUint64(&mmGetFilesInIndex.afterGetFilesInIndexCounter, 1)

	if mmGetFilesInIndex.inspectFuncGetFilesInIndex != nil {
		mmGetFilesInIndex.inspectFuncGetFilesInIndex()
	}

	if mmGetFilesInIndex.GetFilesInIndexMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetFilesInIndex.GetFilesInIndexMock.defaultExpectation.Counter, 1)

		mm_results := mmGetFilesInIndex.GetFilesInIndexMock.defaultExpectation.results
		if mm_results == nil {
			mmGetFilesInIndex.t.Fatal("No results are set for the RepositoryMock.GetFilesInIndex")
		}
		return (*mm_results).sa1, (*mm_results).err
	}
	if mmGetFilesInIndex.funcGetFilesInIndex != nil {
		return mmGetFilesInIndex.funcGetFilesInIndex()
	}
	mmGetFilesInIndex.t.Fatalf("Unexpected call to RepositoryMock.GetFilesInIndex.")
	return
}

// GetFilesInIndexAfterCounter returns a count of finished RepositoryMock.GetFilesInIndex invocations
func (mmGetFilesInIndex *RepositoryMock) GetFilesInIndexAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFilesInIndex.afterGetFilesInIndexCounter)
}

// GetFilesInIndexBeforeCounter returns a count of RepositoryMock.GetFilesInIndex invocations
func (mmGetFilesInIndex *RepositoryMock) GetFilesInIndexBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFilesInIndex.beforeGetFilesInIndexCounter)
}

// MinimockGetFilesInIndexDone returns true if the count of the GetFilesInIndex invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetFilesInIndexDone() bool {
	for _, e := range m.GetFilesInIndexMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetFilesInIndexMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetFilesInIndexCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetFilesInIndex != nil && mm_atomic.LoadUint64(&m.afterGetFilesInIndexCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetFilesInIndexInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetFilesInIndexInspect() {
	for _, e := range m.GetFilesInIndexMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RepositoryMock.GetFilesInIndex")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetFilesInIndexMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetFilesInIndexCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.GetFilesInIndex")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetFilesInIndex != nil && mm_atomic.LoadUint64(&m.afterGetFilesInIndexCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.GetFilesInIndex")
	}
}

type mRepositoryMockGetIndexChanges struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetIndexChangesExpectation
	expectations       []*RepositoryMockGetIndexChangesExpectation
}

// RepositoryMockGetIndexChangesExpectation specifies expectation struct of the Repository.GetIndexChanges
type RepositoryMockGetIndexChangesExpectation struct {
	mock *RepositoryMock

	results *RepositoryMockGetIndexChangesResults
	Counter uint64
}

// RepositoryMockGetIndexChangesResults contains results of the Repository.GetIndexChanges
type RepositoryMockGetIndexChangesResults struct {
	m1  map[string]vcs.Changes
	err error
}

// Expect sets up expected params for Repository.GetIndexChanges
func (mmGetIndexChanges *mRepositoryMockGetIndexChanges) Expect() *mRepositoryMockGetIndexChanges {
	if mmGetIndexChanges.mock.funcGetIndexChanges != nil {
		mmGetIndexChanges.mock.t.Fatalf("RepositoryMock.GetIndexChanges mock is already set by Set")
	}

	if mmGetIndexChanges.defaultExpectation == nil {
		mmGetIndexChanges.defaultExpectation = &RepositoryMockGetIndexChangesExpectation{}
	}

	return mmGetIndexChanges
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetIndexChanges
func (mmGetIndexChanges *mRepositoryMockGetIndexChanges) Inspect(f func()) *mRepositoryMockGetIndexChanges {
	if mmGetIndexChanges.mock.inspectFuncGetIndexChanges != nil {
		mmGetIndexChanges.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetIndexChanges")
	}

	mmGetIndexChanges.mock.inspectFuncGetIndexChanges = f

	return mmGetIndexChanges
}

// Return sets up results that will be returned by Repository.GetIndexChanges
func (mmGetIndexChanges *mRepositoryMockGetIndexChanges) Return(m1 map[string]vcs.Changes, err error) *RepositoryMock {
	if mmGetIndexChanges.mock.funcGetIndexChanges != nil {
		mmGetIndexChanges.mock.t.Fatalf("RepositoryMock.GetIndexChanges mock is already set by Set")
	}

	if mmGetIndexChanges.defaultExpectation == nil {
		mmGetIndexChanges.defaultExpectation = &RepositoryMockGetIndexChangesExpectation{mock: mmGetIndexChanges.mock}
	}
	mmGetIndexChanges.defaultExpectation.results = &RepositoryMockGetIndexChangesResults{m1, err}
	return mmGetIndexChanges.mock
}

//Set uses given function f to mock the Repository.GetIndexChanges method
func (mmGetIndexChanges *mRepositoryMockGetIndexChanges) Set(f func() (m1 map[string]vcs.Changes, err error)) *RepositoryMock {
	if mmGetIndexChanges.defaultExpectation != nil {
		mmGetIndexChanges.mock.t.Fatalf("Default expectation is already set for the Repository.GetIndexChanges method")
	}

	if len(mmGetIndexChanges.expectations) > 0 {
		mmGetIndexChanges.mock.t.Fatalf("Some expectations are already set for the Repository.GetIndexChanges method")
	}

	mmGetIndexChanges.mock.funcGetIndexChanges = f
	return mmGetIndexChanges.mock
}

// GetIndexChanges implements internal.Repository
func (mmGetIndexChanges *RepositoryMock) GetIndexChanges() (m1 map[string]vcs.Changes, err error) {
	mm_atomic.AddUint64(&mmGetIndexChanges.beforeGetIndexChangesCounter, 1)
	defer mm_atomic.AddUint64(&mmGetIndexChanges.afterGetIndexChangesCounter, 1)

	if mmGetIndexChanges.inspectFuncGetIndexChanges != nil {
		mmGetIndexChanges.inspectFuncGetIndexChanges()
	}

	if mmGetIndexChanges.GetIndexChangesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetIndexChanges.GetIndexChangesMock.defaultExpectation.Counter, 1)

		mm_results := mmGetIndexChanges.GetIndexChangesMock.defaultExpectation.results
		if mm_results == nil {
			mmGetIndexChanges.t.Fatal("No results are set for the RepositoryMock.GetIndexChanges")
		}
		return (*mm_results).m1, (*mm_results).err
	}
	if mmGetIndexChanges.funcGetIndexChanges != nil {
		return mmGetIndexChanges.funcGetIndexChanges()
	}
	mmGetIndexChanges.t.Fatalf("Unexpected call to RepositoryMock.GetIndexChanges.")
	return
}

// GetIndexChangesAfterCounter returns a count of finished RepositoryMock.GetIndexChanges invocations
func (mmGetIndexChanges *RepositoryMock) GetIndexChangesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetIndexChanges.afterGetIndexChangesCounter)
}

// GetIndexChangesBeforeCounter returns a count of RepositoryMock.GetIndexChanges invocations
func (mmGetIndexChanges *RepositoryMock) GetIndexChangesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetIndexChanges.beforeGetIndexChangesCounter)
}

// MinimockGetIndexChangesDone returns true if the count of the GetIndexChanges invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetIndexChangesDone() bool {
	for _, e := range m.GetIndexChangesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetIndexChangesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetIndexChangesCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetIndexChanges != nil && mm_atomic.LoadUint64(&m.afterGetIndexChangesCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetIndexChangesInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetIndexChangesInspect() {
	for _, e := range m.GetIndexChangesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RepositoryMock.GetIndexChanges")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetIndexChangesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetIndexChangesCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.GetIndexChanges")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetIndexChanges != nil && mm_atomic.LoadUint64(&m.afterGetIndexChangesCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.GetIndexChanges")
	}
}

type mRepositoryMockGetLastTag struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetLastTagExpectation
	expectations       []*RepositoryMockGetLastTagExpectation
}

// RepositoryMockGetLastTagExpectation specifies expectation struct of the Repository.GetLastTag
type RepositoryMockGetLastTagExpectation struct {
	mock *RepositoryMock

	results *RepositoryMockGetLastTagResults
	Counter uint64
}

// RepositoryMockGetLastTagResults contains results of the Repository.GetLastTag
type RepositoryMockGetLastTagResults struct {
	s1  string
	err error
}

// Expect sets up expected params for Repository.GetLastTag
func (mmGetLastTag *mRepositoryMockGetLastTag) Expect() *mRepositoryMockGetLastTag {
	if mmGetLastTag.mock.funcGetLastTag != nil {
		mmGetLastTag.mock.t.Fatalf("RepositoryMock.GetLastTag mock is already set by Set")
	}

	if mmGetLastTag.defaultExpectation == nil {
		mmGetLastTag.defaultExpectation = &RepositoryMockGetLastTagExpectation{}
	}

	return mmGetLastTag
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetLastTag
func (mmGetLastTag *mRepositoryMockGetLastTag) Inspect(f func()) *mRepositoryMockGetLastTag {
	if mmGetLastTag.mock.inspectFuncGetLastTag != nil {
		mmGetLastTag.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetLastTag")
	}

	mmGetLastTag.mock.inspectFuncGetLastTag = f

	return mmGetLastTag
}

// Return sets up results that will be returned by Repository.GetLastTag
func (mmGetLastTag *mRepositoryMockGetLastTag) Return(s1 string, err error) *RepositoryMock {
	if mmGetLastTag.mock.funcGetLastTag != nil {
		mmGetLastTag.mock.t.Fatalf("RepositoryMock.GetLastTag mock is already set by Set")
	}

	if mmGetLastTag.defaultExpectation == nil {
		mmGetLastTag.defaultExpectation = &RepositoryMockGetLastTagExpectation{mock: mmGetLastTag.mock}
	}
	mmGetLastTag.defaultExpectation.results = &RepositoryMockGetLastTagResults{s1, err}
	return mmGetLastTag.mock
}

//Set uses given function f to mock the Repository.GetLastTag method
func (mmGetLastTag *mRepositoryMockGetLastTag) Set(f func() (s1 string, err error)) *RepositoryMock {
	if mmGetLastTag.defaultExpectation != nil {
		mmGetLastTag.mock.t.Fatalf("Default expectation is already set for the Repository.GetLastTag method")
	}

	if len(mmGetLastTag.expectations) > 0 {
		mmGetLastTag.mock.t.Fatalf("Some expectations are already set for the Repository.GetLastTag method")
	}

	mmGetLastTag.mock.funcGetLastTag = f
	return mmGetLastTag.mock
}

// GetLastTag implements internal.Repository
func (mmGetLastTag *RepositoryMock) GetLastTag() (s1 string, err error) {
	mm_atomic.AddUint64(&mmGetLastTag.beforeGetLastTagCounter, 1)
	defer mm_atomic.AddUint64(&mmGetLastTag.afterGetLastTagCounter, 1)

	if mmGetLastTag.inspectFuncGetLastTag != nil {
		mmGetLastTag.inspectFuncGetLastTag()
	}

	if mmGetLastTag.GetLastTagMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetLastTag.GetLastTagMock.defaultExpectation.Counter, 1)

		mm_results := mmGetLastTag.GetLastTagMock.defaultExpectation.results
		if mm_results == nil {
			mmGetLastTag.t.Fatal("No results are set for the RepositoryMock.GetLastTag")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmGetLastTag.funcGetLastTag != nil {
		return mmGetLastTag.funcGetLastTag()
	}
	mmGetLastTag.t.Fatalf("Unexpected call to RepositoryMock.GetLastTag.")
	return
}

// GetLastTagAfterCounter returns a count of finished RepositoryMock.GetLastTag invocations
func (mmGetLastTag *RepositoryMock) GetLastTagAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetLastTag.afterGetLastTagCounter)
}

// GetLastTagBeforeCounter returns a count of RepositoryMock.GetLastTag invocations
func (mmGetLastTag *RepositoryMock) GetLastTagBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetLastTag.beforeGetLastTagCounter)
}

// MinimockGetLastTagDone returns true if the count of the GetLastTag invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetLastTagDone() bool {
	for _, e := range m.GetLastTagMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetLastTagMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetLastTagCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetLastTag != nil && mm_atomic.LoadUint64(&m.afterGetLastTagCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetLastTagInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetLastTagInspect() {
	for _, e := range m.GetLastTagMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RepositoryMock.GetLastTag")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetLastTagMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetLastTagCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.GetLastTag")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetLastTag != nil && mm_atomic.LoadUint64(&m.afterGetLastTagCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.GetLastTag")
	}
}

type mRepositoryMockGetUser struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetUserExpectation
	expectations       []*RepositoryMockGetUserExpectation
}

// RepositoryMockGetUserExpectation specifies expectation struct of the Repository.GetUser
type RepositoryMockGetUserExpectation struct {
	mock *RepositoryMock

	results *RepositoryMockGetUserResults
	Counter uint64
}

// RepositoryMockGetUserResults contains results of the Repository.GetUser
type RepositoryMockGetUserResults struct {
	u1  vcs.User
	err error
}

// Expect sets up expected params for Repository.GetUser
func (mmGetUser *mRepositoryMockGetUser) Expect() *mRepositoryMockGetUser {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("RepositoryMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &RepositoryMockGetUserExpectation{}
	}

	return mmGetUser
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetUser
func (mmGetUser *mRepositoryMockGetUser) Inspect(f func()) *mRepositoryMockGetUser {
	if mmGetUser.mock.inspectFuncGetUser != nil {
		mmGetUser.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetUser")
	}

	mmGetUser.mock.inspectFuncGetUser = f

	return mmGetUser
}

// Return sets up results that will be returned by Repository.GetUser
func (mmGetUser *mRepositoryMockGetUser) Return(u1 vcs.User, err error) *RepositoryMock {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("RepositoryMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &RepositoryMockGetUserExpectation{mock: mmGetUser.mock}
	}
	mmGetUser.defaultExpectation.results = &RepositoryMockGetUserResults{u1, err}
	return mmGetUser.mock
}

//Set uses given function f to mock the Repository.GetUser method
func (mmGetUser *mRepositoryMockGetUser) Set(f func() (u1 vcs.User, err error)) *RepositoryMock {
	if mmGetUser.defaultExpectation != nil {
		mmGetUser.mock.t.Fatalf("Default expectation is already set for the Repository.GetUser method")
	}

	if len(mmGetUser.expectations) > 0 {
		mmGetUser.mock.t.Fatalf("Some expectations are already set for the Repository.GetUser method")
	}

	mmGetUser.mock.funcGetUser = f
	return mmGetUser.mock
}

// GetUser implements internal.Repository
func (mmGetUser *RepositoryMock) GetUser() (u1 vcs.User, err error) {
	mm_atomic.AddUint64(&mmGetUser.beforeGetUserCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUser.afterGetUserCounter, 1)

	if mmGetUser.inspectFuncGetUser != nil {
		mmGetUser.inspectFuncGetUser()
	}

	if mmGetUser.GetUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUser.GetUserMock.defaultExpectation.Counter, 1)

		mm_results := mmGetUser.GetUserMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUser.t.Fatal("No results are set for the RepositoryMock.GetUser")
		}
		return (*mm_results).u1, (*mm_results).err
	}
	if mmGetUser.funcGetUser != nil {
		return mmGetUser.funcGetUser()
	}
	mmGetUser.t.Fatalf("Unexpected call to RepositoryMock.GetUser.")
	return
}

// GetUserAfterCounter returns a count of finished RepositoryMock.GetUser invocations
func (mmGetUser *RepositoryMock) GetUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUser.afterGetUserCounter)
}

// GetUserBeforeCounter returns a count of RepositoryMock.GetUser invocations
func (mmGetUser *RepositoryMock) GetUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUser.beforeGetUserCounter)
}

// MinimockGetUserDone returns true if the count of the GetUser invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetUserDone() bool {
	for _, e := range m.GetUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetUserCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUser != nil && mm_atomic.LoadUint64(&m.afterGetUserCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetUserInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetUserInspect() {
	for _, e := range m.GetUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RepositoryMock.GetUser")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetUserCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.GetUser")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUser != nil && mm_atomic.LoadUint64(&m.afterGetUserCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.GetUser")
	}
}

type mRepositoryMockRemoveGlob struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockRemoveGlobExpectation
	expectations       []*RepositoryMockRemoveGlobExpectation

	callArgs []*RepositoryMockRemoveGlobParams
	mutex    sync.RWMutex
}

// RepositoryMockRemoveGlobExpectation specifies expectation struct of the Repository.RemoveGlob
type RepositoryMockRemoveGlobExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockRemoveGlobParams
	results *RepositoryMockRemoveGlobResults
	Counter uint64
}

// RepositoryMockRemoveGlobParams contains parameters of the Repository.RemoveGlob
type RepositoryMockRemoveGlobParams struct {
	glob string
}

// RepositoryMockRemoveGlobResults contains results of the Repository.RemoveGlob
type RepositoryMockRemoveGlobResults struct {
	err error
}

// Expect sets up expected params for Repository.RemoveGlob
func (mmRemoveGlob *mRepositoryMockRemoveGlob) Expect(glob string) *mRepositoryMockRemoveGlob {
	if mmRemoveGlob.mock.funcRemoveGlob != nil {
		mmRemoveGlob.mock.t.Fatalf("RepositoryMock.RemoveGlob mock is already set by Set")
	}

	if mmRemoveGlob.defaultExpectation == nil {
		mmRemoveGlob.defaultExpectation = &RepositoryMockRemoveGlobExpectation{}
	}

	mmRemoveGlob.defaultExpectation.params = &RepositoryMockRemoveGlobParams{glob}
	for _, e := range mmRemoveGlob.expectations {
		if minimock.Equal(e.params, mmRemoveGlob.defaultExpectation.params) {
			mmRemoveGlob.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRemoveGlob.defaultExpectation.params)
		}
	}

	return mmRemoveGlob
}

// Inspect accepts an inspector function that has same arguments as the Repository.RemoveGlob
func (mmRemoveGlob *mRepositoryMockRemoveGlob) Inspect(f func(glob string)) *mRepositoryMockRemoveGlob {
	if mmRemoveGlob.mock.inspectFuncRemoveGlob != nil {
		mmRemoveGlob.mock.t.Fatalf("Inspect function is already set for RepositoryMock.RemoveGlob")
	}

	mmRemoveGlob.mock.inspectFuncRemoveGlob = f

	return mmRemoveGlob
}

// Return sets up results that will be returned by Repository.RemoveGlob
func (mmRemoveGlob *mRepositoryMockRemoveGlob) Return(err error) *RepositoryMock {
	if mmRemoveGlob.mock.funcRemoveGlob != nil {
		mmRemoveGlob.mock.t.Fatalf("RepositoryMock.RemoveGlob mock is already set by Set")
	}

	if mmRemoveGlob.defaultExpectation == nil {
		mmRemoveGlob.defaultExpectation = &RepositoryMockRemoveGlobExpectation{mock: mmRemoveGlob.mock}
	}
	mmRemoveGlob.defaultExpectation.results = &RepositoryMockRemoveGlobResults{err}
	return mmRemoveGlob.mock
}

//Set uses given function f to mock the Repository.RemoveGlob method
func (mmRemoveGlob *mRepositoryMockRemoveGlob) Set(f func(glob string) (err error)) *RepositoryMock {
	if mmRemoveGlob.defaultExpectation != nil {
		mmRemoveGlob.mock.t.Fatalf("Default expectation is already set for the Repository.RemoveGlob method")
	}

	if len(mmRemoveGlob.expectations) > 0 {
		mmRemoveGlob.mock.t.Fatalf("Some expectations are already set for the Repository.RemoveGlob method")
	}

	mmRemoveGlob.mock.funcRemoveGlob = f
	return mmRemoveGlob.mock
}

// When sets expectation for the Repository.RemoveGlob which will trigger the result defined by the following
// Then helper
func (mmRemoveGlob *mRepositoryMockRemoveGlob) When(glob string) *RepositoryMockRemoveGlobExpectation {
	if mmRemoveGlob.mock.funcRemoveGlob != nil {
		mmRemoveGlob.mock.t.Fatalf("RepositoryMock.RemoveGlob mock is already set by Set")
	}

	expectation := &RepositoryMockRemoveGlobExpectation{
		mock:   mmRemoveGlob.mock,
		params: &RepositoryMockRemoveGlobParams{glob},
	}
	mmRemoveGlob.expectations = append(mmRemoveGlob.expectations, expectation)
	return expectation
}

// Then sets up Repository.RemoveGlob return parameters for the expectation previously defined by the When method
func (e *RepositoryMockRemoveGlobExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockRemoveGlobResults{err}
	return e.mock
}

// RemoveGlob implements internal.Repository
func (mmRemoveGlob *RepositoryMock) RemoveGlob(glob string) (err error) {
	mm_atomic.AddUint64(&mmRemoveGlob.beforeRemoveGlobCounter, 1)
	defer mm_atomic.AddUint64(&mmRemoveGlob.afterRemoveGlobCounter, 1)

	if mmRemoveGlob.inspectFuncRemoveGlob != nil {
		mmRemoveGlob.inspectFuncRemoveGlob(glob)
	}

	mm_params := &RepositoryMockRemoveGlobParams{glob}

	// Record call args
	mmRemoveGlob.RemoveGlobMock.mutex.Lock()
	mmRemoveGlob.RemoveGlobMock.callArgs = append(mmRemoveGlob.RemoveGlobMock.callArgs, mm_params)
	mmRemoveGlob.RemoveGlobMock.mutex.Unlock()

	for _, e := range mmRemoveGlob.RemoveGlobMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRemoveGlob.RemoveGlobMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRemoveGlob.RemoveGlobMock.defaultExpectation.Counter, 1)
		mm_want := mmRemoveGlob.RemoveGlobMock.defaultExpectation.params
		mm_got := RepositoryMockRemoveGlobParams{glob}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRemoveGlob.t.Errorf("RepositoryMock.RemoveGlob got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRemoveGlob.RemoveGlobMock.defaultExpectation.results
		if mm_results == nil {
			mmRemoveGlob.t.Fatal("No results are set for the RepositoryMock.RemoveGlob")
		}
		return (*mm_results).err
	}
	if mmRemoveGlob.funcRemoveGlob != nil {
		return mmRemoveGlob.funcRemoveGlob(glob)
	}
	mmRemoveGlob.t.Fatalf("Unexpected call to RepositoryMock.RemoveGlob. %v", glob)
	return
}

// RemoveGlobAfterCounter returns a count of finished RepositoryMock.RemoveGlob invocations
func (mmRemoveGlob *RepositoryMock) RemoveGlobAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveGlob.afterRemoveGlobCounter)
}

// RemoveGlobBeforeCounter returns a count of RepositoryMock.RemoveGlob invocations
func (mmRemoveGlob *RepositoryMock) RemoveGlobBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveGlob.beforeRemoveGlobCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.RemoveGlob.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRemoveGlob *mRepositoryMockRemoveGlob) Calls() []*RepositoryMockRemoveGlobParams {
	mmRemoveGlob.mutex.RLock()

	argCopy := make([]*RepositoryMockRemoveGlobParams, len(mmRemoveGlob.callArgs))
	copy(argCopy, mmRemoveGlob.callArgs)

	mmRemoveGlob.mutex.RUnlock()

	return argCopy
}

// MinimockRemoveGlobDone returns true if the count of the RemoveGlob invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockRemoveGlobDone() bool {
	for _, e := range m.RemoveGlobMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RemoveGlobMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRemoveGlobCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemoveGlob != nil && mm_atomic.LoadUint64(&m.afterRemoveGlobCounter) < 1 {
		return false
	}
	return true
}

// MinimockRemoveGlobInspect logs each unmet expectation
func (m *RepositoryMock) MinimockRemoveGlobInspect() {
	for _, e := range m.RemoveGlobMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.RemoveGlob with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RemoveGlobMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRemoveGlobCounter) < 1 {
		if m.RemoveGlobMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.RemoveGlob")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.RemoveGlob with params: %#v", *m.RemoveGlobMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemoveGlob != nil && mm_atomic.LoadUint64(&m.afterRemoveGlobCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.RemoveGlob")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RepositoryMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAddGlobInspect()

		m.MinimockGetCurrentBranchInspect()

		m.MinimockGetFilesInIndexInspect()

		m.MinimockGetIndexChangesInspect()

		m.MinimockGetLastTagInspect()

		m.MinimockGetUserInspect()

		m.MinimockRemoveGlobInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddGlobDone() &&
		m.MinimockGetCurrentBranchDone() &&
		m.MinimockGetFilesInIndexDone() &&
		m.MinimockGetIndexChangesDone() &&
		m.MinimockGetLastTagDone() &&
		m.MinimockGetUserDone() &&
		m.MinimockRemoveGlobDone()
}
