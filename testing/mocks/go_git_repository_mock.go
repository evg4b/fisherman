package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i fisherman/pkg/vcs.GoGitRepository -o ./testing/mocks/go_git_repository_mock.go -n GoGitRepositoryMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/go-git/go-git/v5"
	"github.com/go-git/go-git/v5/config"
	"github.com/go-git/go-git/v5/plumbing"
	"github.com/go-git/go-git/v5/plumbing/object"
	"github.com/go-git/go-git/v5/plumbing/storer"
	"github.com/gojuno/minimock/v3"
)

// GoGitRepositoryMock implements vcs.GoGitRepository
type GoGitRepositoryMock struct {
	t minimock.Tester

	funcBlobObject          func(h plumbing.Hash) (bp1 *object.Blob, err error)
	inspectFuncBlobObject   func(h plumbing.Hash)
	afterBlobObjectCounter  uint64
	beforeBlobObjectCounter uint64
	BlobObjectMock          mGoGitRepositoryMockBlobObject

	funcBlobObjects          func() (bp1 *object.BlobIter, err error)
	inspectFuncBlobObjects   func()
	afterBlobObjectsCounter  uint64
	beforeBlobObjectsCounter uint64
	BlobObjectsMock          mGoGitRepositoryMockBlobObjects

	funcBranch          func(name string) (bp1 *config.Branch, err error)
	inspectFuncBranch   func(name string)
	afterBranchCounter  uint64
	beforeBranchCounter uint64
	BranchMock          mGoGitRepositoryMockBranch

	funcBranches          func() (r1 storer.ReferenceIter, err error)
	inspectFuncBranches   func()
	afterBranchesCounter  uint64
	beforeBranchesCounter uint64
	BranchesMock          mGoGitRepositoryMockBranches

	funcCommitObject          func(h plumbing.Hash) (cp1 *object.Commit, err error)
	inspectFuncCommitObject   func(h plumbing.Hash)
	afterCommitObjectCounter  uint64
	beforeCommitObjectCounter uint64
	CommitObjectMock          mGoGitRepositoryMockCommitObject

	funcCommitObjects          func() (c1 object.CommitIter, err error)
	inspectFuncCommitObjects   func()
	afterCommitObjectsCounter  uint64
	beforeCommitObjectsCounter uint64
	CommitObjectsMock          mGoGitRepositoryMockCommitObjects

	funcConfig          func() (cp1 *config.Config, err error)
	inspectFuncConfig   func()
	afterConfigCounter  uint64
	beforeConfigCounter uint64
	ConfigMock          mGoGitRepositoryMockConfig

	funcConfigScoped          func(scope config.Scope) (cp1 *config.Config, err error)
	inspectFuncConfigScoped   func(scope config.Scope)
	afterConfigScopedCounter  uint64
	beforeConfigScopedCounter uint64
	ConfigScopedMock          mGoGitRepositoryMockConfigScoped

	funcCreateBranch          func(c *config.Branch) (err error)
	inspectFuncCreateBranch   func(c *config.Branch)
	afterCreateBranchCounter  uint64
	beforeCreateBranchCounter uint64
	CreateBranchMock          mGoGitRepositoryMockCreateBranch

	funcCreateRemote          func(c *config.RemoteConfig) (rp1 *git.Remote, err error)
	inspectFuncCreateRemote   func(c *config.RemoteConfig)
	afterCreateRemoteCounter  uint64
	beforeCreateRemoteCounter uint64
	CreateRemoteMock          mGoGitRepositoryMockCreateRemote

	funcCreateRemoteAnonymous          func(c *config.RemoteConfig) (rp1 *git.Remote, err error)
	inspectFuncCreateRemoteAnonymous   func(c *config.RemoteConfig)
	afterCreateRemoteAnonymousCounter  uint64
	beforeCreateRemoteAnonymousCounter uint64
	CreateRemoteAnonymousMock          mGoGitRepositoryMockCreateRemoteAnonymous

	funcCreateTag          func(name string, hash plumbing.Hash, opts *git.CreateTagOptions) (rp1 *plumbing.Reference, err error)
	inspectFuncCreateTag   func(name string, hash plumbing.Hash, opts *git.CreateTagOptions)
	afterCreateTagCounter  uint64
	beforeCreateTagCounter uint64
	CreateTagMock          mGoGitRepositoryMockCreateTag

	funcDeleteBranch          func(name string) (err error)
	inspectFuncDeleteBranch   func(name string)
	afterDeleteBranchCounter  uint64
	beforeDeleteBranchCounter uint64
	DeleteBranchMock          mGoGitRepositoryMockDeleteBranch

	funcDeleteObject          func(hash plumbing.Hash) (err error)
	inspectFuncDeleteObject   func(hash plumbing.Hash)
	afterDeleteObjectCounter  uint64
	beforeDeleteObjectCounter uint64
	DeleteObjectMock          mGoGitRepositoryMockDeleteObject

	funcDeleteRemote          func(name string) (err error)
	inspectFuncDeleteRemote   func(name string)
	afterDeleteRemoteCounter  uint64
	beforeDeleteRemoteCounter uint64
	DeleteRemoteMock          mGoGitRepositoryMockDeleteRemote

	funcDeleteTag          func(name string) (err error)
	inspectFuncDeleteTag   func(name string)
	afterDeleteTagCounter  uint64
	beforeDeleteTagCounter uint64
	DeleteTagMock          mGoGitRepositoryMockDeleteTag

	funcFetch          func(o *git.FetchOptions) (err error)
	inspectFuncFetch   func(o *git.FetchOptions)
	afterFetchCounter  uint64
	beforeFetchCounter uint64
	FetchMock          mGoGitRepositoryMockFetch

	funcFetchContext          func(ctx context.Context, o *git.FetchOptions) (err error)
	inspectFuncFetchContext   func(ctx context.Context, o *git.FetchOptions)
	afterFetchContextCounter  uint64
	beforeFetchContextCounter uint64
	FetchContextMock          mGoGitRepositoryMockFetchContext

	funcHead          func() (rp1 *plumbing.Reference, err error)
	inspectFuncHead   func()
	afterHeadCounter  uint64
	beforeHeadCounter uint64
	HeadMock          mGoGitRepositoryMockHead

	funcLog          func(o *git.LogOptions) (c1 object.CommitIter, err error)
	inspectFuncLog   func(o *git.LogOptions)
	afterLogCounter  uint64
	beforeLogCounter uint64
	LogMock          mGoGitRepositoryMockLog

	funcNotes          func() (r1 storer.ReferenceIter, err error)
	inspectFuncNotes   func()
	afterNotesCounter  uint64
	beforeNotesCounter uint64
	NotesMock          mGoGitRepositoryMockNotes

	funcObject          func(t plumbing.ObjectType, h plumbing.Hash) (o1 object.Object, err error)
	inspectFuncObject   func(t plumbing.ObjectType, h plumbing.Hash)
	afterObjectCounter  uint64
	beforeObjectCounter uint64
	ObjectMock          mGoGitRepositoryMockObject

	funcObjects          func() (op1 *object.ObjectIter, err error)
	inspectFuncObjects   func()
	afterObjectsCounter  uint64
	beforeObjectsCounter uint64
	ObjectsMock          mGoGitRepositoryMockObjects

	funcPrune          func(opt git.PruneOptions) (err error)
	inspectFuncPrune   func(opt git.PruneOptions)
	afterPruneCounter  uint64
	beforePruneCounter uint64
	PruneMock          mGoGitRepositoryMockPrune

	funcPush          func(o *git.PushOptions) (err error)
	inspectFuncPush   func(o *git.PushOptions)
	afterPushCounter  uint64
	beforePushCounter uint64
	PushMock          mGoGitRepositoryMockPush

	funcPushContext          func(ctx context.Context, o *git.PushOptions) (err error)
	inspectFuncPushContext   func(ctx context.Context, o *git.PushOptions)
	afterPushContextCounter  uint64
	beforePushContextCounter uint64
	PushContextMock          mGoGitRepositoryMockPushContext

	funcReference          func(name plumbing.ReferenceName, resolved bool) (rp1 *plumbing.Reference, err error)
	inspectFuncReference   func(name plumbing.ReferenceName, resolved bool)
	afterReferenceCounter  uint64
	beforeReferenceCounter uint64
	ReferenceMock          mGoGitRepositoryMockReference

	funcReferences          func() (r1 storer.ReferenceIter, err error)
	inspectFuncReferences   func()
	afterReferencesCounter  uint64
	beforeReferencesCounter uint64
	ReferencesMock          mGoGitRepositoryMockReferences

	funcRemote          func(name string) (rp1 *git.Remote, err error)
	inspectFuncRemote   func(name string)
	afterRemoteCounter  uint64
	beforeRemoteCounter uint64
	RemoteMock          mGoGitRepositoryMockRemote

	funcRemotes          func() (rpa1 []*git.Remote, err error)
	inspectFuncRemotes   func()
	afterRemotesCounter  uint64
	beforeRemotesCounter uint64
	RemotesMock          mGoGitRepositoryMockRemotes

	funcRepackObjects          func(cfg *git.RepackConfig) (err error)
	inspectFuncRepackObjects   func(cfg *git.RepackConfig)
	afterRepackObjectsCounter  uint64
	beforeRepackObjectsCounter uint64
	RepackObjectsMock          mGoGitRepositoryMockRepackObjects

	funcResolveRevision          func(rev plumbing.Revision) (hp1 *plumbing.Hash, err error)
	inspectFuncResolveRevision   func(rev plumbing.Revision)
	afterResolveRevisionCounter  uint64
	beforeResolveRevisionCounter uint64
	ResolveRevisionMock          mGoGitRepositoryMockResolveRevision

	funcSetConfig          func(cfg *config.Config) (err error)
	inspectFuncSetConfig   func(cfg *config.Config)
	afterSetConfigCounter  uint64
	beforeSetConfigCounter uint64
	SetConfigMock          mGoGitRepositoryMockSetConfig

	funcTag          func(name string) (rp1 *plumbing.Reference, err error)
	inspectFuncTag   func(name string)
	afterTagCounter  uint64
	beforeTagCounter uint64
	TagMock          mGoGitRepositoryMockTag

	funcTagObject          func(h plumbing.Hash) (tp1 *object.Tag, err error)
	inspectFuncTagObject   func(h plumbing.Hash)
	afterTagObjectCounter  uint64
	beforeTagObjectCounter uint64
	TagObjectMock          mGoGitRepositoryMockTagObject

	funcTagObjects          func() (tp1 *object.TagIter, err error)
	inspectFuncTagObjects   func()
	afterTagObjectsCounter  uint64
	beforeTagObjectsCounter uint64
	TagObjectsMock          mGoGitRepositoryMockTagObjects

	funcTags          func() (r1 storer.ReferenceIter, err error)
	inspectFuncTags   func()
	afterTagsCounter  uint64
	beforeTagsCounter uint64
	TagsMock          mGoGitRepositoryMockTags

	funcTreeObject          func(h plumbing.Hash) (tp1 *object.Tree, err error)
	inspectFuncTreeObject   func(h plumbing.Hash)
	afterTreeObjectCounter  uint64
	beforeTreeObjectCounter uint64
	TreeObjectMock          mGoGitRepositoryMockTreeObject

	funcTreeObjects          func() (tp1 *object.TreeIter, err error)
	inspectFuncTreeObjects   func()
	afterTreeObjectsCounter  uint64
	beforeTreeObjectsCounter uint64
	TreeObjectsMock          mGoGitRepositoryMockTreeObjects

	funcWorktree          func() (wp1 *git.Worktree, err error)
	inspectFuncWorktree   func()
	afterWorktreeCounter  uint64
	beforeWorktreeCounter uint64
	WorktreeMock          mGoGitRepositoryMockWorktree
}

// NewGoGitRepositoryMock returns a mock for vcs.GoGitRepository
func NewGoGitRepositoryMock(t minimock.Tester) *GoGitRepositoryMock {
	m := &GoGitRepositoryMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.BlobObjectMock = mGoGitRepositoryMockBlobObject{mock: m}
	m.BlobObjectMock.callArgs = []*GoGitRepositoryMockBlobObjectParams{}

	m.BlobObjectsMock = mGoGitRepositoryMockBlobObjects{mock: m}

	m.BranchMock = mGoGitRepositoryMockBranch{mock: m}
	m.BranchMock.callArgs = []*GoGitRepositoryMockBranchParams{}

	m.BranchesMock = mGoGitRepositoryMockBranches{mock: m}

	m.CommitObjectMock = mGoGitRepositoryMockCommitObject{mock: m}
	m.CommitObjectMock.callArgs = []*GoGitRepositoryMockCommitObjectParams{}

	m.CommitObjectsMock = mGoGitRepositoryMockCommitObjects{mock: m}

	m.ConfigMock = mGoGitRepositoryMockConfig{mock: m}

	m.ConfigScopedMock = mGoGitRepositoryMockConfigScoped{mock: m}
	m.ConfigScopedMock.callArgs = []*GoGitRepositoryMockConfigScopedParams{}

	m.CreateBranchMock = mGoGitRepositoryMockCreateBranch{mock: m}
	m.CreateBranchMock.callArgs = []*GoGitRepositoryMockCreateBranchParams{}

	m.CreateRemoteMock = mGoGitRepositoryMockCreateRemote{mock: m}
	m.CreateRemoteMock.callArgs = []*GoGitRepositoryMockCreateRemoteParams{}

	m.CreateRemoteAnonymousMock = mGoGitRepositoryMockCreateRemoteAnonymous{mock: m}
	m.CreateRemoteAnonymousMock.callArgs = []*GoGitRepositoryMockCreateRemoteAnonymousParams{}

	m.CreateTagMock = mGoGitRepositoryMockCreateTag{mock: m}
	m.CreateTagMock.callArgs = []*GoGitRepositoryMockCreateTagParams{}

	m.DeleteBranchMock = mGoGitRepositoryMockDeleteBranch{mock: m}
	m.DeleteBranchMock.callArgs = []*GoGitRepositoryMockDeleteBranchParams{}

	m.DeleteObjectMock = mGoGitRepositoryMockDeleteObject{mock: m}
	m.DeleteObjectMock.callArgs = []*GoGitRepositoryMockDeleteObjectParams{}

	m.DeleteRemoteMock = mGoGitRepositoryMockDeleteRemote{mock: m}
	m.DeleteRemoteMock.callArgs = []*GoGitRepositoryMockDeleteRemoteParams{}

	m.DeleteTagMock = mGoGitRepositoryMockDeleteTag{mock: m}
	m.DeleteTagMock.callArgs = []*GoGitRepositoryMockDeleteTagParams{}

	m.FetchMock = mGoGitRepositoryMockFetch{mock: m}
	m.FetchMock.callArgs = []*GoGitRepositoryMockFetchParams{}

	m.FetchContextMock = mGoGitRepositoryMockFetchContext{mock: m}
	m.FetchContextMock.callArgs = []*GoGitRepositoryMockFetchContextParams{}

	m.HeadMock = mGoGitRepositoryMockHead{mock: m}

	m.LogMock = mGoGitRepositoryMockLog{mock: m}
	m.LogMock.callArgs = []*GoGitRepositoryMockLogParams{}

	m.NotesMock = mGoGitRepositoryMockNotes{mock: m}

	m.ObjectMock = mGoGitRepositoryMockObject{mock: m}
	m.ObjectMock.callArgs = []*GoGitRepositoryMockObjectParams{}

	m.ObjectsMock = mGoGitRepositoryMockObjects{mock: m}

	m.PruneMock = mGoGitRepositoryMockPrune{mock: m}
	m.PruneMock.callArgs = []*GoGitRepositoryMockPruneParams{}

	m.PushMock = mGoGitRepositoryMockPush{mock: m}
	m.PushMock.callArgs = []*GoGitRepositoryMockPushParams{}

	m.PushContextMock = mGoGitRepositoryMockPushContext{mock: m}
	m.PushContextMock.callArgs = []*GoGitRepositoryMockPushContextParams{}

	m.ReferenceMock = mGoGitRepositoryMockReference{mock: m}
	m.ReferenceMock.callArgs = []*GoGitRepositoryMockReferenceParams{}

	m.ReferencesMock = mGoGitRepositoryMockReferences{mock: m}

	m.RemoteMock = mGoGitRepositoryMockRemote{mock: m}
	m.RemoteMock.callArgs = []*GoGitRepositoryMockRemoteParams{}

	m.RemotesMock = mGoGitRepositoryMockRemotes{mock: m}

	m.RepackObjectsMock = mGoGitRepositoryMockRepackObjects{mock: m}
	m.RepackObjectsMock.callArgs = []*GoGitRepositoryMockRepackObjectsParams{}

	m.ResolveRevisionMock = mGoGitRepositoryMockResolveRevision{mock: m}
	m.ResolveRevisionMock.callArgs = []*GoGitRepositoryMockResolveRevisionParams{}

	m.SetConfigMock = mGoGitRepositoryMockSetConfig{mock: m}
	m.SetConfigMock.callArgs = []*GoGitRepositoryMockSetConfigParams{}

	m.TagMock = mGoGitRepositoryMockTag{mock: m}
	m.TagMock.callArgs = []*GoGitRepositoryMockTagParams{}

	m.TagObjectMock = mGoGitRepositoryMockTagObject{mock: m}
	m.TagObjectMock.callArgs = []*GoGitRepositoryMockTagObjectParams{}

	m.TagObjectsMock = mGoGitRepositoryMockTagObjects{mock: m}

	m.TagsMock = mGoGitRepositoryMockTags{mock: m}

	m.TreeObjectMock = mGoGitRepositoryMockTreeObject{mock: m}
	m.TreeObjectMock.callArgs = []*GoGitRepositoryMockTreeObjectParams{}

	m.TreeObjectsMock = mGoGitRepositoryMockTreeObjects{mock: m}

	m.WorktreeMock = mGoGitRepositoryMockWorktree{mock: m}

	return m
}

type mGoGitRepositoryMockBlobObject struct {
	mock               *GoGitRepositoryMock
	defaultExpectation *GoGitRepositoryMockBlobObjectExpectation
	expectations       []*GoGitRepositoryMockBlobObjectExpectation

	callArgs []*GoGitRepositoryMockBlobObjectParams
	mutex    sync.RWMutex
}

// GoGitRepositoryMockBlobObjectExpectation specifies expectation struct of the GoGitRepository.BlobObject
type GoGitRepositoryMockBlobObjectExpectation struct {
	mock    *GoGitRepositoryMock
	params  *GoGitRepositoryMockBlobObjectParams
	results *GoGitRepositoryMockBlobObjectResults
	Counter uint64
}

// GoGitRepositoryMockBlobObjectParams contains parameters of the GoGitRepository.BlobObject
type GoGitRepositoryMockBlobObjectParams struct {
	h plumbing.Hash
}

// GoGitRepositoryMockBlobObjectResults contains results of the GoGitRepository.BlobObject
type GoGitRepositoryMockBlobObjectResults struct {
	bp1 *object.Blob
	err error
}

// Expect sets up expected params for GoGitRepository.BlobObject
func (mmBlobObject *mGoGitRepositoryMockBlobObject) Expect(h plumbing.Hash) *mGoGitRepositoryMockBlobObject {
	if mmBlobObject.mock.funcBlobObject != nil {
		mmBlobObject.mock.t.Fatalf("GoGitRepositoryMock.BlobObject mock is already set by Set")
	}

	if mmBlobObject.defaultExpectation == nil {
		mmBlobObject.defaultExpectation = &GoGitRepositoryMockBlobObjectExpectation{}
	}

	mmBlobObject.defaultExpectation.params = &GoGitRepositoryMockBlobObjectParams{h}
	for _, e := range mmBlobObject.expectations {
		if minimock.Equal(e.params, mmBlobObject.defaultExpectation.params) {
			mmBlobObject.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmBlobObject.defaultExpectation.params)
		}
	}

	return mmBlobObject
}

// Inspect accepts an inspector function that has same arguments as the GoGitRepository.BlobObject
func (mmBlobObject *mGoGitRepositoryMockBlobObject) Inspect(f func(h plumbing.Hash)) *mGoGitRepositoryMockBlobObject {
	if mmBlobObject.mock.inspectFuncBlobObject != nil {
		mmBlobObject.mock.t.Fatalf("Inspect function is already set for GoGitRepositoryMock.BlobObject")
	}

	mmBlobObject.mock.inspectFuncBlobObject = f

	return mmBlobObject
}

// Return sets up results that will be returned by GoGitRepository.BlobObject
func (mmBlobObject *mGoGitRepositoryMockBlobObject) Return(bp1 *object.Blob, err error) *GoGitRepositoryMock {
	if mmBlobObject.mock.funcBlobObject != nil {
		mmBlobObject.mock.t.Fatalf("GoGitRepositoryMock.BlobObject mock is already set by Set")
	}

	if mmBlobObject.defaultExpectation == nil {
		mmBlobObject.defaultExpectation = &GoGitRepositoryMockBlobObjectExpectation{mock: mmBlobObject.mock}
	}
	mmBlobObject.defaultExpectation.results = &GoGitRepositoryMockBlobObjectResults{bp1, err}
	return mmBlobObject.mock
}

// Set uses given function f to mock the GoGitRepository.BlobObject method
func (mmBlobObject *mGoGitRepositoryMockBlobObject) Set(f func(h plumbing.Hash) (bp1 *object.Blob, err error)) *GoGitRepositoryMock {
	if mmBlobObject.defaultExpectation != nil {
		mmBlobObject.mock.t.Fatalf("Default expectation is already set for the GoGitRepository.BlobObject method")
	}

	if len(mmBlobObject.expectations) > 0 {
		mmBlobObject.mock.t.Fatalf("Some expectations are already set for the GoGitRepository.BlobObject method")
	}

	mmBlobObject.mock.funcBlobObject = f
	return mmBlobObject.mock
}

// When sets expectation for the GoGitRepository.BlobObject which will trigger the result defined by the following
// Then helper
func (mmBlobObject *mGoGitRepositoryMockBlobObject) When(h plumbing.Hash) *GoGitRepositoryMockBlobObjectExpectation {
	if mmBlobObject.mock.funcBlobObject != nil {
		mmBlobObject.mock.t.Fatalf("GoGitRepositoryMock.BlobObject mock is already set by Set")
	}

	expectation := &GoGitRepositoryMockBlobObjectExpectation{
		mock:   mmBlobObject.mock,
		params: &GoGitRepositoryMockBlobObjectParams{h},
	}
	mmBlobObject.expectations = append(mmBlobObject.expectations, expectation)
	return expectation
}

// Then sets up GoGitRepository.BlobObject return parameters for the expectation previously defined by the When method
func (e *GoGitRepositoryMockBlobObjectExpectation) Then(bp1 *object.Blob, err error) *GoGitRepositoryMock {
	e.results = &GoGitRepositoryMockBlobObjectResults{bp1, err}
	return e.mock
}

// BlobObject implements vcs.GoGitRepository
func (mmBlobObject *GoGitRepositoryMock) BlobObject(h plumbing.Hash) (bp1 *object.Blob, err error) {
	mm_atomic.AddUint64(&mmBlobObject.beforeBlobObjectCounter, 1)
	defer mm_atomic.AddUint64(&mmBlobObject.afterBlobObjectCounter, 1)

	if mmBlobObject.inspectFuncBlobObject != nil {
		mmBlobObject.inspectFuncBlobObject(h)
	}

	mm_params := &GoGitRepositoryMockBlobObjectParams{h}

	// Record call args
	mmBlobObject.BlobObjectMock.mutex.Lock()
	mmBlobObject.BlobObjectMock.callArgs = append(mmBlobObject.BlobObjectMock.callArgs, mm_params)
	mmBlobObject.BlobObjectMock.mutex.Unlock()

	for _, e := range mmBlobObject.BlobObjectMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.bp1, e.results.err
		}
	}

	if mmBlobObject.BlobObjectMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmBlobObject.BlobObjectMock.defaultExpectation.Counter, 1)
		mm_want := mmBlobObject.BlobObjectMock.defaultExpectation.params
		mm_got := GoGitRepositoryMockBlobObjectParams{h}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmBlobObject.t.Errorf("GoGitRepositoryMock.BlobObject got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmBlobObject.BlobObjectMock.defaultExpectation.results
		if mm_results == nil {
			mmBlobObject.t.Fatal("No results are set for the GoGitRepositoryMock.BlobObject")
		}
		return (*mm_results).bp1, (*mm_results).err
	}
	if mmBlobObject.funcBlobObject != nil {
		return mmBlobObject.funcBlobObject(h)
	}
	mmBlobObject.t.Fatalf("Unexpected call to GoGitRepositoryMock.BlobObject. %v", h)
	return
}

// BlobObjectAfterCounter returns a count of finished GoGitRepositoryMock.BlobObject invocations
func (mmBlobObject *GoGitRepositoryMock) BlobObjectAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBlobObject.afterBlobObjectCounter)
}

// BlobObjectBeforeCounter returns a count of GoGitRepositoryMock.BlobObject invocations
func (mmBlobObject *GoGitRepositoryMock) BlobObjectBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBlobObject.beforeBlobObjectCounter)
}

// Calls returns a list of arguments used in each call to GoGitRepositoryMock.BlobObject.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmBlobObject *mGoGitRepositoryMockBlobObject) Calls() []*GoGitRepositoryMockBlobObjectParams {
	mmBlobObject.mutex.RLock()

	argCopy := make([]*GoGitRepositoryMockBlobObjectParams, len(mmBlobObject.callArgs))
	copy(argCopy, mmBlobObject.callArgs)

	mmBlobObject.mutex.RUnlock()

	return argCopy
}

// MinimockBlobObjectDone returns true if the count of the BlobObject invocations corresponds
// the number of defined expectations
func (m *GoGitRepositoryMock) MinimockBlobObjectDone() bool {
	for _, e := range m.BlobObjectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BlobObjectMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBlobObjectCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBlobObject != nil && mm_atomic.LoadUint64(&m.afterBlobObjectCounter) < 1 {
		return false
	}
	return true
}

// MinimockBlobObjectInspect logs each unmet expectation
func (m *GoGitRepositoryMock) MinimockBlobObjectInspect() {
	for _, e := range m.BlobObjectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GoGitRepositoryMock.BlobObject with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BlobObjectMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBlobObjectCounter) < 1 {
		if m.BlobObjectMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GoGitRepositoryMock.BlobObject")
		} else {
			m.t.Errorf("Expected call to GoGitRepositoryMock.BlobObject with params: %#v", *m.BlobObjectMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBlobObject != nil && mm_atomic.LoadUint64(&m.afterBlobObjectCounter) < 1 {
		m.t.Error("Expected call to GoGitRepositoryMock.BlobObject")
	}
}

type mGoGitRepositoryMockBlobObjects struct {
	mock               *GoGitRepositoryMock
	defaultExpectation *GoGitRepositoryMockBlobObjectsExpectation
	expectations       []*GoGitRepositoryMockBlobObjectsExpectation
}

// GoGitRepositoryMockBlobObjectsExpectation specifies expectation struct of the GoGitRepository.BlobObjects
type GoGitRepositoryMockBlobObjectsExpectation struct {
	mock *GoGitRepositoryMock

	results *GoGitRepositoryMockBlobObjectsResults
	Counter uint64
}

// GoGitRepositoryMockBlobObjectsResults contains results of the GoGitRepository.BlobObjects
type GoGitRepositoryMockBlobObjectsResults struct {
	bp1 *object.BlobIter
	err error
}

// Expect sets up expected params for GoGitRepository.BlobObjects
func (mmBlobObjects *mGoGitRepositoryMockBlobObjects) Expect() *mGoGitRepositoryMockBlobObjects {
	if mmBlobObjects.mock.funcBlobObjects != nil {
		mmBlobObjects.mock.t.Fatalf("GoGitRepositoryMock.BlobObjects mock is already set by Set")
	}

	if mmBlobObjects.defaultExpectation == nil {
		mmBlobObjects.defaultExpectation = &GoGitRepositoryMockBlobObjectsExpectation{}
	}

	return mmBlobObjects
}

// Inspect accepts an inspector function that has same arguments as the GoGitRepository.BlobObjects
func (mmBlobObjects *mGoGitRepositoryMockBlobObjects) Inspect(f func()) *mGoGitRepositoryMockBlobObjects {
	if mmBlobObjects.mock.inspectFuncBlobObjects != nil {
		mmBlobObjects.mock.t.Fatalf("Inspect function is already set for GoGitRepositoryMock.BlobObjects")
	}

	mmBlobObjects.mock.inspectFuncBlobObjects = f

	return mmBlobObjects
}

// Return sets up results that will be returned by GoGitRepository.BlobObjects
func (mmBlobObjects *mGoGitRepositoryMockBlobObjects) Return(bp1 *object.BlobIter, err error) *GoGitRepositoryMock {
	if mmBlobObjects.mock.funcBlobObjects != nil {
		mmBlobObjects.mock.t.Fatalf("GoGitRepositoryMock.BlobObjects mock is already set by Set")
	}

	if mmBlobObjects.defaultExpectation == nil {
		mmBlobObjects.defaultExpectation = &GoGitRepositoryMockBlobObjectsExpectation{mock: mmBlobObjects.mock}
	}
	mmBlobObjects.defaultExpectation.results = &GoGitRepositoryMockBlobObjectsResults{bp1, err}
	return mmBlobObjects.mock
}

// Set uses given function f to mock the GoGitRepository.BlobObjects method
func (mmBlobObjects *mGoGitRepositoryMockBlobObjects) Set(f func() (bp1 *object.BlobIter, err error)) *GoGitRepositoryMock {
	if mmBlobObjects.defaultExpectation != nil {
		mmBlobObjects.mock.t.Fatalf("Default expectation is already set for the GoGitRepository.BlobObjects method")
	}

	if len(mmBlobObjects.expectations) > 0 {
		mmBlobObjects.mock.t.Fatalf("Some expectations are already set for the GoGitRepository.BlobObjects method")
	}

	mmBlobObjects.mock.funcBlobObjects = f
	return mmBlobObjects.mock
}

// BlobObjects implements vcs.GoGitRepository
func (mmBlobObjects *GoGitRepositoryMock) BlobObjects() (bp1 *object.BlobIter, err error) {
	mm_atomic.AddUint64(&mmBlobObjects.beforeBlobObjectsCounter, 1)
	defer mm_atomic.AddUint64(&mmBlobObjects.afterBlobObjectsCounter, 1)

	if mmBlobObjects.inspectFuncBlobObjects != nil {
		mmBlobObjects.inspectFuncBlobObjects()
	}

	if mmBlobObjects.BlobObjectsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmBlobObjects.BlobObjectsMock.defaultExpectation.Counter, 1)

		mm_results := mmBlobObjects.BlobObjectsMock.defaultExpectation.results
		if mm_results == nil {
			mmBlobObjects.t.Fatal("No results are set for the GoGitRepositoryMock.BlobObjects")
		}
		return (*mm_results).bp1, (*mm_results).err
	}
	if mmBlobObjects.funcBlobObjects != nil {
		return mmBlobObjects.funcBlobObjects()
	}
	mmBlobObjects.t.Fatalf("Unexpected call to GoGitRepositoryMock.BlobObjects.")
	return
}

// BlobObjectsAfterCounter returns a count of finished GoGitRepositoryMock.BlobObjects invocations
func (mmBlobObjects *GoGitRepositoryMock) BlobObjectsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBlobObjects.afterBlobObjectsCounter)
}

// BlobObjectsBeforeCounter returns a count of GoGitRepositoryMock.BlobObjects invocations
func (mmBlobObjects *GoGitRepositoryMock) BlobObjectsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBlobObjects.beforeBlobObjectsCounter)
}

// MinimockBlobObjectsDone returns true if the count of the BlobObjects invocations corresponds
// the number of defined expectations
func (m *GoGitRepositoryMock) MinimockBlobObjectsDone() bool {
	for _, e := range m.BlobObjectsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BlobObjectsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBlobObjectsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBlobObjects != nil && mm_atomic.LoadUint64(&m.afterBlobObjectsCounter) < 1 {
		return false
	}
	return true
}

// MinimockBlobObjectsInspect logs each unmet expectation
func (m *GoGitRepositoryMock) MinimockBlobObjectsInspect() {
	for _, e := range m.BlobObjectsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to GoGitRepositoryMock.BlobObjects")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BlobObjectsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBlobObjectsCounter) < 1 {
		m.t.Error("Expected call to GoGitRepositoryMock.BlobObjects")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBlobObjects != nil && mm_atomic.LoadUint64(&m.afterBlobObjectsCounter) < 1 {
		m.t.Error("Expected call to GoGitRepositoryMock.BlobObjects")
	}
}

type mGoGitRepositoryMockBranch struct {
	mock               *GoGitRepositoryMock
	defaultExpectation *GoGitRepositoryMockBranchExpectation
	expectations       []*GoGitRepositoryMockBranchExpectation

	callArgs []*GoGitRepositoryMockBranchParams
	mutex    sync.RWMutex
}

// GoGitRepositoryMockBranchExpectation specifies expectation struct of the GoGitRepository.Branch
type GoGitRepositoryMockBranchExpectation struct {
	mock    *GoGitRepositoryMock
	params  *GoGitRepositoryMockBranchParams
	results *GoGitRepositoryMockBranchResults
	Counter uint64
}

// GoGitRepositoryMockBranchParams contains parameters of the GoGitRepository.Branch
type GoGitRepositoryMockBranchParams struct {
	name string
}

// GoGitRepositoryMockBranchResults contains results of the GoGitRepository.Branch
type GoGitRepositoryMockBranchResults struct {
	bp1 *config.Branch
	err error
}

// Expect sets up expected params for GoGitRepository.Branch
func (mmBranch *mGoGitRepositoryMockBranch) Expect(name string) *mGoGitRepositoryMockBranch {
	if mmBranch.mock.funcBranch != nil {
		mmBranch.mock.t.Fatalf("GoGitRepositoryMock.Branch mock is already set by Set")
	}

	if mmBranch.defaultExpectation == nil {
		mmBranch.defaultExpectation = &GoGitRepositoryMockBranchExpectation{}
	}

	mmBranch.defaultExpectation.params = &GoGitRepositoryMockBranchParams{name}
	for _, e := range mmBranch.expectations {
		if minimock.Equal(e.params, mmBranch.defaultExpectation.params) {
			mmBranch.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmBranch.defaultExpectation.params)
		}
	}

	return mmBranch
}

// Inspect accepts an inspector function that has same arguments as the GoGitRepository.Branch
func (mmBranch *mGoGitRepositoryMockBranch) Inspect(f func(name string)) *mGoGitRepositoryMockBranch {
	if mmBranch.mock.inspectFuncBranch != nil {
		mmBranch.mock.t.Fatalf("Inspect function is already set for GoGitRepositoryMock.Branch")
	}

	mmBranch.mock.inspectFuncBranch = f

	return mmBranch
}

// Return sets up results that will be returned by GoGitRepository.Branch
func (mmBranch *mGoGitRepositoryMockBranch) Return(bp1 *config.Branch, err error) *GoGitRepositoryMock {
	if mmBranch.mock.funcBranch != nil {
		mmBranch.mock.t.Fatalf("GoGitRepositoryMock.Branch mock is already set by Set")
	}

	if mmBranch.defaultExpectation == nil {
		mmBranch.defaultExpectation = &GoGitRepositoryMockBranchExpectation{mock: mmBranch.mock}
	}
	mmBranch.defaultExpectation.results = &GoGitRepositoryMockBranchResults{bp1, err}
	return mmBranch.mock
}

// Set uses given function f to mock the GoGitRepository.Branch method
func (mmBranch *mGoGitRepositoryMockBranch) Set(f func(name string) (bp1 *config.Branch, err error)) *GoGitRepositoryMock {
	if mmBranch.defaultExpectation != nil {
		mmBranch.mock.t.Fatalf("Default expectation is already set for the GoGitRepository.Branch method")
	}

	if len(mmBranch.expectations) > 0 {
		mmBranch.mock.t.Fatalf("Some expectations are already set for the GoGitRepository.Branch method")
	}

	mmBranch.mock.funcBranch = f
	return mmBranch.mock
}

// When sets expectation for the GoGitRepository.Branch which will trigger the result defined by the following
// Then helper
func (mmBranch *mGoGitRepositoryMockBranch) When(name string) *GoGitRepositoryMockBranchExpectation {
	if mmBranch.mock.funcBranch != nil {
		mmBranch.mock.t.Fatalf("GoGitRepositoryMock.Branch mock is already set by Set")
	}

	expectation := &GoGitRepositoryMockBranchExpectation{
		mock:   mmBranch.mock,
		params: &GoGitRepositoryMockBranchParams{name},
	}
	mmBranch.expectations = append(mmBranch.expectations, expectation)
	return expectation
}

// Then sets up GoGitRepository.Branch return parameters for the expectation previously defined by the When method
func (e *GoGitRepositoryMockBranchExpectation) Then(bp1 *config.Branch, err error) *GoGitRepositoryMock {
	e.results = &GoGitRepositoryMockBranchResults{bp1, err}
	return e.mock
}

// Branch implements vcs.GoGitRepository
func (mmBranch *GoGitRepositoryMock) Branch(name string) (bp1 *config.Branch, err error) {
	mm_atomic.AddUint64(&mmBranch.beforeBranchCounter, 1)
	defer mm_atomic.AddUint64(&mmBranch.afterBranchCounter, 1)

	if mmBranch.inspectFuncBranch != nil {
		mmBranch.inspectFuncBranch(name)
	}

	mm_params := &GoGitRepositoryMockBranchParams{name}

	// Record call args
	mmBranch.BranchMock.mutex.Lock()
	mmBranch.BranchMock.callArgs = append(mmBranch.BranchMock.callArgs, mm_params)
	mmBranch.BranchMock.mutex.Unlock()

	for _, e := range mmBranch.BranchMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.bp1, e.results.err
		}
	}

	if mmBranch.BranchMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmBranch.BranchMock.defaultExpectation.Counter, 1)
		mm_want := mmBranch.BranchMock.defaultExpectation.params
		mm_got := GoGitRepositoryMockBranchParams{name}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmBranch.t.Errorf("GoGitRepositoryMock.Branch got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmBranch.BranchMock.defaultExpectation.results
		if mm_results == nil {
			mmBranch.t.Fatal("No results are set for the GoGitRepositoryMock.Branch")
		}
		return (*mm_results).bp1, (*mm_results).err
	}
	if mmBranch.funcBranch != nil {
		return mmBranch.funcBranch(name)
	}
	mmBranch.t.Fatalf("Unexpected call to GoGitRepositoryMock.Branch. %v", name)
	return
}

// BranchAfterCounter returns a count of finished GoGitRepositoryMock.Branch invocations
func (mmBranch *GoGitRepositoryMock) BranchAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBranch.afterBranchCounter)
}

// BranchBeforeCounter returns a count of GoGitRepositoryMock.Branch invocations
func (mmBranch *GoGitRepositoryMock) BranchBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBranch.beforeBranchCounter)
}

// Calls returns a list of arguments used in each call to GoGitRepositoryMock.Branch.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmBranch *mGoGitRepositoryMockBranch) Calls() []*GoGitRepositoryMockBranchParams {
	mmBranch.mutex.RLock()

	argCopy := make([]*GoGitRepositoryMockBranchParams, len(mmBranch.callArgs))
	copy(argCopy, mmBranch.callArgs)

	mmBranch.mutex.RUnlock()

	return argCopy
}

// MinimockBranchDone returns true if the count of the Branch invocations corresponds
// the number of defined expectations
func (m *GoGitRepositoryMock) MinimockBranchDone() bool {
	for _, e := range m.BranchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BranchMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBranchCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBranch != nil && mm_atomic.LoadUint64(&m.afterBranchCounter) < 1 {
		return false
	}
	return true
}

// MinimockBranchInspect logs each unmet expectation
func (m *GoGitRepositoryMock) MinimockBranchInspect() {
	for _, e := range m.BranchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GoGitRepositoryMock.Branch with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BranchMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBranchCounter) < 1 {
		if m.BranchMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GoGitRepositoryMock.Branch")
		} else {
			m.t.Errorf("Expected call to GoGitRepositoryMock.Branch with params: %#v", *m.BranchMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBranch != nil && mm_atomic.LoadUint64(&m.afterBranchCounter) < 1 {
		m.t.Error("Expected call to GoGitRepositoryMock.Branch")
	}
}

type mGoGitRepositoryMockBranches struct {
	mock               *GoGitRepositoryMock
	defaultExpectation *GoGitRepositoryMockBranchesExpectation
	expectations       []*GoGitRepositoryMockBranchesExpectation
}

// GoGitRepositoryMockBranchesExpectation specifies expectation struct of the GoGitRepository.Branches
type GoGitRepositoryMockBranchesExpectation struct {
	mock *GoGitRepositoryMock

	results *GoGitRepositoryMockBranchesResults
	Counter uint64
}

// GoGitRepositoryMockBranchesResults contains results of the GoGitRepository.Branches
type GoGitRepositoryMockBranchesResults struct {
	r1  storer.ReferenceIter
	err error
}

// Expect sets up expected params for GoGitRepository.Branches
func (mmBranches *mGoGitRepositoryMockBranches) Expect() *mGoGitRepositoryMockBranches {
	if mmBranches.mock.funcBranches != nil {
		mmBranches.mock.t.Fatalf("GoGitRepositoryMock.Branches mock is already set by Set")
	}

	if mmBranches.defaultExpectation == nil {
		mmBranches.defaultExpectation = &GoGitRepositoryMockBranchesExpectation{}
	}

	return mmBranches
}

// Inspect accepts an inspector function that has same arguments as the GoGitRepository.Branches
func (mmBranches *mGoGitRepositoryMockBranches) Inspect(f func()) *mGoGitRepositoryMockBranches {
	if mmBranches.mock.inspectFuncBranches != nil {
		mmBranches.mock.t.Fatalf("Inspect function is already set for GoGitRepositoryMock.Branches")
	}

	mmBranches.mock.inspectFuncBranches = f

	return mmBranches
}

// Return sets up results that will be returned by GoGitRepository.Branches
func (mmBranches *mGoGitRepositoryMockBranches) Return(r1 storer.ReferenceIter, err error) *GoGitRepositoryMock {
	if mmBranches.mock.funcBranches != nil {
		mmBranches.mock.t.Fatalf("GoGitRepositoryMock.Branches mock is already set by Set")
	}

	if mmBranches.defaultExpectation == nil {
		mmBranches.defaultExpectation = &GoGitRepositoryMockBranchesExpectation{mock: mmBranches.mock}
	}
	mmBranches.defaultExpectation.results = &GoGitRepositoryMockBranchesResults{r1, err}
	return mmBranches.mock
}

// Set uses given function f to mock the GoGitRepository.Branches method
func (mmBranches *mGoGitRepositoryMockBranches) Set(f func() (r1 storer.ReferenceIter, err error)) *GoGitRepositoryMock {
	if mmBranches.defaultExpectation != nil {
		mmBranches.mock.t.Fatalf("Default expectation is already set for the GoGitRepository.Branches method")
	}

	if len(mmBranches.expectations) > 0 {
		mmBranches.mock.t.Fatalf("Some expectations are already set for the GoGitRepository.Branches method")
	}

	mmBranches.mock.funcBranches = f
	return mmBranches.mock
}

// Branches implements vcs.GoGitRepository
func (mmBranches *GoGitRepositoryMock) Branches() (r1 storer.ReferenceIter, err error) {
	mm_atomic.AddUint64(&mmBranches.beforeBranchesCounter, 1)
	defer mm_atomic.AddUint64(&mmBranches.afterBranchesCounter, 1)

	if mmBranches.inspectFuncBranches != nil {
		mmBranches.inspectFuncBranches()
	}

	if mmBranches.BranchesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmBranches.BranchesMock.defaultExpectation.Counter, 1)

		mm_results := mmBranches.BranchesMock.defaultExpectation.results
		if mm_results == nil {
			mmBranches.t.Fatal("No results are set for the GoGitRepositoryMock.Branches")
		}
		return (*mm_results).r1, (*mm_results).err
	}
	if mmBranches.funcBranches != nil {
		return mmBranches.funcBranches()
	}
	mmBranches.t.Fatalf("Unexpected call to GoGitRepositoryMock.Branches.")
	return
}

// BranchesAfterCounter returns a count of finished GoGitRepositoryMock.Branches invocations
func (mmBranches *GoGitRepositoryMock) BranchesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBranches.afterBranchesCounter)
}

// BranchesBeforeCounter returns a count of GoGitRepositoryMock.Branches invocations
func (mmBranches *GoGitRepositoryMock) BranchesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBranches.beforeBranchesCounter)
}

// MinimockBranchesDone returns true if the count of the Branches invocations corresponds
// the number of defined expectations
func (m *GoGitRepositoryMock) MinimockBranchesDone() bool {
	for _, e := range m.BranchesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BranchesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBranchesCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBranches != nil && mm_atomic.LoadUint64(&m.afterBranchesCounter) < 1 {
		return false
	}
	return true
}

// MinimockBranchesInspect logs each unmet expectation
func (m *GoGitRepositoryMock) MinimockBranchesInspect() {
	for _, e := range m.BranchesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to GoGitRepositoryMock.Branches")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BranchesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBranchesCounter) < 1 {
		m.t.Error("Expected call to GoGitRepositoryMock.Branches")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBranches != nil && mm_atomic.LoadUint64(&m.afterBranchesCounter) < 1 {
		m.t.Error("Expected call to GoGitRepositoryMock.Branches")
	}
}

type mGoGitRepositoryMockCommitObject struct {
	mock               *GoGitRepositoryMock
	defaultExpectation *GoGitRepositoryMockCommitObjectExpectation
	expectations       []*GoGitRepositoryMockCommitObjectExpectation

	callArgs []*GoGitRepositoryMockCommitObjectParams
	mutex    sync.RWMutex
}

// GoGitRepositoryMockCommitObjectExpectation specifies expectation struct of the GoGitRepository.CommitObject
type GoGitRepositoryMockCommitObjectExpectation struct {
	mock    *GoGitRepositoryMock
	params  *GoGitRepositoryMockCommitObjectParams
	results *GoGitRepositoryMockCommitObjectResults
	Counter uint64
}

// GoGitRepositoryMockCommitObjectParams contains parameters of the GoGitRepository.CommitObject
type GoGitRepositoryMockCommitObjectParams struct {
	h plumbing.Hash
}

// GoGitRepositoryMockCommitObjectResults contains results of the GoGitRepository.CommitObject
type GoGitRepositoryMockCommitObjectResults struct {
	cp1 *object.Commit
	err error
}

// Expect sets up expected params for GoGitRepository.CommitObject
func (mmCommitObject *mGoGitRepositoryMockCommitObject) Expect(h plumbing.Hash) *mGoGitRepositoryMockCommitObject {
	if mmCommitObject.mock.funcCommitObject != nil {
		mmCommitObject.mock.t.Fatalf("GoGitRepositoryMock.CommitObject mock is already set by Set")
	}

	if mmCommitObject.defaultExpectation == nil {
		mmCommitObject.defaultExpectation = &GoGitRepositoryMockCommitObjectExpectation{}
	}

	mmCommitObject.defaultExpectation.params = &GoGitRepositoryMockCommitObjectParams{h}
	for _, e := range mmCommitObject.expectations {
		if minimock.Equal(e.params, mmCommitObject.defaultExpectation.params) {
			mmCommitObject.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCommitObject.defaultExpectation.params)
		}
	}

	return mmCommitObject
}

// Inspect accepts an inspector function that has same arguments as the GoGitRepository.CommitObject
func (mmCommitObject *mGoGitRepositoryMockCommitObject) Inspect(f func(h plumbing.Hash)) *mGoGitRepositoryMockCommitObject {
	if mmCommitObject.mock.inspectFuncCommitObject != nil {
		mmCommitObject.mock.t.Fatalf("Inspect function is already set for GoGitRepositoryMock.CommitObject")
	}

	mmCommitObject.mock.inspectFuncCommitObject = f

	return mmCommitObject
}

// Return sets up results that will be returned by GoGitRepository.CommitObject
func (mmCommitObject *mGoGitRepositoryMockCommitObject) Return(cp1 *object.Commit, err error) *GoGitRepositoryMock {
	if mmCommitObject.mock.funcCommitObject != nil {
		mmCommitObject.mock.t.Fatalf("GoGitRepositoryMock.CommitObject mock is already set by Set")
	}

	if mmCommitObject.defaultExpectation == nil {
		mmCommitObject.defaultExpectation = &GoGitRepositoryMockCommitObjectExpectation{mock: mmCommitObject.mock}
	}
	mmCommitObject.defaultExpectation.results = &GoGitRepositoryMockCommitObjectResults{cp1, err}
	return mmCommitObject.mock
}

// Set uses given function f to mock the GoGitRepository.CommitObject method
func (mmCommitObject *mGoGitRepositoryMockCommitObject) Set(f func(h plumbing.Hash) (cp1 *object.Commit, err error)) *GoGitRepositoryMock {
	if mmCommitObject.defaultExpectation != nil {
		mmCommitObject.mock.t.Fatalf("Default expectation is already set for the GoGitRepository.CommitObject method")
	}

	if len(mmCommitObject.expectations) > 0 {
		mmCommitObject.mock.t.Fatalf("Some expectations are already set for the GoGitRepository.CommitObject method")
	}

	mmCommitObject.mock.funcCommitObject = f
	return mmCommitObject.mock
}

// When sets expectation for the GoGitRepository.CommitObject which will trigger the result defined by the following
// Then helper
func (mmCommitObject *mGoGitRepositoryMockCommitObject) When(h plumbing.Hash) *GoGitRepositoryMockCommitObjectExpectation {
	if mmCommitObject.mock.funcCommitObject != nil {
		mmCommitObject.mock.t.Fatalf("GoGitRepositoryMock.CommitObject mock is already set by Set")
	}

	expectation := &GoGitRepositoryMockCommitObjectExpectation{
		mock:   mmCommitObject.mock,
		params: &GoGitRepositoryMockCommitObjectParams{h},
	}
	mmCommitObject.expectations = append(mmCommitObject.expectations, expectation)
	return expectation
}

// Then sets up GoGitRepository.CommitObject return parameters for the expectation previously defined by the When method
func (e *GoGitRepositoryMockCommitObjectExpectation) Then(cp1 *object.Commit, err error) *GoGitRepositoryMock {
	e.results = &GoGitRepositoryMockCommitObjectResults{cp1, err}
	return e.mock
}

// CommitObject implements vcs.GoGitRepository
func (mmCommitObject *GoGitRepositoryMock) CommitObject(h plumbing.Hash) (cp1 *object.Commit, err error) {
	mm_atomic.AddUint64(&mmCommitObject.beforeCommitObjectCounter, 1)
	defer mm_atomic.AddUint64(&mmCommitObject.afterCommitObjectCounter, 1)

	if mmCommitObject.inspectFuncCommitObject != nil {
		mmCommitObject.inspectFuncCommitObject(h)
	}

	mm_params := &GoGitRepositoryMockCommitObjectParams{h}

	// Record call args
	mmCommitObject.CommitObjectMock.mutex.Lock()
	mmCommitObject.CommitObjectMock.callArgs = append(mmCommitObject.CommitObjectMock.callArgs, mm_params)
	mmCommitObject.CommitObjectMock.mutex.Unlock()

	for _, e := range mmCommitObject.CommitObjectMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmCommitObject.CommitObjectMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCommitObject.CommitObjectMock.defaultExpectation.Counter, 1)
		mm_want := mmCommitObject.CommitObjectMock.defaultExpectation.params
		mm_got := GoGitRepositoryMockCommitObjectParams{h}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCommitObject.t.Errorf("GoGitRepositoryMock.CommitObject got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCommitObject.CommitObjectMock.defaultExpectation.results
		if mm_results == nil {
			mmCommitObject.t.Fatal("No results are set for the GoGitRepositoryMock.CommitObject")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmCommitObject.funcCommitObject != nil {
		return mmCommitObject.funcCommitObject(h)
	}
	mmCommitObject.t.Fatalf("Unexpected call to GoGitRepositoryMock.CommitObject. %v", h)
	return
}

// CommitObjectAfterCounter returns a count of finished GoGitRepositoryMock.CommitObject invocations
func (mmCommitObject *GoGitRepositoryMock) CommitObjectAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCommitObject.afterCommitObjectCounter)
}

// CommitObjectBeforeCounter returns a count of GoGitRepositoryMock.CommitObject invocations
func (mmCommitObject *GoGitRepositoryMock) CommitObjectBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCommitObject.beforeCommitObjectCounter)
}

// Calls returns a list of arguments used in each call to GoGitRepositoryMock.CommitObject.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCommitObject *mGoGitRepositoryMockCommitObject) Calls() []*GoGitRepositoryMockCommitObjectParams {
	mmCommitObject.mutex.RLock()

	argCopy := make([]*GoGitRepositoryMockCommitObjectParams, len(mmCommitObject.callArgs))
	copy(argCopy, mmCommitObject.callArgs)

	mmCommitObject.mutex.RUnlock()

	return argCopy
}

// MinimockCommitObjectDone returns true if the count of the CommitObject invocations corresponds
// the number of defined expectations
func (m *GoGitRepositoryMock) MinimockCommitObjectDone() bool {
	for _, e := range m.CommitObjectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CommitObjectMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCommitObjectCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCommitObject != nil && mm_atomic.LoadUint64(&m.afterCommitObjectCounter) < 1 {
		return false
	}
	return true
}

// MinimockCommitObjectInspect logs each unmet expectation
func (m *GoGitRepositoryMock) MinimockCommitObjectInspect() {
	for _, e := range m.CommitObjectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GoGitRepositoryMock.CommitObject with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CommitObjectMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCommitObjectCounter) < 1 {
		if m.CommitObjectMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GoGitRepositoryMock.CommitObject")
		} else {
			m.t.Errorf("Expected call to GoGitRepositoryMock.CommitObject with params: %#v", *m.CommitObjectMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCommitObject != nil && mm_atomic.LoadUint64(&m.afterCommitObjectCounter) < 1 {
		m.t.Error("Expected call to GoGitRepositoryMock.CommitObject")
	}
}

type mGoGitRepositoryMockCommitObjects struct {
	mock               *GoGitRepositoryMock
	defaultExpectation *GoGitRepositoryMockCommitObjectsExpectation
	expectations       []*GoGitRepositoryMockCommitObjectsExpectation
}

// GoGitRepositoryMockCommitObjectsExpectation specifies expectation struct of the GoGitRepository.CommitObjects
type GoGitRepositoryMockCommitObjectsExpectation struct {
	mock *GoGitRepositoryMock

	results *GoGitRepositoryMockCommitObjectsResults
	Counter uint64
}

// GoGitRepositoryMockCommitObjectsResults contains results of the GoGitRepository.CommitObjects
type GoGitRepositoryMockCommitObjectsResults struct {
	c1  object.CommitIter
	err error
}

// Expect sets up expected params for GoGitRepository.CommitObjects
func (mmCommitObjects *mGoGitRepositoryMockCommitObjects) Expect() *mGoGitRepositoryMockCommitObjects {
	if mmCommitObjects.mock.funcCommitObjects != nil {
		mmCommitObjects.mock.t.Fatalf("GoGitRepositoryMock.CommitObjects mock is already set by Set")
	}

	if mmCommitObjects.defaultExpectation == nil {
		mmCommitObjects.defaultExpectation = &GoGitRepositoryMockCommitObjectsExpectation{}
	}

	return mmCommitObjects
}

// Inspect accepts an inspector function that has same arguments as the GoGitRepository.CommitObjects
func (mmCommitObjects *mGoGitRepositoryMockCommitObjects) Inspect(f func()) *mGoGitRepositoryMockCommitObjects {
	if mmCommitObjects.mock.inspectFuncCommitObjects != nil {
		mmCommitObjects.mock.t.Fatalf("Inspect function is already set for GoGitRepositoryMock.CommitObjects")
	}

	mmCommitObjects.mock.inspectFuncCommitObjects = f

	return mmCommitObjects
}

// Return sets up results that will be returned by GoGitRepository.CommitObjects
func (mmCommitObjects *mGoGitRepositoryMockCommitObjects) Return(c1 object.CommitIter, err error) *GoGitRepositoryMock {
	if mmCommitObjects.mock.funcCommitObjects != nil {
		mmCommitObjects.mock.t.Fatalf("GoGitRepositoryMock.CommitObjects mock is already set by Set")
	}

	if mmCommitObjects.defaultExpectation == nil {
		mmCommitObjects.defaultExpectation = &GoGitRepositoryMockCommitObjectsExpectation{mock: mmCommitObjects.mock}
	}
	mmCommitObjects.defaultExpectation.results = &GoGitRepositoryMockCommitObjectsResults{c1, err}
	return mmCommitObjects.mock
}

// Set uses given function f to mock the GoGitRepository.CommitObjects method
func (mmCommitObjects *mGoGitRepositoryMockCommitObjects) Set(f func() (c1 object.CommitIter, err error)) *GoGitRepositoryMock {
	if mmCommitObjects.defaultExpectation != nil {
		mmCommitObjects.mock.t.Fatalf("Default expectation is already set for the GoGitRepository.CommitObjects method")
	}

	if len(mmCommitObjects.expectations) > 0 {
		mmCommitObjects.mock.t.Fatalf("Some expectations are already set for the GoGitRepository.CommitObjects method")
	}

	mmCommitObjects.mock.funcCommitObjects = f
	return mmCommitObjects.mock
}

// CommitObjects implements vcs.GoGitRepository
func (mmCommitObjects *GoGitRepositoryMock) CommitObjects() (c1 object.CommitIter, err error) {
	mm_atomic.AddUint64(&mmCommitObjects.beforeCommitObjectsCounter, 1)
	defer mm_atomic.AddUint64(&mmCommitObjects.afterCommitObjectsCounter, 1)

	if mmCommitObjects.inspectFuncCommitObjects != nil {
		mmCommitObjects.inspectFuncCommitObjects()
	}

	if mmCommitObjects.CommitObjectsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCommitObjects.CommitObjectsMock.defaultExpectation.Counter, 1)

		mm_results := mmCommitObjects.CommitObjectsMock.defaultExpectation.results
		if mm_results == nil {
			mmCommitObjects.t.Fatal("No results are set for the GoGitRepositoryMock.CommitObjects")
		}
		return (*mm_results).c1, (*mm_results).err
	}
	if mmCommitObjects.funcCommitObjects != nil {
		return mmCommitObjects.funcCommitObjects()
	}
	mmCommitObjects.t.Fatalf("Unexpected call to GoGitRepositoryMock.CommitObjects.")
	return
}

// CommitObjectsAfterCounter returns a count of finished GoGitRepositoryMock.CommitObjects invocations
func (mmCommitObjects *GoGitRepositoryMock) CommitObjectsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCommitObjects.afterCommitObjectsCounter)
}

// CommitObjectsBeforeCounter returns a count of GoGitRepositoryMock.CommitObjects invocations
func (mmCommitObjects *GoGitRepositoryMock) CommitObjectsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCommitObjects.beforeCommitObjectsCounter)
}

// MinimockCommitObjectsDone returns true if the count of the CommitObjects invocations corresponds
// the number of defined expectations
func (m *GoGitRepositoryMock) MinimockCommitObjectsDone() bool {
	for _, e := range m.CommitObjectsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CommitObjectsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCommitObjectsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCommitObjects != nil && mm_atomic.LoadUint64(&m.afterCommitObjectsCounter) < 1 {
		return false
	}
	return true
}

// MinimockCommitObjectsInspect logs each unmet expectation
func (m *GoGitRepositoryMock) MinimockCommitObjectsInspect() {
	for _, e := range m.CommitObjectsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to GoGitRepositoryMock.CommitObjects")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CommitObjectsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCommitObjectsCounter) < 1 {
		m.t.Error("Expected call to GoGitRepositoryMock.CommitObjects")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCommitObjects != nil && mm_atomic.LoadUint64(&m.afterCommitObjectsCounter) < 1 {
		m.t.Error("Expected call to GoGitRepositoryMock.CommitObjects")
	}
}

type mGoGitRepositoryMockConfig struct {
	mock               *GoGitRepositoryMock
	defaultExpectation *GoGitRepositoryMockConfigExpectation
	expectations       []*GoGitRepositoryMockConfigExpectation
}

// GoGitRepositoryMockConfigExpectation specifies expectation struct of the GoGitRepository.Config
type GoGitRepositoryMockConfigExpectation struct {
	mock *GoGitRepositoryMock

	results *GoGitRepositoryMockConfigResults
	Counter uint64
}

// GoGitRepositoryMockConfigResults contains results of the GoGitRepository.Config
type GoGitRepositoryMockConfigResults struct {
	cp1 *config.Config
	err error
}

// Expect sets up expected params for GoGitRepository.Config
func (mmConfig *mGoGitRepositoryMockConfig) Expect() *mGoGitRepositoryMockConfig {
	if mmConfig.mock.funcConfig != nil {
		mmConfig.mock.t.Fatalf("GoGitRepositoryMock.Config mock is already set by Set")
	}

	if mmConfig.defaultExpectation == nil {
		mmConfig.defaultExpectation = &GoGitRepositoryMockConfigExpectation{}
	}

	return mmConfig
}

// Inspect accepts an inspector function that has same arguments as the GoGitRepository.Config
func (mmConfig *mGoGitRepositoryMockConfig) Inspect(f func()) *mGoGitRepositoryMockConfig {
	if mmConfig.mock.inspectFuncConfig != nil {
		mmConfig.mock.t.Fatalf("Inspect function is already set for GoGitRepositoryMock.Config")
	}

	mmConfig.mock.inspectFuncConfig = f

	return mmConfig
}

// Return sets up results that will be returned by GoGitRepository.Config
func (mmConfig *mGoGitRepositoryMockConfig) Return(cp1 *config.Config, err error) *GoGitRepositoryMock {
	if mmConfig.mock.funcConfig != nil {
		mmConfig.mock.t.Fatalf("GoGitRepositoryMock.Config mock is already set by Set")
	}

	if mmConfig.defaultExpectation == nil {
		mmConfig.defaultExpectation = &GoGitRepositoryMockConfigExpectation{mock: mmConfig.mock}
	}
	mmConfig.defaultExpectation.results = &GoGitRepositoryMockConfigResults{cp1, err}
	return mmConfig.mock
}

// Set uses given function f to mock the GoGitRepository.Config method
func (mmConfig *mGoGitRepositoryMockConfig) Set(f func() (cp1 *config.Config, err error)) *GoGitRepositoryMock {
	if mmConfig.defaultExpectation != nil {
		mmConfig.mock.t.Fatalf("Default expectation is already set for the GoGitRepository.Config method")
	}

	if len(mmConfig.expectations) > 0 {
		mmConfig.mock.t.Fatalf("Some expectations are already set for the GoGitRepository.Config method")
	}

	mmConfig.mock.funcConfig = f
	return mmConfig.mock
}

// Config implements vcs.GoGitRepository
func (mmConfig *GoGitRepositoryMock) Config() (cp1 *config.Config, err error) {
	mm_atomic.AddUint64(&mmConfig.beforeConfigCounter, 1)
	defer mm_atomic.AddUint64(&mmConfig.afterConfigCounter, 1)

	if mmConfig.inspectFuncConfig != nil {
		mmConfig.inspectFuncConfig()
	}

	if mmConfig.ConfigMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmConfig.ConfigMock.defaultExpectation.Counter, 1)

		mm_results := mmConfig.ConfigMock.defaultExpectation.results
		if mm_results == nil {
			mmConfig.t.Fatal("No results are set for the GoGitRepositoryMock.Config")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmConfig.funcConfig != nil {
		return mmConfig.funcConfig()
	}
	mmConfig.t.Fatalf("Unexpected call to GoGitRepositoryMock.Config.")
	return
}

// ConfigAfterCounter returns a count of finished GoGitRepositoryMock.Config invocations
func (mmConfig *GoGitRepositoryMock) ConfigAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConfig.afterConfigCounter)
}

// ConfigBeforeCounter returns a count of GoGitRepositoryMock.Config invocations
func (mmConfig *GoGitRepositoryMock) ConfigBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConfig.beforeConfigCounter)
}

// MinimockConfigDone returns true if the count of the Config invocations corresponds
// the number of defined expectations
func (m *GoGitRepositoryMock) MinimockConfigDone() bool {
	for _, e := range m.ConfigMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ConfigMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterConfigCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcConfig != nil && mm_atomic.LoadUint64(&m.afterConfigCounter) < 1 {
		return false
	}
	return true
}

// MinimockConfigInspect logs each unmet expectation
func (m *GoGitRepositoryMock) MinimockConfigInspect() {
	for _, e := range m.ConfigMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to GoGitRepositoryMock.Config")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ConfigMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterConfigCounter) < 1 {
		m.t.Error("Expected call to GoGitRepositoryMock.Config")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcConfig != nil && mm_atomic.LoadUint64(&m.afterConfigCounter) < 1 {
		m.t.Error("Expected call to GoGitRepositoryMock.Config")
	}
}

type mGoGitRepositoryMockConfigScoped struct {
	mock               *GoGitRepositoryMock
	defaultExpectation *GoGitRepositoryMockConfigScopedExpectation
	expectations       []*GoGitRepositoryMockConfigScopedExpectation

	callArgs []*GoGitRepositoryMockConfigScopedParams
	mutex    sync.RWMutex
}

// GoGitRepositoryMockConfigScopedExpectation specifies expectation struct of the GoGitRepository.ConfigScoped
type GoGitRepositoryMockConfigScopedExpectation struct {
	mock    *GoGitRepositoryMock
	params  *GoGitRepositoryMockConfigScopedParams
	results *GoGitRepositoryMockConfigScopedResults
	Counter uint64
}

// GoGitRepositoryMockConfigScopedParams contains parameters of the GoGitRepository.ConfigScoped
type GoGitRepositoryMockConfigScopedParams struct {
	scope config.Scope
}

// GoGitRepositoryMockConfigScopedResults contains results of the GoGitRepository.ConfigScoped
type GoGitRepositoryMockConfigScopedResults struct {
	cp1 *config.Config
	err error
}

// Expect sets up expected params for GoGitRepository.ConfigScoped
func (mmConfigScoped *mGoGitRepositoryMockConfigScoped) Expect(scope config.Scope) *mGoGitRepositoryMockConfigScoped {
	if mmConfigScoped.mock.funcConfigScoped != nil {
		mmConfigScoped.mock.t.Fatalf("GoGitRepositoryMock.ConfigScoped mock is already set by Set")
	}

	if mmConfigScoped.defaultExpectation == nil {
		mmConfigScoped.defaultExpectation = &GoGitRepositoryMockConfigScopedExpectation{}
	}

	mmConfigScoped.defaultExpectation.params = &GoGitRepositoryMockConfigScopedParams{scope}
	for _, e := range mmConfigScoped.expectations {
		if minimock.Equal(e.params, mmConfigScoped.defaultExpectation.params) {
			mmConfigScoped.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmConfigScoped.defaultExpectation.params)
		}
	}

	return mmConfigScoped
}

// Inspect accepts an inspector function that has same arguments as the GoGitRepository.ConfigScoped
func (mmConfigScoped *mGoGitRepositoryMockConfigScoped) Inspect(f func(scope config.Scope)) *mGoGitRepositoryMockConfigScoped {
	if mmConfigScoped.mock.inspectFuncConfigScoped != nil {
		mmConfigScoped.mock.t.Fatalf("Inspect function is already set for GoGitRepositoryMock.ConfigScoped")
	}

	mmConfigScoped.mock.inspectFuncConfigScoped = f

	return mmConfigScoped
}

// Return sets up results that will be returned by GoGitRepository.ConfigScoped
func (mmConfigScoped *mGoGitRepositoryMockConfigScoped) Return(cp1 *config.Config, err error) *GoGitRepositoryMock {
	if mmConfigScoped.mock.funcConfigScoped != nil {
		mmConfigScoped.mock.t.Fatalf("GoGitRepositoryMock.ConfigScoped mock is already set by Set")
	}

	if mmConfigScoped.defaultExpectation == nil {
		mmConfigScoped.defaultExpectation = &GoGitRepositoryMockConfigScopedExpectation{mock: mmConfigScoped.mock}
	}
	mmConfigScoped.defaultExpectation.results = &GoGitRepositoryMockConfigScopedResults{cp1, err}
	return mmConfigScoped.mock
}

// Set uses given function f to mock the GoGitRepository.ConfigScoped method
func (mmConfigScoped *mGoGitRepositoryMockConfigScoped) Set(f func(scope config.Scope) (cp1 *config.Config, err error)) *GoGitRepositoryMock {
	if mmConfigScoped.defaultExpectation != nil {
		mmConfigScoped.mock.t.Fatalf("Default expectation is already set for the GoGitRepository.ConfigScoped method")
	}

	if len(mmConfigScoped.expectations) > 0 {
		mmConfigScoped.mock.t.Fatalf("Some expectations are already set for the GoGitRepository.ConfigScoped method")
	}

	mmConfigScoped.mock.funcConfigScoped = f
	return mmConfigScoped.mock
}

// When sets expectation for the GoGitRepository.ConfigScoped which will trigger the result defined by the following
// Then helper
func (mmConfigScoped *mGoGitRepositoryMockConfigScoped) When(scope config.Scope) *GoGitRepositoryMockConfigScopedExpectation {
	if mmConfigScoped.mock.funcConfigScoped != nil {
		mmConfigScoped.mock.t.Fatalf("GoGitRepositoryMock.ConfigScoped mock is already set by Set")
	}

	expectation := &GoGitRepositoryMockConfigScopedExpectation{
		mock:   mmConfigScoped.mock,
		params: &GoGitRepositoryMockConfigScopedParams{scope},
	}
	mmConfigScoped.expectations = append(mmConfigScoped.expectations, expectation)
	return expectation
}

// Then sets up GoGitRepository.ConfigScoped return parameters for the expectation previously defined by the When method
func (e *GoGitRepositoryMockConfigScopedExpectation) Then(cp1 *config.Config, err error) *GoGitRepositoryMock {
	e.results = &GoGitRepositoryMockConfigScopedResults{cp1, err}
	return e.mock
}

// ConfigScoped implements vcs.GoGitRepository
func (mmConfigScoped *GoGitRepositoryMock) ConfigScoped(scope config.Scope) (cp1 *config.Config, err error) {
	mm_atomic.AddUint64(&mmConfigScoped.beforeConfigScopedCounter, 1)
	defer mm_atomic.AddUint64(&mmConfigScoped.afterConfigScopedCounter, 1)

	if mmConfigScoped.inspectFuncConfigScoped != nil {
		mmConfigScoped.inspectFuncConfigScoped(scope)
	}

	mm_params := &GoGitRepositoryMockConfigScopedParams{scope}

	// Record call args
	mmConfigScoped.ConfigScopedMock.mutex.Lock()
	mmConfigScoped.ConfigScopedMock.callArgs = append(mmConfigScoped.ConfigScopedMock.callArgs, mm_params)
	mmConfigScoped.ConfigScopedMock.mutex.Unlock()

	for _, e := range mmConfigScoped.ConfigScopedMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmConfigScoped.ConfigScopedMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmConfigScoped.ConfigScopedMock.defaultExpectation.Counter, 1)
		mm_want := mmConfigScoped.ConfigScopedMock.defaultExpectation.params
		mm_got := GoGitRepositoryMockConfigScopedParams{scope}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmConfigScoped.t.Errorf("GoGitRepositoryMock.ConfigScoped got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmConfigScoped.ConfigScopedMock.defaultExpectation.results
		if mm_results == nil {
			mmConfigScoped.t.Fatal("No results are set for the GoGitRepositoryMock.ConfigScoped")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmConfigScoped.funcConfigScoped != nil {
		return mmConfigScoped.funcConfigScoped(scope)
	}
	mmConfigScoped.t.Fatalf("Unexpected call to GoGitRepositoryMock.ConfigScoped. %v", scope)
	return
}

// ConfigScopedAfterCounter returns a count of finished GoGitRepositoryMock.ConfigScoped invocations
func (mmConfigScoped *GoGitRepositoryMock) ConfigScopedAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConfigScoped.afterConfigScopedCounter)
}

// ConfigScopedBeforeCounter returns a count of GoGitRepositoryMock.ConfigScoped invocations
func (mmConfigScoped *GoGitRepositoryMock) ConfigScopedBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConfigScoped.beforeConfigScopedCounter)
}

// Calls returns a list of arguments used in each call to GoGitRepositoryMock.ConfigScoped.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmConfigScoped *mGoGitRepositoryMockConfigScoped) Calls() []*GoGitRepositoryMockConfigScopedParams {
	mmConfigScoped.mutex.RLock()

	argCopy := make([]*GoGitRepositoryMockConfigScopedParams, len(mmConfigScoped.callArgs))
	copy(argCopy, mmConfigScoped.callArgs)

	mmConfigScoped.mutex.RUnlock()

	return argCopy
}

// MinimockConfigScopedDone returns true if the count of the ConfigScoped invocations corresponds
// the number of defined expectations
func (m *GoGitRepositoryMock) MinimockConfigScopedDone() bool {
	for _, e := range m.ConfigScopedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ConfigScopedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterConfigScopedCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcConfigScoped != nil && mm_atomic.LoadUint64(&m.afterConfigScopedCounter) < 1 {
		return false
	}
	return true
}

// MinimockConfigScopedInspect logs each unmet expectation
func (m *GoGitRepositoryMock) MinimockConfigScopedInspect() {
	for _, e := range m.ConfigScopedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GoGitRepositoryMock.ConfigScoped with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ConfigScopedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterConfigScopedCounter) < 1 {
		if m.ConfigScopedMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GoGitRepositoryMock.ConfigScoped")
		} else {
			m.t.Errorf("Expected call to GoGitRepositoryMock.ConfigScoped with params: %#v", *m.ConfigScopedMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcConfigScoped != nil && mm_atomic.LoadUint64(&m.afterConfigScopedCounter) < 1 {
		m.t.Error("Expected call to GoGitRepositoryMock.ConfigScoped")
	}
}

type mGoGitRepositoryMockCreateBranch struct {
	mock               *GoGitRepositoryMock
	defaultExpectation *GoGitRepositoryMockCreateBranchExpectation
	expectations       []*GoGitRepositoryMockCreateBranchExpectation

	callArgs []*GoGitRepositoryMockCreateBranchParams
	mutex    sync.RWMutex
}

// GoGitRepositoryMockCreateBranchExpectation specifies expectation struct of the GoGitRepository.CreateBranch
type GoGitRepositoryMockCreateBranchExpectation struct {
	mock    *GoGitRepositoryMock
	params  *GoGitRepositoryMockCreateBranchParams
	results *GoGitRepositoryMockCreateBranchResults
	Counter uint64
}

// GoGitRepositoryMockCreateBranchParams contains parameters of the GoGitRepository.CreateBranch
type GoGitRepositoryMockCreateBranchParams struct {
	c *config.Branch
}

// GoGitRepositoryMockCreateBranchResults contains results of the GoGitRepository.CreateBranch
type GoGitRepositoryMockCreateBranchResults struct {
	err error
}

// Expect sets up expected params for GoGitRepository.CreateBranch
func (mmCreateBranch *mGoGitRepositoryMockCreateBranch) Expect(c *config.Branch) *mGoGitRepositoryMockCreateBranch {
	if mmCreateBranch.mock.funcCreateBranch != nil {
		mmCreateBranch.mock.t.Fatalf("GoGitRepositoryMock.CreateBranch mock is already set by Set")
	}

	if mmCreateBranch.defaultExpectation == nil {
		mmCreateBranch.defaultExpectation = &GoGitRepositoryMockCreateBranchExpectation{}
	}

	mmCreateBranch.defaultExpectation.params = &GoGitRepositoryMockCreateBranchParams{c}
	for _, e := range mmCreateBranch.expectations {
		if minimock.Equal(e.params, mmCreateBranch.defaultExpectation.params) {
			mmCreateBranch.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateBranch.defaultExpectation.params)
		}
	}

	return mmCreateBranch
}

// Inspect accepts an inspector function that has same arguments as the GoGitRepository.CreateBranch
func (mmCreateBranch *mGoGitRepositoryMockCreateBranch) Inspect(f func(c *config.Branch)) *mGoGitRepositoryMockCreateBranch {
	if mmCreateBranch.mock.inspectFuncCreateBranch != nil {
		mmCreateBranch.mock.t.Fatalf("Inspect function is already set for GoGitRepositoryMock.CreateBranch")
	}

	mmCreateBranch.mock.inspectFuncCreateBranch = f

	return mmCreateBranch
}

// Return sets up results that will be returned by GoGitRepository.CreateBranch
func (mmCreateBranch *mGoGitRepositoryMockCreateBranch) Return(err error) *GoGitRepositoryMock {
	if mmCreateBranch.mock.funcCreateBranch != nil {
		mmCreateBranch.mock.t.Fatalf("GoGitRepositoryMock.CreateBranch mock is already set by Set")
	}

	if mmCreateBranch.defaultExpectation == nil {
		mmCreateBranch.defaultExpectation = &GoGitRepositoryMockCreateBranchExpectation{mock: mmCreateBranch.mock}
	}
	mmCreateBranch.defaultExpectation.results = &GoGitRepositoryMockCreateBranchResults{err}
	return mmCreateBranch.mock
}

// Set uses given function f to mock the GoGitRepository.CreateBranch method
func (mmCreateBranch *mGoGitRepositoryMockCreateBranch) Set(f func(c *config.Branch) (err error)) *GoGitRepositoryMock {
	if mmCreateBranch.defaultExpectation != nil {
		mmCreateBranch.mock.t.Fatalf("Default expectation is already set for the GoGitRepository.CreateBranch method")
	}

	if len(mmCreateBranch.expectations) > 0 {
		mmCreateBranch.mock.t.Fatalf("Some expectations are already set for the GoGitRepository.CreateBranch method")
	}

	mmCreateBranch.mock.funcCreateBranch = f
	return mmCreateBranch.mock
}

// When sets expectation for the GoGitRepository.CreateBranch which will trigger the result defined by the following
// Then helper
func (mmCreateBranch *mGoGitRepositoryMockCreateBranch) When(c *config.Branch) *GoGitRepositoryMockCreateBranchExpectation {
	if mmCreateBranch.mock.funcCreateBranch != nil {
		mmCreateBranch.mock.t.Fatalf("GoGitRepositoryMock.CreateBranch mock is already set by Set")
	}

	expectation := &GoGitRepositoryMockCreateBranchExpectation{
		mock:   mmCreateBranch.mock,
		params: &GoGitRepositoryMockCreateBranchParams{c},
	}
	mmCreateBranch.expectations = append(mmCreateBranch.expectations, expectation)
	return expectation
}

// Then sets up GoGitRepository.CreateBranch return parameters for the expectation previously defined by the When method
func (e *GoGitRepositoryMockCreateBranchExpectation) Then(err error) *GoGitRepositoryMock {
	e.results = &GoGitRepositoryMockCreateBranchResults{err}
	return e.mock
}

// CreateBranch implements vcs.GoGitRepository
func (mmCreateBranch *GoGitRepositoryMock) CreateBranch(c *config.Branch) (err error) {
	mm_atomic.AddUint64(&mmCreateBranch.beforeCreateBranchCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateBranch.afterCreateBranchCounter, 1)

	if mmCreateBranch.inspectFuncCreateBranch != nil {
		mmCreateBranch.inspectFuncCreateBranch(c)
	}

	mm_params := &GoGitRepositoryMockCreateBranchParams{c}

	// Record call args
	mmCreateBranch.CreateBranchMock.mutex.Lock()
	mmCreateBranch.CreateBranchMock.callArgs = append(mmCreateBranch.CreateBranchMock.callArgs, mm_params)
	mmCreateBranch.CreateBranchMock.mutex.Unlock()

	for _, e := range mmCreateBranch.CreateBranchMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateBranch.CreateBranchMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateBranch.CreateBranchMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateBranch.CreateBranchMock.defaultExpectation.params
		mm_got := GoGitRepositoryMockCreateBranchParams{c}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateBranch.t.Errorf("GoGitRepositoryMock.CreateBranch got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateBranch.CreateBranchMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateBranch.t.Fatal("No results are set for the GoGitRepositoryMock.CreateBranch")
		}
		return (*mm_results).err
	}
	if mmCreateBranch.funcCreateBranch != nil {
		return mmCreateBranch.funcCreateBranch(c)
	}
	mmCreateBranch.t.Fatalf("Unexpected call to GoGitRepositoryMock.CreateBranch. %v", c)
	return
}

// CreateBranchAfterCounter returns a count of finished GoGitRepositoryMock.CreateBranch invocations
func (mmCreateBranch *GoGitRepositoryMock) CreateBranchAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateBranch.afterCreateBranchCounter)
}

// CreateBranchBeforeCounter returns a count of GoGitRepositoryMock.CreateBranch invocations
func (mmCreateBranch *GoGitRepositoryMock) CreateBranchBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateBranch.beforeCreateBranchCounter)
}

// Calls returns a list of arguments used in each call to GoGitRepositoryMock.CreateBranch.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateBranch *mGoGitRepositoryMockCreateBranch) Calls() []*GoGitRepositoryMockCreateBranchParams {
	mmCreateBranch.mutex.RLock()

	argCopy := make([]*GoGitRepositoryMockCreateBranchParams, len(mmCreateBranch.callArgs))
	copy(argCopy, mmCreateBranch.callArgs)

	mmCreateBranch.mutex.RUnlock()

	return argCopy
}

// MinimockCreateBranchDone returns true if the count of the CreateBranch invocations corresponds
// the number of defined expectations
func (m *GoGitRepositoryMock) MinimockCreateBranchDone() bool {
	for _, e := range m.CreateBranchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateBranchMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateBranchCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateBranch != nil && mm_atomic.LoadUint64(&m.afterCreateBranchCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateBranchInspect logs each unmet expectation
func (m *GoGitRepositoryMock) MinimockCreateBranchInspect() {
	for _, e := range m.CreateBranchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GoGitRepositoryMock.CreateBranch with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateBranchMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateBranchCounter) < 1 {
		if m.CreateBranchMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GoGitRepositoryMock.CreateBranch")
		} else {
			m.t.Errorf("Expected call to GoGitRepositoryMock.CreateBranch with params: %#v", *m.CreateBranchMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateBranch != nil && mm_atomic.LoadUint64(&m.afterCreateBranchCounter) < 1 {
		m.t.Error("Expected call to GoGitRepositoryMock.CreateBranch")
	}
}

type mGoGitRepositoryMockCreateRemote struct {
	mock               *GoGitRepositoryMock
	defaultExpectation *GoGitRepositoryMockCreateRemoteExpectation
	expectations       []*GoGitRepositoryMockCreateRemoteExpectation

	callArgs []*GoGitRepositoryMockCreateRemoteParams
	mutex    sync.RWMutex
}

// GoGitRepositoryMockCreateRemoteExpectation specifies expectation struct of the GoGitRepository.CreateRemote
type GoGitRepositoryMockCreateRemoteExpectation struct {
	mock    *GoGitRepositoryMock
	params  *GoGitRepositoryMockCreateRemoteParams
	results *GoGitRepositoryMockCreateRemoteResults
	Counter uint64
}

// GoGitRepositoryMockCreateRemoteParams contains parameters of the GoGitRepository.CreateRemote
type GoGitRepositoryMockCreateRemoteParams struct {
	c *config.RemoteConfig
}

// GoGitRepositoryMockCreateRemoteResults contains results of the GoGitRepository.CreateRemote
type GoGitRepositoryMockCreateRemoteResults struct {
	rp1 *git.Remote
	err error
}

// Expect sets up expected params for GoGitRepository.CreateRemote
func (mmCreateRemote *mGoGitRepositoryMockCreateRemote) Expect(c *config.RemoteConfig) *mGoGitRepositoryMockCreateRemote {
	if mmCreateRemote.mock.funcCreateRemote != nil {
		mmCreateRemote.mock.t.Fatalf("GoGitRepositoryMock.CreateRemote mock is already set by Set")
	}

	if mmCreateRemote.defaultExpectation == nil {
		mmCreateRemote.defaultExpectation = &GoGitRepositoryMockCreateRemoteExpectation{}
	}

	mmCreateRemote.defaultExpectation.params = &GoGitRepositoryMockCreateRemoteParams{c}
	for _, e := range mmCreateRemote.expectations {
		if minimock.Equal(e.params, mmCreateRemote.defaultExpectation.params) {
			mmCreateRemote.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateRemote.defaultExpectation.params)
		}
	}

	return mmCreateRemote
}

// Inspect accepts an inspector function that has same arguments as the GoGitRepository.CreateRemote
func (mmCreateRemote *mGoGitRepositoryMockCreateRemote) Inspect(f func(c *config.RemoteConfig)) *mGoGitRepositoryMockCreateRemote {
	if mmCreateRemote.mock.inspectFuncCreateRemote != nil {
		mmCreateRemote.mock.t.Fatalf("Inspect function is already set for GoGitRepositoryMock.CreateRemote")
	}

	mmCreateRemote.mock.inspectFuncCreateRemote = f

	return mmCreateRemote
}

// Return sets up results that will be returned by GoGitRepository.CreateRemote
func (mmCreateRemote *mGoGitRepositoryMockCreateRemote) Return(rp1 *git.Remote, err error) *GoGitRepositoryMock {
	if mmCreateRemote.mock.funcCreateRemote != nil {
		mmCreateRemote.mock.t.Fatalf("GoGitRepositoryMock.CreateRemote mock is already set by Set")
	}

	if mmCreateRemote.defaultExpectation == nil {
		mmCreateRemote.defaultExpectation = &GoGitRepositoryMockCreateRemoteExpectation{mock: mmCreateRemote.mock}
	}
	mmCreateRemote.defaultExpectation.results = &GoGitRepositoryMockCreateRemoteResults{rp1, err}
	return mmCreateRemote.mock
}

// Set uses given function f to mock the GoGitRepository.CreateRemote method
func (mmCreateRemote *mGoGitRepositoryMockCreateRemote) Set(f func(c *config.RemoteConfig) (rp1 *git.Remote, err error)) *GoGitRepositoryMock {
	if mmCreateRemote.defaultExpectation != nil {
		mmCreateRemote.mock.t.Fatalf("Default expectation is already set for the GoGitRepository.CreateRemote method")
	}

	if len(mmCreateRemote.expectations) > 0 {
		mmCreateRemote.mock.t.Fatalf("Some expectations are already set for the GoGitRepository.CreateRemote method")
	}

	mmCreateRemote.mock.funcCreateRemote = f
	return mmCreateRemote.mock
}

// When sets expectation for the GoGitRepository.CreateRemote which will trigger the result defined by the following
// Then helper
func (mmCreateRemote *mGoGitRepositoryMockCreateRemote) When(c *config.RemoteConfig) *GoGitRepositoryMockCreateRemoteExpectation {
	if mmCreateRemote.mock.funcCreateRemote != nil {
		mmCreateRemote.mock.t.Fatalf("GoGitRepositoryMock.CreateRemote mock is already set by Set")
	}

	expectation := &GoGitRepositoryMockCreateRemoteExpectation{
		mock:   mmCreateRemote.mock,
		params: &GoGitRepositoryMockCreateRemoteParams{c},
	}
	mmCreateRemote.expectations = append(mmCreateRemote.expectations, expectation)
	return expectation
}

// Then sets up GoGitRepository.CreateRemote return parameters for the expectation previously defined by the When method
func (e *GoGitRepositoryMockCreateRemoteExpectation) Then(rp1 *git.Remote, err error) *GoGitRepositoryMock {
	e.results = &GoGitRepositoryMockCreateRemoteResults{rp1, err}
	return e.mock
}

// CreateRemote implements vcs.GoGitRepository
func (mmCreateRemote *GoGitRepositoryMock) CreateRemote(c *config.RemoteConfig) (rp1 *git.Remote, err error) {
	mm_atomic.AddUint64(&mmCreateRemote.beforeCreateRemoteCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateRemote.afterCreateRemoteCounter, 1)

	if mmCreateRemote.inspectFuncCreateRemote != nil {
		mmCreateRemote.inspectFuncCreateRemote(c)
	}

	mm_params := &GoGitRepositoryMockCreateRemoteParams{c}

	// Record call args
	mmCreateRemote.CreateRemoteMock.mutex.Lock()
	mmCreateRemote.CreateRemoteMock.callArgs = append(mmCreateRemote.CreateRemoteMock.callArgs, mm_params)
	mmCreateRemote.CreateRemoteMock.mutex.Unlock()

	for _, e := range mmCreateRemote.CreateRemoteMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.rp1, e.results.err
		}
	}

	if mmCreateRemote.CreateRemoteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateRemote.CreateRemoteMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateRemote.CreateRemoteMock.defaultExpectation.params
		mm_got := GoGitRepositoryMockCreateRemoteParams{c}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateRemote.t.Errorf("GoGitRepositoryMock.CreateRemote got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateRemote.CreateRemoteMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateRemote.t.Fatal("No results are set for the GoGitRepositoryMock.CreateRemote")
		}
		return (*mm_results).rp1, (*mm_results).err
	}
	if mmCreateRemote.funcCreateRemote != nil {
		return mmCreateRemote.funcCreateRemote(c)
	}
	mmCreateRemote.t.Fatalf("Unexpected call to GoGitRepositoryMock.CreateRemote. %v", c)
	return
}

// CreateRemoteAfterCounter returns a count of finished GoGitRepositoryMock.CreateRemote invocations
func (mmCreateRemote *GoGitRepositoryMock) CreateRemoteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateRemote.afterCreateRemoteCounter)
}

// CreateRemoteBeforeCounter returns a count of GoGitRepositoryMock.CreateRemote invocations
func (mmCreateRemote *GoGitRepositoryMock) CreateRemoteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateRemote.beforeCreateRemoteCounter)
}

// Calls returns a list of arguments used in each call to GoGitRepositoryMock.CreateRemote.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateRemote *mGoGitRepositoryMockCreateRemote) Calls() []*GoGitRepositoryMockCreateRemoteParams {
	mmCreateRemote.mutex.RLock()

	argCopy := make([]*GoGitRepositoryMockCreateRemoteParams, len(mmCreateRemote.callArgs))
	copy(argCopy, mmCreateRemote.callArgs)

	mmCreateRemote.mutex.RUnlock()

	return argCopy
}

// MinimockCreateRemoteDone returns true if the count of the CreateRemote invocations corresponds
// the number of defined expectations
func (m *GoGitRepositoryMock) MinimockCreateRemoteDone() bool {
	for _, e := range m.CreateRemoteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateRemoteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateRemoteCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateRemote != nil && mm_atomic.LoadUint64(&m.afterCreateRemoteCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateRemoteInspect logs each unmet expectation
func (m *GoGitRepositoryMock) MinimockCreateRemoteInspect() {
	for _, e := range m.CreateRemoteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GoGitRepositoryMock.CreateRemote with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateRemoteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateRemoteCounter) < 1 {
		if m.CreateRemoteMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GoGitRepositoryMock.CreateRemote")
		} else {
			m.t.Errorf("Expected call to GoGitRepositoryMock.CreateRemote with params: %#v", *m.CreateRemoteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateRemote != nil && mm_atomic.LoadUint64(&m.afterCreateRemoteCounter) < 1 {
		m.t.Error("Expected call to GoGitRepositoryMock.CreateRemote")
	}
}

type mGoGitRepositoryMockCreateRemoteAnonymous struct {
	mock               *GoGitRepositoryMock
	defaultExpectation *GoGitRepositoryMockCreateRemoteAnonymousExpectation
	expectations       []*GoGitRepositoryMockCreateRemoteAnonymousExpectation

	callArgs []*GoGitRepositoryMockCreateRemoteAnonymousParams
	mutex    sync.RWMutex
}

// GoGitRepositoryMockCreateRemoteAnonymousExpectation specifies expectation struct of the GoGitRepository.CreateRemoteAnonymous
type GoGitRepositoryMockCreateRemoteAnonymousExpectation struct {
	mock    *GoGitRepositoryMock
	params  *GoGitRepositoryMockCreateRemoteAnonymousParams
	results *GoGitRepositoryMockCreateRemoteAnonymousResults
	Counter uint64
}

// GoGitRepositoryMockCreateRemoteAnonymousParams contains parameters of the GoGitRepository.CreateRemoteAnonymous
type GoGitRepositoryMockCreateRemoteAnonymousParams struct {
	c *config.RemoteConfig
}

// GoGitRepositoryMockCreateRemoteAnonymousResults contains results of the GoGitRepository.CreateRemoteAnonymous
type GoGitRepositoryMockCreateRemoteAnonymousResults struct {
	rp1 *git.Remote
	err error
}

// Expect sets up expected params for GoGitRepository.CreateRemoteAnonymous
func (mmCreateRemoteAnonymous *mGoGitRepositoryMockCreateRemoteAnonymous) Expect(c *config.RemoteConfig) *mGoGitRepositoryMockCreateRemoteAnonymous {
	if mmCreateRemoteAnonymous.mock.funcCreateRemoteAnonymous != nil {
		mmCreateRemoteAnonymous.mock.t.Fatalf("GoGitRepositoryMock.CreateRemoteAnonymous mock is already set by Set")
	}

	if mmCreateRemoteAnonymous.defaultExpectation == nil {
		mmCreateRemoteAnonymous.defaultExpectation = &GoGitRepositoryMockCreateRemoteAnonymousExpectation{}
	}

	mmCreateRemoteAnonymous.defaultExpectation.params = &GoGitRepositoryMockCreateRemoteAnonymousParams{c}
	for _, e := range mmCreateRemoteAnonymous.expectations {
		if minimock.Equal(e.params, mmCreateRemoteAnonymous.defaultExpectation.params) {
			mmCreateRemoteAnonymous.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateRemoteAnonymous.defaultExpectation.params)
		}
	}

	return mmCreateRemoteAnonymous
}

// Inspect accepts an inspector function that has same arguments as the GoGitRepository.CreateRemoteAnonymous
func (mmCreateRemoteAnonymous *mGoGitRepositoryMockCreateRemoteAnonymous) Inspect(f func(c *config.RemoteConfig)) *mGoGitRepositoryMockCreateRemoteAnonymous {
	if mmCreateRemoteAnonymous.mock.inspectFuncCreateRemoteAnonymous != nil {
		mmCreateRemoteAnonymous.mock.t.Fatalf("Inspect function is already set for GoGitRepositoryMock.CreateRemoteAnonymous")
	}

	mmCreateRemoteAnonymous.mock.inspectFuncCreateRemoteAnonymous = f

	return mmCreateRemoteAnonymous
}

// Return sets up results that will be returned by GoGitRepository.CreateRemoteAnonymous
func (mmCreateRemoteAnonymous *mGoGitRepositoryMockCreateRemoteAnonymous) Return(rp1 *git.Remote, err error) *GoGitRepositoryMock {
	if mmCreateRemoteAnonymous.mock.funcCreateRemoteAnonymous != nil {
		mmCreateRemoteAnonymous.mock.t.Fatalf("GoGitRepositoryMock.CreateRemoteAnonymous mock is already set by Set")
	}

	if mmCreateRemoteAnonymous.defaultExpectation == nil {
		mmCreateRemoteAnonymous.defaultExpectation = &GoGitRepositoryMockCreateRemoteAnonymousExpectation{mock: mmCreateRemoteAnonymous.mock}
	}
	mmCreateRemoteAnonymous.defaultExpectation.results = &GoGitRepositoryMockCreateRemoteAnonymousResults{rp1, err}
	return mmCreateRemoteAnonymous.mock
}

// Set uses given function f to mock the GoGitRepository.CreateRemoteAnonymous method
func (mmCreateRemoteAnonymous *mGoGitRepositoryMockCreateRemoteAnonymous) Set(f func(c *config.RemoteConfig) (rp1 *git.Remote, err error)) *GoGitRepositoryMock {
	if mmCreateRemoteAnonymous.defaultExpectation != nil {
		mmCreateRemoteAnonymous.mock.t.Fatalf("Default expectation is already set for the GoGitRepository.CreateRemoteAnonymous method")
	}

	if len(mmCreateRemoteAnonymous.expectations) > 0 {
		mmCreateRemoteAnonymous.mock.t.Fatalf("Some expectations are already set for the GoGitRepository.CreateRemoteAnonymous method")
	}

	mmCreateRemoteAnonymous.mock.funcCreateRemoteAnonymous = f
	return mmCreateRemoteAnonymous.mock
}

// When sets expectation for the GoGitRepository.CreateRemoteAnonymous which will trigger the result defined by the following
// Then helper
func (mmCreateRemoteAnonymous *mGoGitRepositoryMockCreateRemoteAnonymous) When(c *config.RemoteConfig) *GoGitRepositoryMockCreateRemoteAnonymousExpectation {
	if mmCreateRemoteAnonymous.mock.funcCreateRemoteAnonymous != nil {
		mmCreateRemoteAnonymous.mock.t.Fatalf("GoGitRepositoryMock.CreateRemoteAnonymous mock is already set by Set")
	}

	expectation := &GoGitRepositoryMockCreateRemoteAnonymousExpectation{
		mock:   mmCreateRemoteAnonymous.mock,
		params: &GoGitRepositoryMockCreateRemoteAnonymousParams{c},
	}
	mmCreateRemoteAnonymous.expectations = append(mmCreateRemoteAnonymous.expectations, expectation)
	return expectation
}

// Then sets up GoGitRepository.CreateRemoteAnonymous return parameters for the expectation previously defined by the When method
func (e *GoGitRepositoryMockCreateRemoteAnonymousExpectation) Then(rp1 *git.Remote, err error) *GoGitRepositoryMock {
	e.results = &GoGitRepositoryMockCreateRemoteAnonymousResults{rp1, err}
	return e.mock
}

// CreateRemoteAnonymous implements vcs.GoGitRepository
func (mmCreateRemoteAnonymous *GoGitRepositoryMock) CreateRemoteAnonymous(c *config.RemoteConfig) (rp1 *git.Remote, err error) {
	mm_atomic.AddUint64(&mmCreateRemoteAnonymous.beforeCreateRemoteAnonymousCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateRemoteAnonymous.afterCreateRemoteAnonymousCounter, 1)

	if mmCreateRemoteAnonymous.inspectFuncCreateRemoteAnonymous != nil {
		mmCreateRemoteAnonymous.inspectFuncCreateRemoteAnonymous(c)
	}

	mm_params := &GoGitRepositoryMockCreateRemoteAnonymousParams{c}

	// Record call args
	mmCreateRemoteAnonymous.CreateRemoteAnonymousMock.mutex.Lock()
	mmCreateRemoteAnonymous.CreateRemoteAnonymousMock.callArgs = append(mmCreateRemoteAnonymous.CreateRemoteAnonymousMock.callArgs, mm_params)
	mmCreateRemoteAnonymous.CreateRemoteAnonymousMock.mutex.Unlock()

	for _, e := range mmCreateRemoteAnonymous.CreateRemoteAnonymousMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.rp1, e.results.err
		}
	}

	if mmCreateRemoteAnonymous.CreateRemoteAnonymousMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateRemoteAnonymous.CreateRemoteAnonymousMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateRemoteAnonymous.CreateRemoteAnonymousMock.defaultExpectation.params
		mm_got := GoGitRepositoryMockCreateRemoteAnonymousParams{c}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateRemoteAnonymous.t.Errorf("GoGitRepositoryMock.CreateRemoteAnonymous got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateRemoteAnonymous.CreateRemoteAnonymousMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateRemoteAnonymous.t.Fatal("No results are set for the GoGitRepositoryMock.CreateRemoteAnonymous")
		}
		return (*mm_results).rp1, (*mm_results).err
	}
	if mmCreateRemoteAnonymous.funcCreateRemoteAnonymous != nil {
		return mmCreateRemoteAnonymous.funcCreateRemoteAnonymous(c)
	}
	mmCreateRemoteAnonymous.t.Fatalf("Unexpected call to GoGitRepositoryMock.CreateRemoteAnonymous. %v", c)
	return
}

// CreateRemoteAnonymousAfterCounter returns a count of finished GoGitRepositoryMock.CreateRemoteAnonymous invocations
func (mmCreateRemoteAnonymous *GoGitRepositoryMock) CreateRemoteAnonymousAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateRemoteAnonymous.afterCreateRemoteAnonymousCounter)
}

// CreateRemoteAnonymousBeforeCounter returns a count of GoGitRepositoryMock.CreateRemoteAnonymous invocations
func (mmCreateRemoteAnonymous *GoGitRepositoryMock) CreateRemoteAnonymousBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateRemoteAnonymous.beforeCreateRemoteAnonymousCounter)
}

// Calls returns a list of arguments used in each call to GoGitRepositoryMock.CreateRemoteAnonymous.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateRemoteAnonymous *mGoGitRepositoryMockCreateRemoteAnonymous) Calls() []*GoGitRepositoryMockCreateRemoteAnonymousParams {
	mmCreateRemoteAnonymous.mutex.RLock()

	argCopy := make([]*GoGitRepositoryMockCreateRemoteAnonymousParams, len(mmCreateRemoteAnonymous.callArgs))
	copy(argCopy, mmCreateRemoteAnonymous.callArgs)

	mmCreateRemoteAnonymous.mutex.RUnlock()

	return argCopy
}

// MinimockCreateRemoteAnonymousDone returns true if the count of the CreateRemoteAnonymous invocations corresponds
// the number of defined expectations
func (m *GoGitRepositoryMock) MinimockCreateRemoteAnonymousDone() bool {
	for _, e := range m.CreateRemoteAnonymousMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateRemoteAnonymousMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateRemoteAnonymousCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateRemoteAnonymous != nil && mm_atomic.LoadUint64(&m.afterCreateRemoteAnonymousCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateRemoteAnonymousInspect logs each unmet expectation
func (m *GoGitRepositoryMock) MinimockCreateRemoteAnonymousInspect() {
	for _, e := range m.CreateRemoteAnonymousMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GoGitRepositoryMock.CreateRemoteAnonymous with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateRemoteAnonymousMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateRemoteAnonymousCounter) < 1 {
		if m.CreateRemoteAnonymousMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GoGitRepositoryMock.CreateRemoteAnonymous")
		} else {
			m.t.Errorf("Expected call to GoGitRepositoryMock.CreateRemoteAnonymous with params: %#v", *m.CreateRemoteAnonymousMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateRemoteAnonymous != nil && mm_atomic.LoadUint64(&m.afterCreateRemoteAnonymousCounter) < 1 {
		m.t.Error("Expected call to GoGitRepositoryMock.CreateRemoteAnonymous")
	}
}

type mGoGitRepositoryMockCreateTag struct {
	mock               *GoGitRepositoryMock
	defaultExpectation *GoGitRepositoryMockCreateTagExpectation
	expectations       []*GoGitRepositoryMockCreateTagExpectation

	callArgs []*GoGitRepositoryMockCreateTagParams
	mutex    sync.RWMutex
}

// GoGitRepositoryMockCreateTagExpectation specifies expectation struct of the GoGitRepository.CreateTag
type GoGitRepositoryMockCreateTagExpectation struct {
	mock    *GoGitRepositoryMock
	params  *GoGitRepositoryMockCreateTagParams
	results *GoGitRepositoryMockCreateTagResults
	Counter uint64
}

// GoGitRepositoryMockCreateTagParams contains parameters of the GoGitRepository.CreateTag
type GoGitRepositoryMockCreateTagParams struct {
	name string
	hash plumbing.Hash
	opts *git.CreateTagOptions
}

// GoGitRepositoryMockCreateTagResults contains results of the GoGitRepository.CreateTag
type GoGitRepositoryMockCreateTagResults struct {
	rp1 *plumbing.Reference
	err error
}

// Expect sets up expected params for GoGitRepository.CreateTag
func (mmCreateTag *mGoGitRepositoryMockCreateTag) Expect(name string, hash plumbing.Hash, opts *git.CreateTagOptions) *mGoGitRepositoryMockCreateTag {
	if mmCreateTag.mock.funcCreateTag != nil {
		mmCreateTag.mock.t.Fatalf("GoGitRepositoryMock.CreateTag mock is already set by Set")
	}

	if mmCreateTag.defaultExpectation == nil {
		mmCreateTag.defaultExpectation = &GoGitRepositoryMockCreateTagExpectation{}
	}

	mmCreateTag.defaultExpectation.params = &GoGitRepositoryMockCreateTagParams{name, hash, opts}
	for _, e := range mmCreateTag.expectations {
		if minimock.Equal(e.params, mmCreateTag.defaultExpectation.params) {
			mmCreateTag.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateTag.defaultExpectation.params)
		}
	}

	return mmCreateTag
}

// Inspect accepts an inspector function that has same arguments as the GoGitRepository.CreateTag
func (mmCreateTag *mGoGitRepositoryMockCreateTag) Inspect(f func(name string, hash plumbing.Hash, opts *git.CreateTagOptions)) *mGoGitRepositoryMockCreateTag {
	if mmCreateTag.mock.inspectFuncCreateTag != nil {
		mmCreateTag.mock.t.Fatalf("Inspect function is already set for GoGitRepositoryMock.CreateTag")
	}

	mmCreateTag.mock.inspectFuncCreateTag = f

	return mmCreateTag
}

// Return sets up results that will be returned by GoGitRepository.CreateTag
func (mmCreateTag *mGoGitRepositoryMockCreateTag) Return(rp1 *plumbing.Reference, err error) *GoGitRepositoryMock {
	if mmCreateTag.mock.funcCreateTag != nil {
		mmCreateTag.mock.t.Fatalf("GoGitRepositoryMock.CreateTag mock is already set by Set")
	}

	if mmCreateTag.defaultExpectation == nil {
		mmCreateTag.defaultExpectation = &GoGitRepositoryMockCreateTagExpectation{mock: mmCreateTag.mock}
	}
	mmCreateTag.defaultExpectation.results = &GoGitRepositoryMockCreateTagResults{rp1, err}
	return mmCreateTag.mock
}

// Set uses given function f to mock the GoGitRepository.CreateTag method
func (mmCreateTag *mGoGitRepositoryMockCreateTag) Set(f func(name string, hash plumbing.Hash, opts *git.CreateTagOptions) (rp1 *plumbing.Reference, err error)) *GoGitRepositoryMock {
	if mmCreateTag.defaultExpectation != nil {
		mmCreateTag.mock.t.Fatalf("Default expectation is already set for the GoGitRepository.CreateTag method")
	}

	if len(mmCreateTag.expectations) > 0 {
		mmCreateTag.mock.t.Fatalf("Some expectations are already set for the GoGitRepository.CreateTag method")
	}

	mmCreateTag.mock.funcCreateTag = f
	return mmCreateTag.mock
}

// When sets expectation for the GoGitRepository.CreateTag which will trigger the result defined by the following
// Then helper
func (mmCreateTag *mGoGitRepositoryMockCreateTag) When(name string, hash plumbing.Hash, opts *git.CreateTagOptions) *GoGitRepositoryMockCreateTagExpectation {
	if mmCreateTag.mock.funcCreateTag != nil {
		mmCreateTag.mock.t.Fatalf("GoGitRepositoryMock.CreateTag mock is already set by Set")
	}

	expectation := &GoGitRepositoryMockCreateTagExpectation{
		mock:   mmCreateTag.mock,
		params: &GoGitRepositoryMockCreateTagParams{name, hash, opts},
	}
	mmCreateTag.expectations = append(mmCreateTag.expectations, expectation)
	return expectation
}

// Then sets up GoGitRepository.CreateTag return parameters for the expectation previously defined by the When method
func (e *GoGitRepositoryMockCreateTagExpectation) Then(rp1 *plumbing.Reference, err error) *GoGitRepositoryMock {
	e.results = &GoGitRepositoryMockCreateTagResults{rp1, err}
	return e.mock
}

// CreateTag implements vcs.GoGitRepository
func (mmCreateTag *GoGitRepositoryMock) CreateTag(name string, hash plumbing.Hash, opts *git.CreateTagOptions) (rp1 *plumbing.Reference, err error) {
	mm_atomic.AddUint64(&mmCreateTag.beforeCreateTagCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateTag.afterCreateTagCounter, 1)

	if mmCreateTag.inspectFuncCreateTag != nil {
		mmCreateTag.inspectFuncCreateTag(name, hash, opts)
	}

	mm_params := &GoGitRepositoryMockCreateTagParams{name, hash, opts}

	// Record call args
	mmCreateTag.CreateTagMock.mutex.Lock()
	mmCreateTag.CreateTagMock.callArgs = append(mmCreateTag.CreateTagMock.callArgs, mm_params)
	mmCreateTag.CreateTagMock.mutex.Unlock()

	for _, e := range mmCreateTag.CreateTagMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.rp1, e.results.err
		}
	}

	if mmCreateTag.CreateTagMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateTag.CreateTagMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateTag.CreateTagMock.defaultExpectation.params
		mm_got := GoGitRepositoryMockCreateTagParams{name, hash, opts}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateTag.t.Errorf("GoGitRepositoryMock.CreateTag got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateTag.CreateTagMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateTag.t.Fatal("No results are set for the GoGitRepositoryMock.CreateTag")
		}
		return (*mm_results).rp1, (*mm_results).err
	}
	if mmCreateTag.funcCreateTag != nil {
		return mmCreateTag.funcCreateTag(name, hash, opts)
	}
	mmCreateTag.t.Fatalf("Unexpected call to GoGitRepositoryMock.CreateTag. %v %v %v", name, hash, opts)
	return
}

// CreateTagAfterCounter returns a count of finished GoGitRepositoryMock.CreateTag invocations
func (mmCreateTag *GoGitRepositoryMock) CreateTagAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateTag.afterCreateTagCounter)
}

// CreateTagBeforeCounter returns a count of GoGitRepositoryMock.CreateTag invocations
func (mmCreateTag *GoGitRepositoryMock) CreateTagBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateTag.beforeCreateTagCounter)
}

// Calls returns a list of arguments used in each call to GoGitRepositoryMock.CreateTag.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateTag *mGoGitRepositoryMockCreateTag) Calls() []*GoGitRepositoryMockCreateTagParams {
	mmCreateTag.mutex.RLock()

	argCopy := make([]*GoGitRepositoryMockCreateTagParams, len(mmCreateTag.callArgs))
	copy(argCopy, mmCreateTag.callArgs)

	mmCreateTag.mutex.RUnlock()

	return argCopy
}

// MinimockCreateTagDone returns true if the count of the CreateTag invocations corresponds
// the number of defined expectations
func (m *GoGitRepositoryMock) MinimockCreateTagDone() bool {
	for _, e := range m.CreateTagMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateTagMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateTagCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateTag != nil && mm_atomic.LoadUint64(&m.afterCreateTagCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateTagInspect logs each unmet expectation
func (m *GoGitRepositoryMock) MinimockCreateTagInspect() {
	for _, e := range m.CreateTagMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GoGitRepositoryMock.CreateTag with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateTagMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateTagCounter) < 1 {
		if m.CreateTagMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GoGitRepositoryMock.CreateTag")
		} else {
			m.t.Errorf("Expected call to GoGitRepositoryMock.CreateTag with params: %#v", *m.CreateTagMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateTag != nil && mm_atomic.LoadUint64(&m.afterCreateTagCounter) < 1 {
		m.t.Error("Expected call to GoGitRepositoryMock.CreateTag")
	}
}

type mGoGitRepositoryMockDeleteBranch struct {
	mock               *GoGitRepositoryMock
	defaultExpectation *GoGitRepositoryMockDeleteBranchExpectation
	expectations       []*GoGitRepositoryMockDeleteBranchExpectation

	callArgs []*GoGitRepositoryMockDeleteBranchParams
	mutex    sync.RWMutex
}

// GoGitRepositoryMockDeleteBranchExpectation specifies expectation struct of the GoGitRepository.DeleteBranch
type GoGitRepositoryMockDeleteBranchExpectation struct {
	mock    *GoGitRepositoryMock
	params  *GoGitRepositoryMockDeleteBranchParams
	results *GoGitRepositoryMockDeleteBranchResults
	Counter uint64
}

// GoGitRepositoryMockDeleteBranchParams contains parameters of the GoGitRepository.DeleteBranch
type GoGitRepositoryMockDeleteBranchParams struct {
	name string
}

// GoGitRepositoryMockDeleteBranchResults contains results of the GoGitRepository.DeleteBranch
type GoGitRepositoryMockDeleteBranchResults struct {
	err error
}

// Expect sets up expected params for GoGitRepository.DeleteBranch
func (mmDeleteBranch *mGoGitRepositoryMockDeleteBranch) Expect(name string) *mGoGitRepositoryMockDeleteBranch {
	if mmDeleteBranch.mock.funcDeleteBranch != nil {
		mmDeleteBranch.mock.t.Fatalf("GoGitRepositoryMock.DeleteBranch mock is already set by Set")
	}

	if mmDeleteBranch.defaultExpectation == nil {
		mmDeleteBranch.defaultExpectation = &GoGitRepositoryMockDeleteBranchExpectation{}
	}

	mmDeleteBranch.defaultExpectation.params = &GoGitRepositoryMockDeleteBranchParams{name}
	for _, e := range mmDeleteBranch.expectations {
		if minimock.Equal(e.params, mmDeleteBranch.defaultExpectation.params) {
			mmDeleteBranch.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteBranch.defaultExpectation.params)
		}
	}

	return mmDeleteBranch
}

// Inspect accepts an inspector function that has same arguments as the GoGitRepository.DeleteBranch
func (mmDeleteBranch *mGoGitRepositoryMockDeleteBranch) Inspect(f func(name string)) *mGoGitRepositoryMockDeleteBranch {
	if mmDeleteBranch.mock.inspectFuncDeleteBranch != nil {
		mmDeleteBranch.mock.t.Fatalf("Inspect function is already set for GoGitRepositoryMock.DeleteBranch")
	}

	mmDeleteBranch.mock.inspectFuncDeleteBranch = f

	return mmDeleteBranch
}

// Return sets up results that will be returned by GoGitRepository.DeleteBranch
func (mmDeleteBranch *mGoGitRepositoryMockDeleteBranch) Return(err error) *GoGitRepositoryMock {
	if mmDeleteBranch.mock.funcDeleteBranch != nil {
		mmDeleteBranch.mock.t.Fatalf("GoGitRepositoryMock.DeleteBranch mock is already set by Set")
	}

	if mmDeleteBranch.defaultExpectation == nil {
		mmDeleteBranch.defaultExpectation = &GoGitRepositoryMockDeleteBranchExpectation{mock: mmDeleteBranch.mock}
	}
	mmDeleteBranch.defaultExpectation.results = &GoGitRepositoryMockDeleteBranchResults{err}
	return mmDeleteBranch.mock
}

// Set uses given function f to mock the GoGitRepository.DeleteBranch method
func (mmDeleteBranch *mGoGitRepositoryMockDeleteBranch) Set(f func(name string) (err error)) *GoGitRepositoryMock {
	if mmDeleteBranch.defaultExpectation != nil {
		mmDeleteBranch.mock.t.Fatalf("Default expectation is already set for the GoGitRepository.DeleteBranch method")
	}

	if len(mmDeleteBranch.expectations) > 0 {
		mmDeleteBranch.mock.t.Fatalf("Some expectations are already set for the GoGitRepository.DeleteBranch method")
	}

	mmDeleteBranch.mock.funcDeleteBranch = f
	return mmDeleteBranch.mock
}

// When sets expectation for the GoGitRepository.DeleteBranch which will trigger the result defined by the following
// Then helper
func (mmDeleteBranch *mGoGitRepositoryMockDeleteBranch) When(name string) *GoGitRepositoryMockDeleteBranchExpectation {
	if mmDeleteBranch.mock.funcDeleteBranch != nil {
		mmDeleteBranch.mock.t.Fatalf("GoGitRepositoryMock.DeleteBranch mock is already set by Set")
	}

	expectation := &GoGitRepositoryMockDeleteBranchExpectation{
		mock:   mmDeleteBranch.mock,
		params: &GoGitRepositoryMockDeleteBranchParams{name},
	}
	mmDeleteBranch.expectations = append(mmDeleteBranch.expectations, expectation)
	return expectation
}

// Then sets up GoGitRepository.DeleteBranch return parameters for the expectation previously defined by the When method
func (e *GoGitRepositoryMockDeleteBranchExpectation) Then(err error) *GoGitRepositoryMock {
	e.results = &GoGitRepositoryMockDeleteBranchResults{err}
	return e.mock
}

// DeleteBranch implements vcs.GoGitRepository
func (mmDeleteBranch *GoGitRepositoryMock) DeleteBranch(name string) (err error) {
	mm_atomic.AddUint64(&mmDeleteBranch.beforeDeleteBranchCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteBranch.afterDeleteBranchCounter, 1)

	if mmDeleteBranch.inspectFuncDeleteBranch != nil {
		mmDeleteBranch.inspectFuncDeleteBranch(name)
	}

	mm_params := &GoGitRepositoryMockDeleteBranchParams{name}

	// Record call args
	mmDeleteBranch.DeleteBranchMock.mutex.Lock()
	mmDeleteBranch.DeleteBranchMock.callArgs = append(mmDeleteBranch.DeleteBranchMock.callArgs, mm_params)
	mmDeleteBranch.DeleteBranchMock.mutex.Unlock()

	for _, e := range mmDeleteBranch.DeleteBranchMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteBranch.DeleteBranchMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteBranch.DeleteBranchMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteBranch.DeleteBranchMock.defaultExpectation.params
		mm_got := GoGitRepositoryMockDeleteBranchParams{name}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteBranch.t.Errorf("GoGitRepositoryMock.DeleteBranch got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteBranch.DeleteBranchMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteBranch.t.Fatal("No results are set for the GoGitRepositoryMock.DeleteBranch")
		}
		return (*mm_results).err
	}
	if mmDeleteBranch.funcDeleteBranch != nil {
		return mmDeleteBranch.funcDeleteBranch(name)
	}
	mmDeleteBranch.t.Fatalf("Unexpected call to GoGitRepositoryMock.DeleteBranch. %v", name)
	return
}

// DeleteBranchAfterCounter returns a count of finished GoGitRepositoryMock.DeleteBranch invocations
func (mmDeleteBranch *GoGitRepositoryMock) DeleteBranchAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteBranch.afterDeleteBranchCounter)
}

// DeleteBranchBeforeCounter returns a count of GoGitRepositoryMock.DeleteBranch invocations
func (mmDeleteBranch *GoGitRepositoryMock) DeleteBranchBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteBranch.beforeDeleteBranchCounter)
}

// Calls returns a list of arguments used in each call to GoGitRepositoryMock.DeleteBranch.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteBranch *mGoGitRepositoryMockDeleteBranch) Calls() []*GoGitRepositoryMockDeleteBranchParams {
	mmDeleteBranch.mutex.RLock()

	argCopy := make([]*GoGitRepositoryMockDeleteBranchParams, len(mmDeleteBranch.callArgs))
	copy(argCopy, mmDeleteBranch.callArgs)

	mmDeleteBranch.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteBranchDone returns true if the count of the DeleteBranch invocations corresponds
// the number of defined expectations
func (m *GoGitRepositoryMock) MinimockDeleteBranchDone() bool {
	for _, e := range m.DeleteBranchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteBranchMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteBranchCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteBranch != nil && mm_atomic.LoadUint64(&m.afterDeleteBranchCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteBranchInspect logs each unmet expectation
func (m *GoGitRepositoryMock) MinimockDeleteBranchInspect() {
	for _, e := range m.DeleteBranchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GoGitRepositoryMock.DeleteBranch with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteBranchMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteBranchCounter) < 1 {
		if m.DeleteBranchMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GoGitRepositoryMock.DeleteBranch")
		} else {
			m.t.Errorf("Expected call to GoGitRepositoryMock.DeleteBranch with params: %#v", *m.DeleteBranchMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteBranch != nil && mm_atomic.LoadUint64(&m.afterDeleteBranchCounter) < 1 {
		m.t.Error("Expected call to GoGitRepositoryMock.DeleteBranch")
	}
}

type mGoGitRepositoryMockDeleteObject struct {
	mock               *GoGitRepositoryMock
	defaultExpectation *GoGitRepositoryMockDeleteObjectExpectation
	expectations       []*GoGitRepositoryMockDeleteObjectExpectation

	callArgs []*GoGitRepositoryMockDeleteObjectParams
	mutex    sync.RWMutex
}

// GoGitRepositoryMockDeleteObjectExpectation specifies expectation struct of the GoGitRepository.DeleteObject
type GoGitRepositoryMockDeleteObjectExpectation struct {
	mock    *GoGitRepositoryMock
	params  *GoGitRepositoryMockDeleteObjectParams
	results *GoGitRepositoryMockDeleteObjectResults
	Counter uint64
}

// GoGitRepositoryMockDeleteObjectParams contains parameters of the GoGitRepository.DeleteObject
type GoGitRepositoryMockDeleteObjectParams struct {
	hash plumbing.Hash
}

// GoGitRepositoryMockDeleteObjectResults contains results of the GoGitRepository.DeleteObject
type GoGitRepositoryMockDeleteObjectResults struct {
	err error
}

// Expect sets up expected params for GoGitRepository.DeleteObject
func (mmDeleteObject *mGoGitRepositoryMockDeleteObject) Expect(hash plumbing.Hash) *mGoGitRepositoryMockDeleteObject {
	if mmDeleteObject.mock.funcDeleteObject != nil {
		mmDeleteObject.mock.t.Fatalf("GoGitRepositoryMock.DeleteObject mock is already set by Set")
	}

	if mmDeleteObject.defaultExpectation == nil {
		mmDeleteObject.defaultExpectation = &GoGitRepositoryMockDeleteObjectExpectation{}
	}

	mmDeleteObject.defaultExpectation.params = &GoGitRepositoryMockDeleteObjectParams{hash}
	for _, e := range mmDeleteObject.expectations {
		if minimock.Equal(e.params, mmDeleteObject.defaultExpectation.params) {
			mmDeleteObject.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteObject.defaultExpectation.params)
		}
	}

	return mmDeleteObject
}

// Inspect accepts an inspector function that has same arguments as the GoGitRepository.DeleteObject
func (mmDeleteObject *mGoGitRepositoryMockDeleteObject) Inspect(f func(hash plumbing.Hash)) *mGoGitRepositoryMockDeleteObject {
	if mmDeleteObject.mock.inspectFuncDeleteObject != nil {
		mmDeleteObject.mock.t.Fatalf("Inspect function is already set for GoGitRepositoryMock.DeleteObject")
	}

	mmDeleteObject.mock.inspectFuncDeleteObject = f

	return mmDeleteObject
}

// Return sets up results that will be returned by GoGitRepository.DeleteObject
func (mmDeleteObject *mGoGitRepositoryMockDeleteObject) Return(err error) *GoGitRepositoryMock {
	if mmDeleteObject.mock.funcDeleteObject != nil {
		mmDeleteObject.mock.t.Fatalf("GoGitRepositoryMock.DeleteObject mock is already set by Set")
	}

	if mmDeleteObject.defaultExpectation == nil {
		mmDeleteObject.defaultExpectation = &GoGitRepositoryMockDeleteObjectExpectation{mock: mmDeleteObject.mock}
	}
	mmDeleteObject.defaultExpectation.results = &GoGitRepositoryMockDeleteObjectResults{err}
	return mmDeleteObject.mock
}

// Set uses given function f to mock the GoGitRepository.DeleteObject method
func (mmDeleteObject *mGoGitRepositoryMockDeleteObject) Set(f func(hash plumbing.Hash) (err error)) *GoGitRepositoryMock {
	if mmDeleteObject.defaultExpectation != nil {
		mmDeleteObject.mock.t.Fatalf("Default expectation is already set for the GoGitRepository.DeleteObject method")
	}

	if len(mmDeleteObject.expectations) > 0 {
		mmDeleteObject.mock.t.Fatalf("Some expectations are already set for the GoGitRepository.DeleteObject method")
	}

	mmDeleteObject.mock.funcDeleteObject = f
	return mmDeleteObject.mock
}

// When sets expectation for the GoGitRepository.DeleteObject which will trigger the result defined by the following
// Then helper
func (mmDeleteObject *mGoGitRepositoryMockDeleteObject) When(hash plumbing.Hash) *GoGitRepositoryMockDeleteObjectExpectation {
	if mmDeleteObject.mock.funcDeleteObject != nil {
		mmDeleteObject.mock.t.Fatalf("GoGitRepositoryMock.DeleteObject mock is already set by Set")
	}

	expectation := &GoGitRepositoryMockDeleteObjectExpectation{
		mock:   mmDeleteObject.mock,
		params: &GoGitRepositoryMockDeleteObjectParams{hash},
	}
	mmDeleteObject.expectations = append(mmDeleteObject.expectations, expectation)
	return expectation
}

// Then sets up GoGitRepository.DeleteObject return parameters for the expectation previously defined by the When method
func (e *GoGitRepositoryMockDeleteObjectExpectation) Then(err error) *GoGitRepositoryMock {
	e.results = &GoGitRepositoryMockDeleteObjectResults{err}
	return e.mock
}

// DeleteObject implements vcs.GoGitRepository
func (mmDeleteObject *GoGitRepositoryMock) DeleteObject(hash plumbing.Hash) (err error) {
	mm_atomic.AddUint64(&mmDeleteObject.beforeDeleteObjectCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteObject.afterDeleteObjectCounter, 1)

	if mmDeleteObject.inspectFuncDeleteObject != nil {
		mmDeleteObject.inspectFuncDeleteObject(hash)
	}

	mm_params := &GoGitRepositoryMockDeleteObjectParams{hash}

	// Record call args
	mmDeleteObject.DeleteObjectMock.mutex.Lock()
	mmDeleteObject.DeleteObjectMock.callArgs = append(mmDeleteObject.DeleteObjectMock.callArgs, mm_params)
	mmDeleteObject.DeleteObjectMock.mutex.Unlock()

	for _, e := range mmDeleteObject.DeleteObjectMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteObject.DeleteObjectMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteObject.DeleteObjectMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteObject.DeleteObjectMock.defaultExpectation.params
		mm_got := GoGitRepositoryMockDeleteObjectParams{hash}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteObject.t.Errorf("GoGitRepositoryMock.DeleteObject got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteObject.DeleteObjectMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteObject.t.Fatal("No results are set for the GoGitRepositoryMock.DeleteObject")
		}
		return (*mm_results).err
	}
	if mmDeleteObject.funcDeleteObject != nil {
		return mmDeleteObject.funcDeleteObject(hash)
	}
	mmDeleteObject.t.Fatalf("Unexpected call to GoGitRepositoryMock.DeleteObject. %v", hash)
	return
}

// DeleteObjectAfterCounter returns a count of finished GoGitRepositoryMock.DeleteObject invocations
func (mmDeleteObject *GoGitRepositoryMock) DeleteObjectAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteObject.afterDeleteObjectCounter)
}

// DeleteObjectBeforeCounter returns a count of GoGitRepositoryMock.DeleteObject invocations
func (mmDeleteObject *GoGitRepositoryMock) DeleteObjectBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteObject.beforeDeleteObjectCounter)
}

// Calls returns a list of arguments used in each call to GoGitRepositoryMock.DeleteObject.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteObject *mGoGitRepositoryMockDeleteObject) Calls() []*GoGitRepositoryMockDeleteObjectParams {
	mmDeleteObject.mutex.RLock()

	argCopy := make([]*GoGitRepositoryMockDeleteObjectParams, len(mmDeleteObject.callArgs))
	copy(argCopy, mmDeleteObject.callArgs)

	mmDeleteObject.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteObjectDone returns true if the count of the DeleteObject invocations corresponds
// the number of defined expectations
func (m *GoGitRepositoryMock) MinimockDeleteObjectDone() bool {
	for _, e := range m.DeleteObjectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteObjectMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteObjectCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteObject != nil && mm_atomic.LoadUint64(&m.afterDeleteObjectCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteObjectInspect logs each unmet expectation
func (m *GoGitRepositoryMock) MinimockDeleteObjectInspect() {
	for _, e := range m.DeleteObjectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GoGitRepositoryMock.DeleteObject with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteObjectMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteObjectCounter) < 1 {
		if m.DeleteObjectMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GoGitRepositoryMock.DeleteObject")
		} else {
			m.t.Errorf("Expected call to GoGitRepositoryMock.DeleteObject with params: %#v", *m.DeleteObjectMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteObject != nil && mm_atomic.LoadUint64(&m.afterDeleteObjectCounter) < 1 {
		m.t.Error("Expected call to GoGitRepositoryMock.DeleteObject")
	}
}

type mGoGitRepositoryMockDeleteRemote struct {
	mock               *GoGitRepositoryMock
	defaultExpectation *GoGitRepositoryMockDeleteRemoteExpectation
	expectations       []*GoGitRepositoryMockDeleteRemoteExpectation

	callArgs []*GoGitRepositoryMockDeleteRemoteParams
	mutex    sync.RWMutex
}

// GoGitRepositoryMockDeleteRemoteExpectation specifies expectation struct of the GoGitRepository.DeleteRemote
type GoGitRepositoryMockDeleteRemoteExpectation struct {
	mock    *GoGitRepositoryMock
	params  *GoGitRepositoryMockDeleteRemoteParams
	results *GoGitRepositoryMockDeleteRemoteResults
	Counter uint64
}

// GoGitRepositoryMockDeleteRemoteParams contains parameters of the GoGitRepository.DeleteRemote
type GoGitRepositoryMockDeleteRemoteParams struct {
	name string
}

// GoGitRepositoryMockDeleteRemoteResults contains results of the GoGitRepository.DeleteRemote
type GoGitRepositoryMockDeleteRemoteResults struct {
	err error
}

// Expect sets up expected params for GoGitRepository.DeleteRemote
func (mmDeleteRemote *mGoGitRepositoryMockDeleteRemote) Expect(name string) *mGoGitRepositoryMockDeleteRemote {
	if mmDeleteRemote.mock.funcDeleteRemote != nil {
		mmDeleteRemote.mock.t.Fatalf("GoGitRepositoryMock.DeleteRemote mock is already set by Set")
	}

	if mmDeleteRemote.defaultExpectation == nil {
		mmDeleteRemote.defaultExpectation = &GoGitRepositoryMockDeleteRemoteExpectation{}
	}

	mmDeleteRemote.defaultExpectation.params = &GoGitRepositoryMockDeleteRemoteParams{name}
	for _, e := range mmDeleteRemote.expectations {
		if minimock.Equal(e.params, mmDeleteRemote.defaultExpectation.params) {
			mmDeleteRemote.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteRemote.defaultExpectation.params)
		}
	}

	return mmDeleteRemote
}

// Inspect accepts an inspector function that has same arguments as the GoGitRepository.DeleteRemote
func (mmDeleteRemote *mGoGitRepositoryMockDeleteRemote) Inspect(f func(name string)) *mGoGitRepositoryMockDeleteRemote {
	if mmDeleteRemote.mock.inspectFuncDeleteRemote != nil {
		mmDeleteRemote.mock.t.Fatalf("Inspect function is already set for GoGitRepositoryMock.DeleteRemote")
	}

	mmDeleteRemote.mock.inspectFuncDeleteRemote = f

	return mmDeleteRemote
}

// Return sets up results that will be returned by GoGitRepository.DeleteRemote
func (mmDeleteRemote *mGoGitRepositoryMockDeleteRemote) Return(err error) *GoGitRepositoryMock {
	if mmDeleteRemote.mock.funcDeleteRemote != nil {
		mmDeleteRemote.mock.t.Fatalf("GoGitRepositoryMock.DeleteRemote mock is already set by Set")
	}

	if mmDeleteRemote.defaultExpectation == nil {
		mmDeleteRemote.defaultExpectation = &GoGitRepositoryMockDeleteRemoteExpectation{mock: mmDeleteRemote.mock}
	}
	mmDeleteRemote.defaultExpectation.results = &GoGitRepositoryMockDeleteRemoteResults{err}
	return mmDeleteRemote.mock
}

// Set uses given function f to mock the GoGitRepository.DeleteRemote method
func (mmDeleteRemote *mGoGitRepositoryMockDeleteRemote) Set(f func(name string) (err error)) *GoGitRepositoryMock {
	if mmDeleteRemote.defaultExpectation != nil {
		mmDeleteRemote.mock.t.Fatalf("Default expectation is already set for the GoGitRepository.DeleteRemote method")
	}

	if len(mmDeleteRemote.expectations) > 0 {
		mmDeleteRemote.mock.t.Fatalf("Some expectations are already set for the GoGitRepository.DeleteRemote method")
	}

	mmDeleteRemote.mock.funcDeleteRemote = f
	return mmDeleteRemote.mock
}

// When sets expectation for the GoGitRepository.DeleteRemote which will trigger the result defined by the following
// Then helper
func (mmDeleteRemote *mGoGitRepositoryMockDeleteRemote) When(name string) *GoGitRepositoryMockDeleteRemoteExpectation {
	if mmDeleteRemote.mock.funcDeleteRemote != nil {
		mmDeleteRemote.mock.t.Fatalf("GoGitRepositoryMock.DeleteRemote mock is already set by Set")
	}

	expectation := &GoGitRepositoryMockDeleteRemoteExpectation{
		mock:   mmDeleteRemote.mock,
		params: &GoGitRepositoryMockDeleteRemoteParams{name},
	}
	mmDeleteRemote.expectations = append(mmDeleteRemote.expectations, expectation)
	return expectation
}

// Then sets up GoGitRepository.DeleteRemote return parameters for the expectation previously defined by the When method
func (e *GoGitRepositoryMockDeleteRemoteExpectation) Then(err error) *GoGitRepositoryMock {
	e.results = &GoGitRepositoryMockDeleteRemoteResults{err}
	return e.mock
}

// DeleteRemote implements vcs.GoGitRepository
func (mmDeleteRemote *GoGitRepositoryMock) DeleteRemote(name string) (err error) {
	mm_atomic.AddUint64(&mmDeleteRemote.beforeDeleteRemoteCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteRemote.afterDeleteRemoteCounter, 1)

	if mmDeleteRemote.inspectFuncDeleteRemote != nil {
		mmDeleteRemote.inspectFuncDeleteRemote(name)
	}

	mm_params := &GoGitRepositoryMockDeleteRemoteParams{name}

	// Record call args
	mmDeleteRemote.DeleteRemoteMock.mutex.Lock()
	mmDeleteRemote.DeleteRemoteMock.callArgs = append(mmDeleteRemote.DeleteRemoteMock.callArgs, mm_params)
	mmDeleteRemote.DeleteRemoteMock.mutex.Unlock()

	for _, e := range mmDeleteRemote.DeleteRemoteMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteRemote.DeleteRemoteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteRemote.DeleteRemoteMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteRemote.DeleteRemoteMock.defaultExpectation.params
		mm_got := GoGitRepositoryMockDeleteRemoteParams{name}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteRemote.t.Errorf("GoGitRepositoryMock.DeleteRemote got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteRemote.DeleteRemoteMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteRemote.t.Fatal("No results are set for the GoGitRepositoryMock.DeleteRemote")
		}
		return (*mm_results).err
	}
	if mmDeleteRemote.funcDeleteRemote != nil {
		return mmDeleteRemote.funcDeleteRemote(name)
	}
	mmDeleteRemote.t.Fatalf("Unexpected call to GoGitRepositoryMock.DeleteRemote. %v", name)
	return
}

// DeleteRemoteAfterCounter returns a count of finished GoGitRepositoryMock.DeleteRemote invocations
func (mmDeleteRemote *GoGitRepositoryMock) DeleteRemoteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteRemote.afterDeleteRemoteCounter)
}

// DeleteRemoteBeforeCounter returns a count of GoGitRepositoryMock.DeleteRemote invocations
func (mmDeleteRemote *GoGitRepositoryMock) DeleteRemoteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteRemote.beforeDeleteRemoteCounter)
}

// Calls returns a list of arguments used in each call to GoGitRepositoryMock.DeleteRemote.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteRemote *mGoGitRepositoryMockDeleteRemote) Calls() []*GoGitRepositoryMockDeleteRemoteParams {
	mmDeleteRemote.mutex.RLock()

	argCopy := make([]*GoGitRepositoryMockDeleteRemoteParams, len(mmDeleteRemote.callArgs))
	copy(argCopy, mmDeleteRemote.callArgs)

	mmDeleteRemote.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteRemoteDone returns true if the count of the DeleteRemote invocations corresponds
// the number of defined expectations
func (m *GoGitRepositoryMock) MinimockDeleteRemoteDone() bool {
	for _, e := range m.DeleteRemoteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteRemoteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteRemoteCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteRemote != nil && mm_atomic.LoadUint64(&m.afterDeleteRemoteCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteRemoteInspect logs each unmet expectation
func (m *GoGitRepositoryMock) MinimockDeleteRemoteInspect() {
	for _, e := range m.DeleteRemoteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GoGitRepositoryMock.DeleteRemote with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteRemoteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteRemoteCounter) < 1 {
		if m.DeleteRemoteMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GoGitRepositoryMock.DeleteRemote")
		} else {
			m.t.Errorf("Expected call to GoGitRepositoryMock.DeleteRemote with params: %#v", *m.DeleteRemoteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteRemote != nil && mm_atomic.LoadUint64(&m.afterDeleteRemoteCounter) < 1 {
		m.t.Error("Expected call to GoGitRepositoryMock.DeleteRemote")
	}
}

type mGoGitRepositoryMockDeleteTag struct {
	mock               *GoGitRepositoryMock
	defaultExpectation *GoGitRepositoryMockDeleteTagExpectation
	expectations       []*GoGitRepositoryMockDeleteTagExpectation

	callArgs []*GoGitRepositoryMockDeleteTagParams
	mutex    sync.RWMutex
}

// GoGitRepositoryMockDeleteTagExpectation specifies expectation struct of the GoGitRepository.DeleteTag
type GoGitRepositoryMockDeleteTagExpectation struct {
	mock    *GoGitRepositoryMock
	params  *GoGitRepositoryMockDeleteTagParams
	results *GoGitRepositoryMockDeleteTagResults
	Counter uint64
}

// GoGitRepositoryMockDeleteTagParams contains parameters of the GoGitRepository.DeleteTag
type GoGitRepositoryMockDeleteTagParams struct {
	name string
}

// GoGitRepositoryMockDeleteTagResults contains results of the GoGitRepository.DeleteTag
type GoGitRepositoryMockDeleteTagResults struct {
	err error
}

// Expect sets up expected params for GoGitRepository.DeleteTag
func (mmDeleteTag *mGoGitRepositoryMockDeleteTag) Expect(name string) *mGoGitRepositoryMockDeleteTag {
	if mmDeleteTag.mock.funcDeleteTag != nil {
		mmDeleteTag.mock.t.Fatalf("GoGitRepositoryMock.DeleteTag mock is already set by Set")
	}

	if mmDeleteTag.defaultExpectation == nil {
		mmDeleteTag.defaultExpectation = &GoGitRepositoryMockDeleteTagExpectation{}
	}

	mmDeleteTag.defaultExpectation.params = &GoGitRepositoryMockDeleteTagParams{name}
	for _, e := range mmDeleteTag.expectations {
		if minimock.Equal(e.params, mmDeleteTag.defaultExpectation.params) {
			mmDeleteTag.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteTag.defaultExpectation.params)
		}
	}

	return mmDeleteTag
}

// Inspect accepts an inspector function that has same arguments as the GoGitRepository.DeleteTag
func (mmDeleteTag *mGoGitRepositoryMockDeleteTag) Inspect(f func(name string)) *mGoGitRepositoryMockDeleteTag {
	if mmDeleteTag.mock.inspectFuncDeleteTag != nil {
		mmDeleteTag.mock.t.Fatalf("Inspect function is already set for GoGitRepositoryMock.DeleteTag")
	}

	mmDeleteTag.mock.inspectFuncDeleteTag = f

	return mmDeleteTag
}

// Return sets up results that will be returned by GoGitRepository.DeleteTag
func (mmDeleteTag *mGoGitRepositoryMockDeleteTag) Return(err error) *GoGitRepositoryMock {
	if mmDeleteTag.mock.funcDeleteTag != nil {
		mmDeleteTag.mock.t.Fatalf("GoGitRepositoryMock.DeleteTag mock is already set by Set")
	}

	if mmDeleteTag.defaultExpectation == nil {
		mmDeleteTag.defaultExpectation = &GoGitRepositoryMockDeleteTagExpectation{mock: mmDeleteTag.mock}
	}
	mmDeleteTag.defaultExpectation.results = &GoGitRepositoryMockDeleteTagResults{err}
	return mmDeleteTag.mock
}

// Set uses given function f to mock the GoGitRepository.DeleteTag method
func (mmDeleteTag *mGoGitRepositoryMockDeleteTag) Set(f func(name string) (err error)) *GoGitRepositoryMock {
	if mmDeleteTag.defaultExpectation != nil {
		mmDeleteTag.mock.t.Fatalf("Default expectation is already set for the GoGitRepository.DeleteTag method")
	}

	if len(mmDeleteTag.expectations) > 0 {
		mmDeleteTag.mock.t.Fatalf("Some expectations are already set for the GoGitRepository.DeleteTag method")
	}

	mmDeleteTag.mock.funcDeleteTag = f
	return mmDeleteTag.mock
}

// When sets expectation for the GoGitRepository.DeleteTag which will trigger the result defined by the following
// Then helper
func (mmDeleteTag *mGoGitRepositoryMockDeleteTag) When(name string) *GoGitRepositoryMockDeleteTagExpectation {
	if mmDeleteTag.mock.funcDeleteTag != nil {
		mmDeleteTag.mock.t.Fatalf("GoGitRepositoryMock.DeleteTag mock is already set by Set")
	}

	expectation := &GoGitRepositoryMockDeleteTagExpectation{
		mock:   mmDeleteTag.mock,
		params: &GoGitRepositoryMockDeleteTagParams{name},
	}
	mmDeleteTag.expectations = append(mmDeleteTag.expectations, expectation)
	return expectation
}

// Then sets up GoGitRepository.DeleteTag return parameters for the expectation previously defined by the When method
func (e *GoGitRepositoryMockDeleteTagExpectation) Then(err error) *GoGitRepositoryMock {
	e.results = &GoGitRepositoryMockDeleteTagResults{err}
	return e.mock
}

// DeleteTag implements vcs.GoGitRepository
func (mmDeleteTag *GoGitRepositoryMock) DeleteTag(name string) (err error) {
	mm_atomic.AddUint64(&mmDeleteTag.beforeDeleteTagCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteTag.afterDeleteTagCounter, 1)

	if mmDeleteTag.inspectFuncDeleteTag != nil {
		mmDeleteTag.inspectFuncDeleteTag(name)
	}

	mm_params := &GoGitRepositoryMockDeleteTagParams{name}

	// Record call args
	mmDeleteTag.DeleteTagMock.mutex.Lock()
	mmDeleteTag.DeleteTagMock.callArgs = append(mmDeleteTag.DeleteTagMock.callArgs, mm_params)
	mmDeleteTag.DeleteTagMock.mutex.Unlock()

	for _, e := range mmDeleteTag.DeleteTagMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteTag.DeleteTagMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteTag.DeleteTagMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteTag.DeleteTagMock.defaultExpectation.params
		mm_got := GoGitRepositoryMockDeleteTagParams{name}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteTag.t.Errorf("GoGitRepositoryMock.DeleteTag got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteTag.DeleteTagMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteTag.t.Fatal("No results are set for the GoGitRepositoryMock.DeleteTag")
		}
		return (*mm_results).err
	}
	if mmDeleteTag.funcDeleteTag != nil {
		return mmDeleteTag.funcDeleteTag(name)
	}
	mmDeleteTag.t.Fatalf("Unexpected call to GoGitRepositoryMock.DeleteTag. %v", name)
	return
}

// DeleteTagAfterCounter returns a count of finished GoGitRepositoryMock.DeleteTag invocations
func (mmDeleteTag *GoGitRepositoryMock) DeleteTagAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteTag.afterDeleteTagCounter)
}

// DeleteTagBeforeCounter returns a count of GoGitRepositoryMock.DeleteTag invocations
func (mmDeleteTag *GoGitRepositoryMock) DeleteTagBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteTag.beforeDeleteTagCounter)
}

// Calls returns a list of arguments used in each call to GoGitRepositoryMock.DeleteTag.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteTag *mGoGitRepositoryMockDeleteTag) Calls() []*GoGitRepositoryMockDeleteTagParams {
	mmDeleteTag.mutex.RLock()

	argCopy := make([]*GoGitRepositoryMockDeleteTagParams, len(mmDeleteTag.callArgs))
	copy(argCopy, mmDeleteTag.callArgs)

	mmDeleteTag.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteTagDone returns true if the count of the DeleteTag invocations corresponds
// the number of defined expectations
func (m *GoGitRepositoryMock) MinimockDeleteTagDone() bool {
	for _, e := range m.DeleteTagMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteTagMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteTagCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteTag != nil && mm_atomic.LoadUint64(&m.afterDeleteTagCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteTagInspect logs each unmet expectation
func (m *GoGitRepositoryMock) MinimockDeleteTagInspect() {
	for _, e := range m.DeleteTagMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GoGitRepositoryMock.DeleteTag with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteTagMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteTagCounter) < 1 {
		if m.DeleteTagMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GoGitRepositoryMock.DeleteTag")
		} else {
			m.t.Errorf("Expected call to GoGitRepositoryMock.DeleteTag with params: %#v", *m.DeleteTagMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteTag != nil && mm_atomic.LoadUint64(&m.afterDeleteTagCounter) < 1 {
		m.t.Error("Expected call to GoGitRepositoryMock.DeleteTag")
	}
}

type mGoGitRepositoryMockFetch struct {
	mock               *GoGitRepositoryMock
	defaultExpectation *GoGitRepositoryMockFetchExpectation
	expectations       []*GoGitRepositoryMockFetchExpectation

	callArgs []*GoGitRepositoryMockFetchParams
	mutex    sync.RWMutex
}

// GoGitRepositoryMockFetchExpectation specifies expectation struct of the GoGitRepository.Fetch
type GoGitRepositoryMockFetchExpectation struct {
	mock    *GoGitRepositoryMock
	params  *GoGitRepositoryMockFetchParams
	results *GoGitRepositoryMockFetchResults
	Counter uint64
}

// GoGitRepositoryMockFetchParams contains parameters of the GoGitRepository.Fetch
type GoGitRepositoryMockFetchParams struct {
	o *git.FetchOptions
}

// GoGitRepositoryMockFetchResults contains results of the GoGitRepository.Fetch
type GoGitRepositoryMockFetchResults struct {
	err error
}

// Expect sets up expected params for GoGitRepository.Fetch
func (mmFetch *mGoGitRepositoryMockFetch) Expect(o *git.FetchOptions) *mGoGitRepositoryMockFetch {
	if mmFetch.mock.funcFetch != nil {
		mmFetch.mock.t.Fatalf("GoGitRepositoryMock.Fetch mock is already set by Set")
	}

	if mmFetch.defaultExpectation == nil {
		mmFetch.defaultExpectation = &GoGitRepositoryMockFetchExpectation{}
	}

	mmFetch.defaultExpectation.params = &GoGitRepositoryMockFetchParams{o}
	for _, e := range mmFetch.expectations {
		if minimock.Equal(e.params, mmFetch.defaultExpectation.params) {
			mmFetch.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFetch.defaultExpectation.params)
		}
	}

	return mmFetch
}

// Inspect accepts an inspector function that has same arguments as the GoGitRepository.Fetch
func (mmFetch *mGoGitRepositoryMockFetch) Inspect(f func(o *git.FetchOptions)) *mGoGitRepositoryMockFetch {
	if mmFetch.mock.inspectFuncFetch != nil {
		mmFetch.mock.t.Fatalf("Inspect function is already set for GoGitRepositoryMock.Fetch")
	}

	mmFetch.mock.inspectFuncFetch = f

	return mmFetch
}

// Return sets up results that will be returned by GoGitRepository.Fetch
func (mmFetch *mGoGitRepositoryMockFetch) Return(err error) *GoGitRepositoryMock {
	if mmFetch.mock.funcFetch != nil {
		mmFetch.mock.t.Fatalf("GoGitRepositoryMock.Fetch mock is already set by Set")
	}

	if mmFetch.defaultExpectation == nil {
		mmFetch.defaultExpectation = &GoGitRepositoryMockFetchExpectation{mock: mmFetch.mock}
	}
	mmFetch.defaultExpectation.results = &GoGitRepositoryMockFetchResults{err}
	return mmFetch.mock
}

// Set uses given function f to mock the GoGitRepository.Fetch method
func (mmFetch *mGoGitRepositoryMockFetch) Set(f func(o *git.FetchOptions) (err error)) *GoGitRepositoryMock {
	if mmFetch.defaultExpectation != nil {
		mmFetch.mock.t.Fatalf("Default expectation is already set for the GoGitRepository.Fetch method")
	}

	if len(mmFetch.expectations) > 0 {
		mmFetch.mock.t.Fatalf("Some expectations are already set for the GoGitRepository.Fetch method")
	}

	mmFetch.mock.funcFetch = f
	return mmFetch.mock
}

// When sets expectation for the GoGitRepository.Fetch which will trigger the result defined by the following
// Then helper
func (mmFetch *mGoGitRepositoryMockFetch) When(o *git.FetchOptions) *GoGitRepositoryMockFetchExpectation {
	if mmFetch.mock.funcFetch != nil {
		mmFetch.mock.t.Fatalf("GoGitRepositoryMock.Fetch mock is already set by Set")
	}

	expectation := &GoGitRepositoryMockFetchExpectation{
		mock:   mmFetch.mock,
		params: &GoGitRepositoryMockFetchParams{o},
	}
	mmFetch.expectations = append(mmFetch.expectations, expectation)
	return expectation
}

// Then sets up GoGitRepository.Fetch return parameters for the expectation previously defined by the When method
func (e *GoGitRepositoryMockFetchExpectation) Then(err error) *GoGitRepositoryMock {
	e.results = &GoGitRepositoryMockFetchResults{err}
	return e.mock
}

// Fetch implements vcs.GoGitRepository
func (mmFetch *GoGitRepositoryMock) Fetch(o *git.FetchOptions) (err error) {
	mm_atomic.AddUint64(&mmFetch.beforeFetchCounter, 1)
	defer mm_atomic.AddUint64(&mmFetch.afterFetchCounter, 1)

	if mmFetch.inspectFuncFetch != nil {
		mmFetch.inspectFuncFetch(o)
	}

	mm_params := &GoGitRepositoryMockFetchParams{o}

	// Record call args
	mmFetch.FetchMock.mutex.Lock()
	mmFetch.FetchMock.callArgs = append(mmFetch.FetchMock.callArgs, mm_params)
	mmFetch.FetchMock.mutex.Unlock()

	for _, e := range mmFetch.FetchMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmFetch.FetchMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFetch.FetchMock.defaultExpectation.Counter, 1)
		mm_want := mmFetch.FetchMock.defaultExpectation.params
		mm_got := GoGitRepositoryMockFetchParams{o}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmFetch.t.Errorf("GoGitRepositoryMock.Fetch got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmFetch.FetchMock.defaultExpectation.results
		if mm_results == nil {
			mmFetch.t.Fatal("No results are set for the GoGitRepositoryMock.Fetch")
		}
		return (*mm_results).err
	}
	if mmFetch.funcFetch != nil {
		return mmFetch.funcFetch(o)
	}
	mmFetch.t.Fatalf("Unexpected call to GoGitRepositoryMock.Fetch. %v", o)
	return
}

// FetchAfterCounter returns a count of finished GoGitRepositoryMock.Fetch invocations
func (mmFetch *GoGitRepositoryMock) FetchAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFetch.afterFetchCounter)
}

// FetchBeforeCounter returns a count of GoGitRepositoryMock.Fetch invocations
func (mmFetch *GoGitRepositoryMock) FetchBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFetch.beforeFetchCounter)
}

// Calls returns a list of arguments used in each call to GoGitRepositoryMock.Fetch.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFetch *mGoGitRepositoryMockFetch) Calls() []*GoGitRepositoryMockFetchParams {
	mmFetch.mutex.RLock()

	argCopy := make([]*GoGitRepositoryMockFetchParams, len(mmFetch.callArgs))
	copy(argCopy, mmFetch.callArgs)

	mmFetch.mutex.RUnlock()

	return argCopy
}

// MinimockFetchDone returns true if the count of the Fetch invocations corresponds
// the number of defined expectations
func (m *GoGitRepositoryMock) MinimockFetchDone() bool {
	for _, e := range m.FetchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FetchMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFetchCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFetch != nil && mm_atomic.LoadUint64(&m.afterFetchCounter) < 1 {
		return false
	}
	return true
}

// MinimockFetchInspect logs each unmet expectation
func (m *GoGitRepositoryMock) MinimockFetchInspect() {
	for _, e := range m.FetchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GoGitRepositoryMock.Fetch with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FetchMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFetchCounter) < 1 {
		if m.FetchMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GoGitRepositoryMock.Fetch")
		} else {
			m.t.Errorf("Expected call to GoGitRepositoryMock.Fetch with params: %#v", *m.FetchMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFetch != nil && mm_atomic.LoadUint64(&m.afterFetchCounter) < 1 {
		m.t.Error("Expected call to GoGitRepositoryMock.Fetch")
	}
}

type mGoGitRepositoryMockFetchContext struct {
	mock               *GoGitRepositoryMock
	defaultExpectation *GoGitRepositoryMockFetchContextExpectation
	expectations       []*GoGitRepositoryMockFetchContextExpectation

	callArgs []*GoGitRepositoryMockFetchContextParams
	mutex    sync.RWMutex
}

// GoGitRepositoryMockFetchContextExpectation specifies expectation struct of the GoGitRepository.FetchContext
type GoGitRepositoryMockFetchContextExpectation struct {
	mock    *GoGitRepositoryMock
	params  *GoGitRepositoryMockFetchContextParams
	results *GoGitRepositoryMockFetchContextResults
	Counter uint64
}

// GoGitRepositoryMockFetchContextParams contains parameters of the GoGitRepository.FetchContext
type GoGitRepositoryMockFetchContextParams struct {
	ctx context.Context
	o   *git.FetchOptions
}

// GoGitRepositoryMockFetchContextResults contains results of the GoGitRepository.FetchContext
type GoGitRepositoryMockFetchContextResults struct {
	err error
}

// Expect sets up expected params for GoGitRepository.FetchContext
func (mmFetchContext *mGoGitRepositoryMockFetchContext) Expect(ctx context.Context, o *git.FetchOptions) *mGoGitRepositoryMockFetchContext {
	if mmFetchContext.mock.funcFetchContext != nil {
		mmFetchContext.mock.t.Fatalf("GoGitRepositoryMock.FetchContext mock is already set by Set")
	}

	if mmFetchContext.defaultExpectation == nil {
		mmFetchContext.defaultExpectation = &GoGitRepositoryMockFetchContextExpectation{}
	}

	mmFetchContext.defaultExpectation.params = &GoGitRepositoryMockFetchContextParams{ctx, o}
	for _, e := range mmFetchContext.expectations {
		if minimock.Equal(e.params, mmFetchContext.defaultExpectation.params) {
			mmFetchContext.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFetchContext.defaultExpectation.params)
		}
	}

	return mmFetchContext
}

// Inspect accepts an inspector function that has same arguments as the GoGitRepository.FetchContext
func (mmFetchContext *mGoGitRepositoryMockFetchContext) Inspect(f func(ctx context.Context, o *git.FetchOptions)) *mGoGitRepositoryMockFetchContext {
	if mmFetchContext.mock.inspectFuncFetchContext != nil {
		mmFetchContext.mock.t.Fatalf("Inspect function is already set for GoGitRepositoryMock.FetchContext")
	}

	mmFetchContext.mock.inspectFuncFetchContext = f

	return mmFetchContext
}

// Return sets up results that will be returned by GoGitRepository.FetchContext
func (mmFetchContext *mGoGitRepositoryMockFetchContext) Return(err error) *GoGitRepositoryMock {
	if mmFetchContext.mock.funcFetchContext != nil {
		mmFetchContext.mock.t.Fatalf("GoGitRepositoryMock.FetchContext mock is already set by Set")
	}

	if mmFetchContext.defaultExpectation == nil {
		mmFetchContext.defaultExpectation = &GoGitRepositoryMockFetchContextExpectation{mock: mmFetchContext.mock}
	}
	mmFetchContext.defaultExpectation.results = &GoGitRepositoryMockFetchContextResults{err}
	return mmFetchContext.mock
}

// Set uses given function f to mock the GoGitRepository.FetchContext method
func (mmFetchContext *mGoGitRepositoryMockFetchContext) Set(f func(ctx context.Context, o *git.FetchOptions) (err error)) *GoGitRepositoryMock {
	if mmFetchContext.defaultExpectation != nil {
		mmFetchContext.mock.t.Fatalf("Default expectation is already set for the GoGitRepository.FetchContext method")
	}

	if len(mmFetchContext.expectations) > 0 {
		mmFetchContext.mock.t.Fatalf("Some expectations are already set for the GoGitRepository.FetchContext method")
	}

	mmFetchContext.mock.funcFetchContext = f
	return mmFetchContext.mock
}

// When sets expectation for the GoGitRepository.FetchContext which will trigger the result defined by the following
// Then helper
func (mmFetchContext *mGoGitRepositoryMockFetchContext) When(ctx context.Context, o *git.FetchOptions) *GoGitRepositoryMockFetchContextExpectation {
	if mmFetchContext.mock.funcFetchContext != nil {
		mmFetchContext.mock.t.Fatalf("GoGitRepositoryMock.FetchContext mock is already set by Set")
	}

	expectation := &GoGitRepositoryMockFetchContextExpectation{
		mock:   mmFetchContext.mock,
		params: &GoGitRepositoryMockFetchContextParams{ctx, o},
	}
	mmFetchContext.expectations = append(mmFetchContext.expectations, expectation)
	return expectation
}

// Then sets up GoGitRepository.FetchContext return parameters for the expectation previously defined by the When method
func (e *GoGitRepositoryMockFetchContextExpectation) Then(err error) *GoGitRepositoryMock {
	e.results = &GoGitRepositoryMockFetchContextResults{err}
	return e.mock
}

// FetchContext implements vcs.GoGitRepository
func (mmFetchContext *GoGitRepositoryMock) FetchContext(ctx context.Context, o *git.FetchOptions) (err error) {
	mm_atomic.AddUint64(&mmFetchContext.beforeFetchContextCounter, 1)
	defer mm_atomic.AddUint64(&mmFetchContext.afterFetchContextCounter, 1)

	if mmFetchContext.inspectFuncFetchContext != nil {
		mmFetchContext.inspectFuncFetchContext(ctx, o)
	}

	mm_params := &GoGitRepositoryMockFetchContextParams{ctx, o}

	// Record call args
	mmFetchContext.FetchContextMock.mutex.Lock()
	mmFetchContext.FetchContextMock.callArgs = append(mmFetchContext.FetchContextMock.callArgs, mm_params)
	mmFetchContext.FetchContextMock.mutex.Unlock()

	for _, e := range mmFetchContext.FetchContextMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmFetchContext.FetchContextMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFetchContext.FetchContextMock.defaultExpectation.Counter, 1)
		mm_want := mmFetchContext.FetchContextMock.defaultExpectation.params
		mm_got := GoGitRepositoryMockFetchContextParams{ctx, o}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmFetchContext.t.Errorf("GoGitRepositoryMock.FetchContext got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmFetchContext.FetchContextMock.defaultExpectation.results
		if mm_results == nil {
			mmFetchContext.t.Fatal("No results are set for the GoGitRepositoryMock.FetchContext")
		}
		return (*mm_results).err
	}
	if mmFetchContext.funcFetchContext != nil {
		return mmFetchContext.funcFetchContext(ctx, o)
	}
	mmFetchContext.t.Fatalf("Unexpected call to GoGitRepositoryMock.FetchContext. %v %v", ctx, o)
	return
}

// FetchContextAfterCounter returns a count of finished GoGitRepositoryMock.FetchContext invocations
func (mmFetchContext *GoGitRepositoryMock) FetchContextAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFetchContext.afterFetchContextCounter)
}

// FetchContextBeforeCounter returns a count of GoGitRepositoryMock.FetchContext invocations
func (mmFetchContext *GoGitRepositoryMock) FetchContextBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFetchContext.beforeFetchContextCounter)
}

// Calls returns a list of arguments used in each call to GoGitRepositoryMock.FetchContext.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFetchContext *mGoGitRepositoryMockFetchContext) Calls() []*GoGitRepositoryMockFetchContextParams {
	mmFetchContext.mutex.RLock()

	argCopy := make([]*GoGitRepositoryMockFetchContextParams, len(mmFetchContext.callArgs))
	copy(argCopy, mmFetchContext.callArgs)

	mmFetchContext.mutex.RUnlock()

	return argCopy
}

// MinimockFetchContextDone returns true if the count of the FetchContext invocations corresponds
// the number of defined expectations
func (m *GoGitRepositoryMock) MinimockFetchContextDone() bool {
	for _, e := range m.FetchContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FetchContextMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFetchContextCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFetchContext != nil && mm_atomic.LoadUint64(&m.afterFetchContextCounter) < 1 {
		return false
	}
	return true
}

// MinimockFetchContextInspect logs each unmet expectation
func (m *GoGitRepositoryMock) MinimockFetchContextInspect() {
	for _, e := range m.FetchContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GoGitRepositoryMock.FetchContext with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FetchContextMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFetchContextCounter) < 1 {
		if m.FetchContextMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GoGitRepositoryMock.FetchContext")
		} else {
			m.t.Errorf("Expected call to GoGitRepositoryMock.FetchContext with params: %#v", *m.FetchContextMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFetchContext != nil && mm_atomic.LoadUint64(&m.afterFetchContextCounter) < 1 {
		m.t.Error("Expected call to GoGitRepositoryMock.FetchContext")
	}
}

type mGoGitRepositoryMockHead struct {
	mock               *GoGitRepositoryMock
	defaultExpectation *GoGitRepositoryMockHeadExpectation
	expectations       []*GoGitRepositoryMockHeadExpectation
}

// GoGitRepositoryMockHeadExpectation specifies expectation struct of the GoGitRepository.Head
type GoGitRepositoryMockHeadExpectation struct {
	mock *GoGitRepositoryMock

	results *GoGitRepositoryMockHeadResults
	Counter uint64
}

// GoGitRepositoryMockHeadResults contains results of the GoGitRepository.Head
type GoGitRepositoryMockHeadResults struct {
	rp1 *plumbing.Reference
	err error
}

// Expect sets up expected params for GoGitRepository.Head
func (mmHead *mGoGitRepositoryMockHead) Expect() *mGoGitRepositoryMockHead {
	if mmHead.mock.funcHead != nil {
		mmHead.mock.t.Fatalf("GoGitRepositoryMock.Head mock is already set by Set")
	}

	if mmHead.defaultExpectation == nil {
		mmHead.defaultExpectation = &GoGitRepositoryMockHeadExpectation{}
	}

	return mmHead
}

// Inspect accepts an inspector function that has same arguments as the GoGitRepository.Head
func (mmHead *mGoGitRepositoryMockHead) Inspect(f func()) *mGoGitRepositoryMockHead {
	if mmHead.mock.inspectFuncHead != nil {
		mmHead.mock.t.Fatalf("Inspect function is already set for GoGitRepositoryMock.Head")
	}

	mmHead.mock.inspectFuncHead = f

	return mmHead
}

// Return sets up results that will be returned by GoGitRepository.Head
func (mmHead *mGoGitRepositoryMockHead) Return(rp1 *plumbing.Reference, err error) *GoGitRepositoryMock {
	if mmHead.mock.funcHead != nil {
		mmHead.mock.t.Fatalf("GoGitRepositoryMock.Head mock is already set by Set")
	}

	if mmHead.defaultExpectation == nil {
		mmHead.defaultExpectation = &GoGitRepositoryMockHeadExpectation{mock: mmHead.mock}
	}
	mmHead.defaultExpectation.results = &GoGitRepositoryMockHeadResults{rp1, err}
	return mmHead.mock
}

// Set uses given function f to mock the GoGitRepository.Head method
func (mmHead *mGoGitRepositoryMockHead) Set(f func() (rp1 *plumbing.Reference, err error)) *GoGitRepositoryMock {
	if mmHead.defaultExpectation != nil {
		mmHead.mock.t.Fatalf("Default expectation is already set for the GoGitRepository.Head method")
	}

	if len(mmHead.expectations) > 0 {
		mmHead.mock.t.Fatalf("Some expectations are already set for the GoGitRepository.Head method")
	}

	mmHead.mock.funcHead = f
	return mmHead.mock
}

// Head implements vcs.GoGitRepository
func (mmHead *GoGitRepositoryMock) Head() (rp1 *plumbing.Reference, err error) {
	mm_atomic.AddUint64(&mmHead.beforeHeadCounter, 1)
	defer mm_atomic.AddUint64(&mmHead.afterHeadCounter, 1)

	if mmHead.inspectFuncHead != nil {
		mmHead.inspectFuncHead()
	}

	if mmHead.HeadMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHead.HeadMock.defaultExpectation.Counter, 1)

		mm_results := mmHead.HeadMock.defaultExpectation.results
		if mm_results == nil {
			mmHead.t.Fatal("No results are set for the GoGitRepositoryMock.Head")
		}
		return (*mm_results).rp1, (*mm_results).err
	}
	if mmHead.funcHead != nil {
		return mmHead.funcHead()
	}
	mmHead.t.Fatalf("Unexpected call to GoGitRepositoryMock.Head.")
	return
}

// HeadAfterCounter returns a count of finished GoGitRepositoryMock.Head invocations
func (mmHead *GoGitRepositoryMock) HeadAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHead.afterHeadCounter)
}

// HeadBeforeCounter returns a count of GoGitRepositoryMock.Head invocations
func (mmHead *GoGitRepositoryMock) HeadBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHead.beforeHeadCounter)
}

// MinimockHeadDone returns true if the count of the Head invocations corresponds
// the number of defined expectations
func (m *GoGitRepositoryMock) MinimockHeadDone() bool {
	for _, e := range m.HeadMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.HeadMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterHeadCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHead != nil && mm_atomic.LoadUint64(&m.afterHeadCounter) < 1 {
		return false
	}
	return true
}

// MinimockHeadInspect logs each unmet expectation
func (m *GoGitRepositoryMock) MinimockHeadInspect() {
	for _, e := range m.HeadMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to GoGitRepositoryMock.Head")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.HeadMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterHeadCounter) < 1 {
		m.t.Error("Expected call to GoGitRepositoryMock.Head")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHead != nil && mm_atomic.LoadUint64(&m.afterHeadCounter) < 1 {
		m.t.Error("Expected call to GoGitRepositoryMock.Head")
	}
}

type mGoGitRepositoryMockLog struct {
	mock               *GoGitRepositoryMock
	defaultExpectation *GoGitRepositoryMockLogExpectation
	expectations       []*GoGitRepositoryMockLogExpectation

	callArgs []*GoGitRepositoryMockLogParams
	mutex    sync.RWMutex
}

// GoGitRepositoryMockLogExpectation specifies expectation struct of the GoGitRepository.Log
type GoGitRepositoryMockLogExpectation struct {
	mock    *GoGitRepositoryMock
	params  *GoGitRepositoryMockLogParams
	results *GoGitRepositoryMockLogResults
	Counter uint64
}

// GoGitRepositoryMockLogParams contains parameters of the GoGitRepository.Log
type GoGitRepositoryMockLogParams struct {
	o *git.LogOptions
}

// GoGitRepositoryMockLogResults contains results of the GoGitRepository.Log
type GoGitRepositoryMockLogResults struct {
	c1  object.CommitIter
	err error
}

// Expect sets up expected params for GoGitRepository.Log
func (mmLog *mGoGitRepositoryMockLog) Expect(o *git.LogOptions) *mGoGitRepositoryMockLog {
	if mmLog.mock.funcLog != nil {
		mmLog.mock.t.Fatalf("GoGitRepositoryMock.Log mock is already set by Set")
	}

	if mmLog.defaultExpectation == nil {
		mmLog.defaultExpectation = &GoGitRepositoryMockLogExpectation{}
	}

	mmLog.defaultExpectation.params = &GoGitRepositoryMockLogParams{o}
	for _, e := range mmLog.expectations {
		if minimock.Equal(e.params, mmLog.defaultExpectation.params) {
			mmLog.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmLog.defaultExpectation.params)
		}
	}

	return mmLog
}

// Inspect accepts an inspector function that has same arguments as the GoGitRepository.Log
func (mmLog *mGoGitRepositoryMockLog) Inspect(f func(o *git.LogOptions)) *mGoGitRepositoryMockLog {
	if mmLog.mock.inspectFuncLog != nil {
		mmLog.mock.t.Fatalf("Inspect function is already set for GoGitRepositoryMock.Log")
	}

	mmLog.mock.inspectFuncLog = f

	return mmLog
}

// Return sets up results that will be returned by GoGitRepository.Log
func (mmLog *mGoGitRepositoryMockLog) Return(c1 object.CommitIter, err error) *GoGitRepositoryMock {
	if mmLog.mock.funcLog != nil {
		mmLog.mock.t.Fatalf("GoGitRepositoryMock.Log mock is already set by Set")
	}

	if mmLog.defaultExpectation == nil {
		mmLog.defaultExpectation = &GoGitRepositoryMockLogExpectation{mock: mmLog.mock}
	}
	mmLog.defaultExpectation.results = &GoGitRepositoryMockLogResults{c1, err}
	return mmLog.mock
}

// Set uses given function f to mock the GoGitRepository.Log method
func (mmLog *mGoGitRepositoryMockLog) Set(f func(o *git.LogOptions) (c1 object.CommitIter, err error)) *GoGitRepositoryMock {
	if mmLog.defaultExpectation != nil {
		mmLog.mock.t.Fatalf("Default expectation is already set for the GoGitRepository.Log method")
	}

	if len(mmLog.expectations) > 0 {
		mmLog.mock.t.Fatalf("Some expectations are already set for the GoGitRepository.Log method")
	}

	mmLog.mock.funcLog = f
	return mmLog.mock
}

// When sets expectation for the GoGitRepository.Log which will trigger the result defined by the following
// Then helper
func (mmLog *mGoGitRepositoryMockLog) When(o *git.LogOptions) *GoGitRepositoryMockLogExpectation {
	if mmLog.mock.funcLog != nil {
		mmLog.mock.t.Fatalf("GoGitRepositoryMock.Log mock is already set by Set")
	}

	expectation := &GoGitRepositoryMockLogExpectation{
		mock:   mmLog.mock,
		params: &GoGitRepositoryMockLogParams{o},
	}
	mmLog.expectations = append(mmLog.expectations, expectation)
	return expectation
}

// Then sets up GoGitRepository.Log return parameters for the expectation previously defined by the When method
func (e *GoGitRepositoryMockLogExpectation) Then(c1 object.CommitIter, err error) *GoGitRepositoryMock {
	e.results = &GoGitRepositoryMockLogResults{c1, err}
	return e.mock
}

// Log implements vcs.GoGitRepository
func (mmLog *GoGitRepositoryMock) Log(o *git.LogOptions) (c1 object.CommitIter, err error) {
	mm_atomic.AddUint64(&mmLog.beforeLogCounter, 1)
	defer mm_atomic.AddUint64(&mmLog.afterLogCounter, 1)

	if mmLog.inspectFuncLog != nil {
		mmLog.inspectFuncLog(o)
	}

	mm_params := &GoGitRepositoryMockLogParams{o}

	// Record call args
	mmLog.LogMock.mutex.Lock()
	mmLog.LogMock.callArgs = append(mmLog.LogMock.callArgs, mm_params)
	mmLog.LogMock.mutex.Unlock()

	for _, e := range mmLog.LogMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.c1, e.results.err
		}
	}

	if mmLog.LogMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLog.LogMock.defaultExpectation.Counter, 1)
		mm_want := mmLog.LogMock.defaultExpectation.params
		mm_got := GoGitRepositoryMockLogParams{o}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmLog.t.Errorf("GoGitRepositoryMock.Log got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmLog.LogMock.defaultExpectation.results
		if mm_results == nil {
			mmLog.t.Fatal("No results are set for the GoGitRepositoryMock.Log")
		}
		return (*mm_results).c1, (*mm_results).err
	}
	if mmLog.funcLog != nil {
		return mmLog.funcLog(o)
	}
	mmLog.t.Fatalf("Unexpected call to GoGitRepositoryMock.Log. %v", o)
	return
}

// LogAfterCounter returns a count of finished GoGitRepositoryMock.Log invocations
func (mmLog *GoGitRepositoryMock) LogAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLog.afterLogCounter)
}

// LogBeforeCounter returns a count of GoGitRepositoryMock.Log invocations
func (mmLog *GoGitRepositoryMock) LogBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLog.beforeLogCounter)
}

// Calls returns a list of arguments used in each call to GoGitRepositoryMock.Log.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmLog *mGoGitRepositoryMockLog) Calls() []*GoGitRepositoryMockLogParams {
	mmLog.mutex.RLock()

	argCopy := make([]*GoGitRepositoryMockLogParams, len(mmLog.callArgs))
	copy(argCopy, mmLog.callArgs)

	mmLog.mutex.RUnlock()

	return argCopy
}

// MinimockLogDone returns true if the count of the Log invocations corresponds
// the number of defined expectations
func (m *GoGitRepositoryMock) MinimockLogDone() bool {
	for _, e := range m.LogMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LogMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLogCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLog != nil && mm_atomic.LoadUint64(&m.afterLogCounter) < 1 {
		return false
	}
	return true
}

// MinimockLogInspect logs each unmet expectation
func (m *GoGitRepositoryMock) MinimockLogInspect() {
	for _, e := range m.LogMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GoGitRepositoryMock.Log with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LogMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLogCounter) < 1 {
		if m.LogMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GoGitRepositoryMock.Log")
		} else {
			m.t.Errorf("Expected call to GoGitRepositoryMock.Log with params: %#v", *m.LogMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLog != nil && mm_atomic.LoadUint64(&m.afterLogCounter) < 1 {
		m.t.Error("Expected call to GoGitRepositoryMock.Log")
	}
}

type mGoGitRepositoryMockNotes struct {
	mock               *GoGitRepositoryMock
	defaultExpectation *GoGitRepositoryMockNotesExpectation
	expectations       []*GoGitRepositoryMockNotesExpectation
}

// GoGitRepositoryMockNotesExpectation specifies expectation struct of the GoGitRepository.Notes
type GoGitRepositoryMockNotesExpectation struct {
	mock *GoGitRepositoryMock

	results *GoGitRepositoryMockNotesResults
	Counter uint64
}

// GoGitRepositoryMockNotesResults contains results of the GoGitRepository.Notes
type GoGitRepositoryMockNotesResults struct {
	r1  storer.ReferenceIter
	err error
}

// Expect sets up expected params for GoGitRepository.Notes
func (mmNotes *mGoGitRepositoryMockNotes) Expect() *mGoGitRepositoryMockNotes {
	if mmNotes.mock.funcNotes != nil {
		mmNotes.mock.t.Fatalf("GoGitRepositoryMock.Notes mock is already set by Set")
	}

	if mmNotes.defaultExpectation == nil {
		mmNotes.defaultExpectation = &GoGitRepositoryMockNotesExpectation{}
	}

	return mmNotes
}

// Inspect accepts an inspector function that has same arguments as the GoGitRepository.Notes
func (mmNotes *mGoGitRepositoryMockNotes) Inspect(f func()) *mGoGitRepositoryMockNotes {
	if mmNotes.mock.inspectFuncNotes != nil {
		mmNotes.mock.t.Fatalf("Inspect function is already set for GoGitRepositoryMock.Notes")
	}

	mmNotes.mock.inspectFuncNotes = f

	return mmNotes
}

// Return sets up results that will be returned by GoGitRepository.Notes
func (mmNotes *mGoGitRepositoryMockNotes) Return(r1 storer.ReferenceIter, err error) *GoGitRepositoryMock {
	if mmNotes.mock.funcNotes != nil {
		mmNotes.mock.t.Fatalf("GoGitRepositoryMock.Notes mock is already set by Set")
	}

	if mmNotes.defaultExpectation == nil {
		mmNotes.defaultExpectation = &GoGitRepositoryMockNotesExpectation{mock: mmNotes.mock}
	}
	mmNotes.defaultExpectation.results = &GoGitRepositoryMockNotesResults{r1, err}
	return mmNotes.mock
}

// Set uses given function f to mock the GoGitRepository.Notes method
func (mmNotes *mGoGitRepositoryMockNotes) Set(f func() (r1 storer.ReferenceIter, err error)) *GoGitRepositoryMock {
	if mmNotes.defaultExpectation != nil {
		mmNotes.mock.t.Fatalf("Default expectation is already set for the GoGitRepository.Notes method")
	}

	if len(mmNotes.expectations) > 0 {
		mmNotes.mock.t.Fatalf("Some expectations are already set for the GoGitRepository.Notes method")
	}

	mmNotes.mock.funcNotes = f
	return mmNotes.mock
}

// Notes implements vcs.GoGitRepository
func (mmNotes *GoGitRepositoryMock) Notes() (r1 storer.ReferenceIter, err error) {
	mm_atomic.AddUint64(&mmNotes.beforeNotesCounter, 1)
	defer mm_atomic.AddUint64(&mmNotes.afterNotesCounter, 1)

	if mmNotes.inspectFuncNotes != nil {
		mmNotes.inspectFuncNotes()
	}

	if mmNotes.NotesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmNotes.NotesMock.defaultExpectation.Counter, 1)

		mm_results := mmNotes.NotesMock.defaultExpectation.results
		if mm_results == nil {
			mmNotes.t.Fatal("No results are set for the GoGitRepositoryMock.Notes")
		}
		return (*mm_results).r1, (*mm_results).err
	}
	if mmNotes.funcNotes != nil {
		return mmNotes.funcNotes()
	}
	mmNotes.t.Fatalf("Unexpected call to GoGitRepositoryMock.Notes.")
	return
}

// NotesAfterCounter returns a count of finished GoGitRepositoryMock.Notes invocations
func (mmNotes *GoGitRepositoryMock) NotesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNotes.afterNotesCounter)
}

// NotesBeforeCounter returns a count of GoGitRepositoryMock.Notes invocations
func (mmNotes *GoGitRepositoryMock) NotesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNotes.beforeNotesCounter)
}

// MinimockNotesDone returns true if the count of the Notes invocations corresponds
// the number of defined expectations
func (m *GoGitRepositoryMock) MinimockNotesDone() bool {
	for _, e := range m.NotesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.NotesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterNotesCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNotes != nil && mm_atomic.LoadUint64(&m.afterNotesCounter) < 1 {
		return false
	}
	return true
}

// MinimockNotesInspect logs each unmet expectation
func (m *GoGitRepositoryMock) MinimockNotesInspect() {
	for _, e := range m.NotesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to GoGitRepositoryMock.Notes")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.NotesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterNotesCounter) < 1 {
		m.t.Error("Expected call to GoGitRepositoryMock.Notes")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNotes != nil && mm_atomic.LoadUint64(&m.afterNotesCounter) < 1 {
		m.t.Error("Expected call to GoGitRepositoryMock.Notes")
	}
}

type mGoGitRepositoryMockObject struct {
	mock               *GoGitRepositoryMock
	defaultExpectation *GoGitRepositoryMockObjectExpectation
	expectations       []*GoGitRepositoryMockObjectExpectation

	callArgs []*GoGitRepositoryMockObjectParams
	mutex    sync.RWMutex
}

// GoGitRepositoryMockObjectExpectation specifies expectation struct of the GoGitRepository.Object
type GoGitRepositoryMockObjectExpectation struct {
	mock    *GoGitRepositoryMock
	params  *GoGitRepositoryMockObjectParams
	results *GoGitRepositoryMockObjectResults
	Counter uint64
}

// GoGitRepositoryMockObjectParams contains parameters of the GoGitRepository.Object
type GoGitRepositoryMockObjectParams struct {
	t plumbing.ObjectType
	h plumbing.Hash
}

// GoGitRepositoryMockObjectResults contains results of the GoGitRepository.Object
type GoGitRepositoryMockObjectResults struct {
	o1  object.Object
	err error
}

// Expect sets up expected params for GoGitRepository.Object
func (mmObject *mGoGitRepositoryMockObject) Expect(t plumbing.ObjectType, h plumbing.Hash) *mGoGitRepositoryMockObject {
	if mmObject.mock.funcObject != nil {
		mmObject.mock.t.Fatalf("GoGitRepositoryMock.Object mock is already set by Set")
	}

	if mmObject.defaultExpectation == nil {
		mmObject.defaultExpectation = &GoGitRepositoryMockObjectExpectation{}
	}

	mmObject.defaultExpectation.params = &GoGitRepositoryMockObjectParams{t, h}
	for _, e := range mmObject.expectations {
		if minimock.Equal(e.params, mmObject.defaultExpectation.params) {
			mmObject.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmObject.defaultExpectation.params)
		}
	}

	return mmObject
}

// Inspect accepts an inspector function that has same arguments as the GoGitRepository.Object
func (mmObject *mGoGitRepositoryMockObject) Inspect(f func(t plumbing.ObjectType, h plumbing.Hash)) *mGoGitRepositoryMockObject {
	if mmObject.mock.inspectFuncObject != nil {
		mmObject.mock.t.Fatalf("Inspect function is already set for GoGitRepositoryMock.Object")
	}

	mmObject.mock.inspectFuncObject = f

	return mmObject
}

// Return sets up results that will be returned by GoGitRepository.Object
func (mmObject *mGoGitRepositoryMockObject) Return(o1 object.Object, err error) *GoGitRepositoryMock {
	if mmObject.mock.funcObject != nil {
		mmObject.mock.t.Fatalf("GoGitRepositoryMock.Object mock is already set by Set")
	}

	if mmObject.defaultExpectation == nil {
		mmObject.defaultExpectation = &GoGitRepositoryMockObjectExpectation{mock: mmObject.mock}
	}
	mmObject.defaultExpectation.results = &GoGitRepositoryMockObjectResults{o1, err}
	return mmObject.mock
}

// Set uses given function f to mock the GoGitRepository.Object method
func (mmObject *mGoGitRepositoryMockObject) Set(f func(t plumbing.ObjectType, h plumbing.Hash) (o1 object.Object, err error)) *GoGitRepositoryMock {
	if mmObject.defaultExpectation != nil {
		mmObject.mock.t.Fatalf("Default expectation is already set for the GoGitRepository.Object method")
	}

	if len(mmObject.expectations) > 0 {
		mmObject.mock.t.Fatalf("Some expectations are already set for the GoGitRepository.Object method")
	}

	mmObject.mock.funcObject = f
	return mmObject.mock
}

// When sets expectation for the GoGitRepository.Object which will trigger the result defined by the following
// Then helper
func (mmObject *mGoGitRepositoryMockObject) When(t plumbing.ObjectType, h plumbing.Hash) *GoGitRepositoryMockObjectExpectation {
	if mmObject.mock.funcObject != nil {
		mmObject.mock.t.Fatalf("GoGitRepositoryMock.Object mock is already set by Set")
	}

	expectation := &GoGitRepositoryMockObjectExpectation{
		mock:   mmObject.mock,
		params: &GoGitRepositoryMockObjectParams{t, h},
	}
	mmObject.expectations = append(mmObject.expectations, expectation)
	return expectation
}

// Then sets up GoGitRepository.Object return parameters for the expectation previously defined by the When method
func (e *GoGitRepositoryMockObjectExpectation) Then(o1 object.Object, err error) *GoGitRepositoryMock {
	e.results = &GoGitRepositoryMockObjectResults{o1, err}
	return e.mock
}

// Object implements vcs.GoGitRepository
func (mmObject *GoGitRepositoryMock) Object(t plumbing.ObjectType, h plumbing.Hash) (o1 object.Object, err error) {
	mm_atomic.AddUint64(&mmObject.beforeObjectCounter, 1)
	defer mm_atomic.AddUint64(&mmObject.afterObjectCounter, 1)

	if mmObject.inspectFuncObject != nil {
		mmObject.inspectFuncObject(t, h)
	}

	mm_params := &GoGitRepositoryMockObjectParams{t, h}

	// Record call args
	mmObject.ObjectMock.mutex.Lock()
	mmObject.ObjectMock.callArgs = append(mmObject.ObjectMock.callArgs, mm_params)
	mmObject.ObjectMock.mutex.Unlock()

	for _, e := range mmObject.ObjectMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.o1, e.results.err
		}
	}

	if mmObject.ObjectMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmObject.ObjectMock.defaultExpectation.Counter, 1)
		mm_want := mmObject.ObjectMock.defaultExpectation.params
		mm_got := GoGitRepositoryMockObjectParams{t, h}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmObject.t.Errorf("GoGitRepositoryMock.Object got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmObject.ObjectMock.defaultExpectation.results
		if mm_results == nil {
			mmObject.t.Fatal("No results are set for the GoGitRepositoryMock.Object")
		}
		return (*mm_results).o1, (*mm_results).err
	}
	if mmObject.funcObject != nil {
		return mmObject.funcObject(t, h)
	}
	mmObject.t.Fatalf("Unexpected call to GoGitRepositoryMock.Object. %v %v", t, h)
	return
}

// ObjectAfterCounter returns a count of finished GoGitRepositoryMock.Object invocations
func (mmObject *GoGitRepositoryMock) ObjectAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmObject.afterObjectCounter)
}

// ObjectBeforeCounter returns a count of GoGitRepositoryMock.Object invocations
func (mmObject *GoGitRepositoryMock) ObjectBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmObject.beforeObjectCounter)
}

// Calls returns a list of arguments used in each call to GoGitRepositoryMock.Object.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmObject *mGoGitRepositoryMockObject) Calls() []*GoGitRepositoryMockObjectParams {
	mmObject.mutex.RLock()

	argCopy := make([]*GoGitRepositoryMockObjectParams, len(mmObject.callArgs))
	copy(argCopy, mmObject.callArgs)

	mmObject.mutex.RUnlock()

	return argCopy
}

// MinimockObjectDone returns true if the count of the Object invocations corresponds
// the number of defined expectations
func (m *GoGitRepositoryMock) MinimockObjectDone() bool {
	for _, e := range m.ObjectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ObjectMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterObjectCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcObject != nil && mm_atomic.LoadUint64(&m.afterObjectCounter) < 1 {
		return false
	}
	return true
}

// MinimockObjectInspect logs each unmet expectation
func (m *GoGitRepositoryMock) MinimockObjectInspect() {
	for _, e := range m.ObjectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GoGitRepositoryMock.Object with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ObjectMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterObjectCounter) < 1 {
		if m.ObjectMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GoGitRepositoryMock.Object")
		} else {
			m.t.Errorf("Expected call to GoGitRepositoryMock.Object with params: %#v", *m.ObjectMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcObject != nil && mm_atomic.LoadUint64(&m.afterObjectCounter) < 1 {
		m.t.Error("Expected call to GoGitRepositoryMock.Object")
	}
}

type mGoGitRepositoryMockObjects struct {
	mock               *GoGitRepositoryMock
	defaultExpectation *GoGitRepositoryMockObjectsExpectation
	expectations       []*GoGitRepositoryMockObjectsExpectation
}

// GoGitRepositoryMockObjectsExpectation specifies expectation struct of the GoGitRepository.Objects
type GoGitRepositoryMockObjectsExpectation struct {
	mock *GoGitRepositoryMock

	results *GoGitRepositoryMockObjectsResults
	Counter uint64
}

// GoGitRepositoryMockObjectsResults contains results of the GoGitRepository.Objects
type GoGitRepositoryMockObjectsResults struct {
	op1 *object.ObjectIter
	err error
}

// Expect sets up expected params for GoGitRepository.Objects
func (mmObjects *mGoGitRepositoryMockObjects) Expect() *mGoGitRepositoryMockObjects {
	if mmObjects.mock.funcObjects != nil {
		mmObjects.mock.t.Fatalf("GoGitRepositoryMock.Objects mock is already set by Set")
	}

	if mmObjects.defaultExpectation == nil {
		mmObjects.defaultExpectation = &GoGitRepositoryMockObjectsExpectation{}
	}

	return mmObjects
}

// Inspect accepts an inspector function that has same arguments as the GoGitRepository.Objects
func (mmObjects *mGoGitRepositoryMockObjects) Inspect(f func()) *mGoGitRepositoryMockObjects {
	if mmObjects.mock.inspectFuncObjects != nil {
		mmObjects.mock.t.Fatalf("Inspect function is already set for GoGitRepositoryMock.Objects")
	}

	mmObjects.mock.inspectFuncObjects = f

	return mmObjects
}

// Return sets up results that will be returned by GoGitRepository.Objects
func (mmObjects *mGoGitRepositoryMockObjects) Return(op1 *object.ObjectIter, err error) *GoGitRepositoryMock {
	if mmObjects.mock.funcObjects != nil {
		mmObjects.mock.t.Fatalf("GoGitRepositoryMock.Objects mock is already set by Set")
	}

	if mmObjects.defaultExpectation == nil {
		mmObjects.defaultExpectation = &GoGitRepositoryMockObjectsExpectation{mock: mmObjects.mock}
	}
	mmObjects.defaultExpectation.results = &GoGitRepositoryMockObjectsResults{op1, err}
	return mmObjects.mock
}

// Set uses given function f to mock the GoGitRepository.Objects method
func (mmObjects *mGoGitRepositoryMockObjects) Set(f func() (op1 *object.ObjectIter, err error)) *GoGitRepositoryMock {
	if mmObjects.defaultExpectation != nil {
		mmObjects.mock.t.Fatalf("Default expectation is already set for the GoGitRepository.Objects method")
	}

	if len(mmObjects.expectations) > 0 {
		mmObjects.mock.t.Fatalf("Some expectations are already set for the GoGitRepository.Objects method")
	}

	mmObjects.mock.funcObjects = f
	return mmObjects.mock
}

// Objects implements vcs.GoGitRepository
func (mmObjects *GoGitRepositoryMock) Objects() (op1 *object.ObjectIter, err error) {
	mm_atomic.AddUint64(&mmObjects.beforeObjectsCounter, 1)
	defer mm_atomic.AddUint64(&mmObjects.afterObjectsCounter, 1)

	if mmObjects.inspectFuncObjects != nil {
		mmObjects.inspectFuncObjects()
	}

	if mmObjects.ObjectsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmObjects.ObjectsMock.defaultExpectation.Counter, 1)

		mm_results := mmObjects.ObjectsMock.defaultExpectation.results
		if mm_results == nil {
			mmObjects.t.Fatal("No results are set for the GoGitRepositoryMock.Objects")
		}
		return (*mm_results).op1, (*mm_results).err
	}
	if mmObjects.funcObjects != nil {
		return mmObjects.funcObjects()
	}
	mmObjects.t.Fatalf("Unexpected call to GoGitRepositoryMock.Objects.")
	return
}

// ObjectsAfterCounter returns a count of finished GoGitRepositoryMock.Objects invocations
func (mmObjects *GoGitRepositoryMock) ObjectsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmObjects.afterObjectsCounter)
}

// ObjectsBeforeCounter returns a count of GoGitRepositoryMock.Objects invocations
func (mmObjects *GoGitRepositoryMock) ObjectsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmObjects.beforeObjectsCounter)
}

// MinimockObjectsDone returns true if the count of the Objects invocations corresponds
// the number of defined expectations
func (m *GoGitRepositoryMock) MinimockObjectsDone() bool {
	for _, e := range m.ObjectsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ObjectsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterObjectsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcObjects != nil && mm_atomic.LoadUint64(&m.afterObjectsCounter) < 1 {
		return false
	}
	return true
}

// MinimockObjectsInspect logs each unmet expectation
func (m *GoGitRepositoryMock) MinimockObjectsInspect() {
	for _, e := range m.ObjectsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to GoGitRepositoryMock.Objects")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ObjectsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterObjectsCounter) < 1 {
		m.t.Error("Expected call to GoGitRepositoryMock.Objects")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcObjects != nil && mm_atomic.LoadUint64(&m.afterObjectsCounter) < 1 {
		m.t.Error("Expected call to GoGitRepositoryMock.Objects")
	}
}

type mGoGitRepositoryMockPrune struct {
	mock               *GoGitRepositoryMock
	defaultExpectation *GoGitRepositoryMockPruneExpectation
	expectations       []*GoGitRepositoryMockPruneExpectation

	callArgs []*GoGitRepositoryMockPruneParams
	mutex    sync.RWMutex
}

// GoGitRepositoryMockPruneExpectation specifies expectation struct of the GoGitRepository.Prune
type GoGitRepositoryMockPruneExpectation struct {
	mock    *GoGitRepositoryMock
	params  *GoGitRepositoryMockPruneParams
	results *GoGitRepositoryMockPruneResults
	Counter uint64
}

// GoGitRepositoryMockPruneParams contains parameters of the GoGitRepository.Prune
type GoGitRepositoryMockPruneParams struct {
	opt git.PruneOptions
}

// GoGitRepositoryMockPruneResults contains results of the GoGitRepository.Prune
type GoGitRepositoryMockPruneResults struct {
	err error
}

// Expect sets up expected params for GoGitRepository.Prune
func (mmPrune *mGoGitRepositoryMockPrune) Expect(opt git.PruneOptions) *mGoGitRepositoryMockPrune {
	if mmPrune.mock.funcPrune != nil {
		mmPrune.mock.t.Fatalf("GoGitRepositoryMock.Prune mock is already set by Set")
	}

	if mmPrune.defaultExpectation == nil {
		mmPrune.defaultExpectation = &GoGitRepositoryMockPruneExpectation{}
	}

	mmPrune.defaultExpectation.params = &GoGitRepositoryMockPruneParams{opt}
	for _, e := range mmPrune.expectations {
		if minimock.Equal(e.params, mmPrune.defaultExpectation.params) {
			mmPrune.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPrune.defaultExpectation.params)
		}
	}

	return mmPrune
}

// Inspect accepts an inspector function that has same arguments as the GoGitRepository.Prune
func (mmPrune *mGoGitRepositoryMockPrune) Inspect(f func(opt git.PruneOptions)) *mGoGitRepositoryMockPrune {
	if mmPrune.mock.inspectFuncPrune != nil {
		mmPrune.mock.t.Fatalf("Inspect function is already set for GoGitRepositoryMock.Prune")
	}

	mmPrune.mock.inspectFuncPrune = f

	return mmPrune
}

// Return sets up results that will be returned by GoGitRepository.Prune
func (mmPrune *mGoGitRepositoryMockPrune) Return(err error) *GoGitRepositoryMock {
	if mmPrune.mock.funcPrune != nil {
		mmPrune.mock.t.Fatalf("GoGitRepositoryMock.Prune mock is already set by Set")
	}

	if mmPrune.defaultExpectation == nil {
		mmPrune.defaultExpectation = &GoGitRepositoryMockPruneExpectation{mock: mmPrune.mock}
	}
	mmPrune.defaultExpectation.results = &GoGitRepositoryMockPruneResults{err}
	return mmPrune.mock
}

// Set uses given function f to mock the GoGitRepository.Prune method
func (mmPrune *mGoGitRepositoryMockPrune) Set(f func(opt git.PruneOptions) (err error)) *GoGitRepositoryMock {
	if mmPrune.defaultExpectation != nil {
		mmPrune.mock.t.Fatalf("Default expectation is already set for the GoGitRepository.Prune method")
	}

	if len(mmPrune.expectations) > 0 {
		mmPrune.mock.t.Fatalf("Some expectations are already set for the GoGitRepository.Prune method")
	}

	mmPrune.mock.funcPrune = f
	return mmPrune.mock
}

// When sets expectation for the GoGitRepository.Prune which will trigger the result defined by the following
// Then helper
func (mmPrune *mGoGitRepositoryMockPrune) When(opt git.PruneOptions) *GoGitRepositoryMockPruneExpectation {
	if mmPrune.mock.funcPrune != nil {
		mmPrune.mock.t.Fatalf("GoGitRepositoryMock.Prune mock is already set by Set")
	}

	expectation := &GoGitRepositoryMockPruneExpectation{
		mock:   mmPrune.mock,
		params: &GoGitRepositoryMockPruneParams{opt},
	}
	mmPrune.expectations = append(mmPrune.expectations, expectation)
	return expectation
}

// Then sets up GoGitRepository.Prune return parameters for the expectation previously defined by the When method
func (e *GoGitRepositoryMockPruneExpectation) Then(err error) *GoGitRepositoryMock {
	e.results = &GoGitRepositoryMockPruneResults{err}
	return e.mock
}

// Prune implements vcs.GoGitRepository
func (mmPrune *GoGitRepositoryMock) Prune(opt git.PruneOptions) (err error) {
	mm_atomic.AddUint64(&mmPrune.beforePruneCounter, 1)
	defer mm_atomic.AddUint64(&mmPrune.afterPruneCounter, 1)

	if mmPrune.inspectFuncPrune != nil {
		mmPrune.inspectFuncPrune(opt)
	}

	mm_params := &GoGitRepositoryMockPruneParams{opt}

	// Record call args
	mmPrune.PruneMock.mutex.Lock()
	mmPrune.PruneMock.callArgs = append(mmPrune.PruneMock.callArgs, mm_params)
	mmPrune.PruneMock.mutex.Unlock()

	for _, e := range mmPrune.PruneMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmPrune.PruneMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPrune.PruneMock.defaultExpectation.Counter, 1)
		mm_want := mmPrune.PruneMock.defaultExpectation.params
		mm_got := GoGitRepositoryMockPruneParams{opt}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPrune.t.Errorf("GoGitRepositoryMock.Prune got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPrune.PruneMock.defaultExpectation.results
		if mm_results == nil {
			mmPrune.t.Fatal("No results are set for the GoGitRepositoryMock.Prune")
		}
		return (*mm_results).err
	}
	if mmPrune.funcPrune != nil {
		return mmPrune.funcPrune(opt)
	}
	mmPrune.t.Fatalf("Unexpected call to GoGitRepositoryMock.Prune. %v", opt)
	return
}

// PruneAfterCounter returns a count of finished GoGitRepositoryMock.Prune invocations
func (mmPrune *GoGitRepositoryMock) PruneAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrune.afterPruneCounter)
}

// PruneBeforeCounter returns a count of GoGitRepositoryMock.Prune invocations
func (mmPrune *GoGitRepositoryMock) PruneBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrune.beforePruneCounter)
}

// Calls returns a list of arguments used in each call to GoGitRepositoryMock.Prune.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPrune *mGoGitRepositoryMockPrune) Calls() []*GoGitRepositoryMockPruneParams {
	mmPrune.mutex.RLock()

	argCopy := make([]*GoGitRepositoryMockPruneParams, len(mmPrune.callArgs))
	copy(argCopy, mmPrune.callArgs)

	mmPrune.mutex.RUnlock()

	return argCopy
}

// MinimockPruneDone returns true if the count of the Prune invocations corresponds
// the number of defined expectations
func (m *GoGitRepositoryMock) MinimockPruneDone() bool {
	for _, e := range m.PruneMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PruneMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPruneCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPrune != nil && mm_atomic.LoadUint64(&m.afterPruneCounter) < 1 {
		return false
	}
	return true
}

// MinimockPruneInspect logs each unmet expectation
func (m *GoGitRepositoryMock) MinimockPruneInspect() {
	for _, e := range m.PruneMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GoGitRepositoryMock.Prune with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PruneMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPruneCounter) < 1 {
		if m.PruneMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GoGitRepositoryMock.Prune")
		} else {
			m.t.Errorf("Expected call to GoGitRepositoryMock.Prune with params: %#v", *m.PruneMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPrune != nil && mm_atomic.LoadUint64(&m.afterPruneCounter) < 1 {
		m.t.Error("Expected call to GoGitRepositoryMock.Prune")
	}
}

type mGoGitRepositoryMockPush struct {
	mock               *GoGitRepositoryMock
	defaultExpectation *GoGitRepositoryMockPushExpectation
	expectations       []*GoGitRepositoryMockPushExpectation

	callArgs []*GoGitRepositoryMockPushParams
	mutex    sync.RWMutex
}

// GoGitRepositoryMockPushExpectation specifies expectation struct of the GoGitRepository.Push
type GoGitRepositoryMockPushExpectation struct {
	mock    *GoGitRepositoryMock
	params  *GoGitRepositoryMockPushParams
	results *GoGitRepositoryMockPushResults
	Counter uint64
}

// GoGitRepositoryMockPushParams contains parameters of the GoGitRepository.Push
type GoGitRepositoryMockPushParams struct {
	o *git.PushOptions
}

// GoGitRepositoryMockPushResults contains results of the GoGitRepository.Push
type GoGitRepositoryMockPushResults struct {
	err error
}

// Expect sets up expected params for GoGitRepository.Push
func (mmPush *mGoGitRepositoryMockPush) Expect(o *git.PushOptions) *mGoGitRepositoryMockPush {
	if mmPush.mock.funcPush != nil {
		mmPush.mock.t.Fatalf("GoGitRepositoryMock.Push mock is already set by Set")
	}

	if mmPush.defaultExpectation == nil {
		mmPush.defaultExpectation = &GoGitRepositoryMockPushExpectation{}
	}

	mmPush.defaultExpectation.params = &GoGitRepositoryMockPushParams{o}
	for _, e := range mmPush.expectations {
		if minimock.Equal(e.params, mmPush.defaultExpectation.params) {
			mmPush.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPush.defaultExpectation.params)
		}
	}

	return mmPush
}

// Inspect accepts an inspector function that has same arguments as the GoGitRepository.Push
func (mmPush *mGoGitRepositoryMockPush) Inspect(f func(o *git.PushOptions)) *mGoGitRepositoryMockPush {
	if mmPush.mock.inspectFuncPush != nil {
		mmPush.mock.t.Fatalf("Inspect function is already set for GoGitRepositoryMock.Push")
	}

	mmPush.mock.inspectFuncPush = f

	return mmPush
}

// Return sets up results that will be returned by GoGitRepository.Push
func (mmPush *mGoGitRepositoryMockPush) Return(err error) *GoGitRepositoryMock {
	if mmPush.mock.funcPush != nil {
		mmPush.mock.t.Fatalf("GoGitRepositoryMock.Push mock is already set by Set")
	}

	if mmPush.defaultExpectation == nil {
		mmPush.defaultExpectation = &GoGitRepositoryMockPushExpectation{mock: mmPush.mock}
	}
	mmPush.defaultExpectation.results = &GoGitRepositoryMockPushResults{err}
	return mmPush.mock
}

// Set uses given function f to mock the GoGitRepository.Push method
func (mmPush *mGoGitRepositoryMockPush) Set(f func(o *git.PushOptions) (err error)) *GoGitRepositoryMock {
	if mmPush.defaultExpectation != nil {
		mmPush.mock.t.Fatalf("Default expectation is already set for the GoGitRepository.Push method")
	}

	if len(mmPush.expectations) > 0 {
		mmPush.mock.t.Fatalf("Some expectations are already set for the GoGitRepository.Push method")
	}

	mmPush.mock.funcPush = f
	return mmPush.mock
}

// When sets expectation for the GoGitRepository.Push which will trigger the result defined by the following
// Then helper
func (mmPush *mGoGitRepositoryMockPush) When(o *git.PushOptions) *GoGitRepositoryMockPushExpectation {
	if mmPush.mock.funcPush != nil {
		mmPush.mock.t.Fatalf("GoGitRepositoryMock.Push mock is already set by Set")
	}

	expectation := &GoGitRepositoryMockPushExpectation{
		mock:   mmPush.mock,
		params: &GoGitRepositoryMockPushParams{o},
	}
	mmPush.expectations = append(mmPush.expectations, expectation)
	return expectation
}

// Then sets up GoGitRepository.Push return parameters for the expectation previously defined by the When method
func (e *GoGitRepositoryMockPushExpectation) Then(err error) *GoGitRepositoryMock {
	e.results = &GoGitRepositoryMockPushResults{err}
	return e.mock
}

// Push implements vcs.GoGitRepository
func (mmPush *GoGitRepositoryMock) Push(o *git.PushOptions) (err error) {
	mm_atomic.AddUint64(&mmPush.beforePushCounter, 1)
	defer mm_atomic.AddUint64(&mmPush.afterPushCounter, 1)

	if mmPush.inspectFuncPush != nil {
		mmPush.inspectFuncPush(o)
	}

	mm_params := &GoGitRepositoryMockPushParams{o}

	// Record call args
	mmPush.PushMock.mutex.Lock()
	mmPush.PushMock.callArgs = append(mmPush.PushMock.callArgs, mm_params)
	mmPush.PushMock.mutex.Unlock()

	for _, e := range mmPush.PushMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmPush.PushMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPush.PushMock.defaultExpectation.Counter, 1)
		mm_want := mmPush.PushMock.defaultExpectation.params
		mm_got := GoGitRepositoryMockPushParams{o}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPush.t.Errorf("GoGitRepositoryMock.Push got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPush.PushMock.defaultExpectation.results
		if mm_results == nil {
			mmPush.t.Fatal("No results are set for the GoGitRepositoryMock.Push")
		}
		return (*mm_results).err
	}
	if mmPush.funcPush != nil {
		return mmPush.funcPush(o)
	}
	mmPush.t.Fatalf("Unexpected call to GoGitRepositoryMock.Push. %v", o)
	return
}

// PushAfterCounter returns a count of finished GoGitRepositoryMock.Push invocations
func (mmPush *GoGitRepositoryMock) PushAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPush.afterPushCounter)
}

// PushBeforeCounter returns a count of GoGitRepositoryMock.Push invocations
func (mmPush *GoGitRepositoryMock) PushBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPush.beforePushCounter)
}

// Calls returns a list of arguments used in each call to GoGitRepositoryMock.Push.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPush *mGoGitRepositoryMockPush) Calls() []*GoGitRepositoryMockPushParams {
	mmPush.mutex.RLock()

	argCopy := make([]*GoGitRepositoryMockPushParams, len(mmPush.callArgs))
	copy(argCopy, mmPush.callArgs)

	mmPush.mutex.RUnlock()

	return argCopy
}

// MinimockPushDone returns true if the count of the Push invocations corresponds
// the number of defined expectations
func (m *GoGitRepositoryMock) MinimockPushDone() bool {
	for _, e := range m.PushMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PushMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPushCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPush != nil && mm_atomic.LoadUint64(&m.afterPushCounter) < 1 {
		return false
	}
	return true
}

// MinimockPushInspect logs each unmet expectation
func (m *GoGitRepositoryMock) MinimockPushInspect() {
	for _, e := range m.PushMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GoGitRepositoryMock.Push with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PushMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPushCounter) < 1 {
		if m.PushMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GoGitRepositoryMock.Push")
		} else {
			m.t.Errorf("Expected call to GoGitRepositoryMock.Push with params: %#v", *m.PushMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPush != nil && mm_atomic.LoadUint64(&m.afterPushCounter) < 1 {
		m.t.Error("Expected call to GoGitRepositoryMock.Push")
	}
}

type mGoGitRepositoryMockPushContext struct {
	mock               *GoGitRepositoryMock
	defaultExpectation *GoGitRepositoryMockPushContextExpectation
	expectations       []*GoGitRepositoryMockPushContextExpectation

	callArgs []*GoGitRepositoryMockPushContextParams
	mutex    sync.RWMutex
}

// GoGitRepositoryMockPushContextExpectation specifies expectation struct of the GoGitRepository.PushContext
type GoGitRepositoryMockPushContextExpectation struct {
	mock    *GoGitRepositoryMock
	params  *GoGitRepositoryMockPushContextParams
	results *GoGitRepositoryMockPushContextResults
	Counter uint64
}

// GoGitRepositoryMockPushContextParams contains parameters of the GoGitRepository.PushContext
type GoGitRepositoryMockPushContextParams struct {
	ctx context.Context
	o   *git.PushOptions
}

// GoGitRepositoryMockPushContextResults contains results of the GoGitRepository.PushContext
type GoGitRepositoryMockPushContextResults struct {
	err error
}

// Expect sets up expected params for GoGitRepository.PushContext
func (mmPushContext *mGoGitRepositoryMockPushContext) Expect(ctx context.Context, o *git.PushOptions) *mGoGitRepositoryMockPushContext {
	if mmPushContext.mock.funcPushContext != nil {
		mmPushContext.mock.t.Fatalf("GoGitRepositoryMock.PushContext mock is already set by Set")
	}

	if mmPushContext.defaultExpectation == nil {
		mmPushContext.defaultExpectation = &GoGitRepositoryMockPushContextExpectation{}
	}

	mmPushContext.defaultExpectation.params = &GoGitRepositoryMockPushContextParams{ctx, o}
	for _, e := range mmPushContext.expectations {
		if minimock.Equal(e.params, mmPushContext.defaultExpectation.params) {
			mmPushContext.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPushContext.defaultExpectation.params)
		}
	}

	return mmPushContext
}

// Inspect accepts an inspector function that has same arguments as the GoGitRepository.PushContext
func (mmPushContext *mGoGitRepositoryMockPushContext) Inspect(f func(ctx context.Context, o *git.PushOptions)) *mGoGitRepositoryMockPushContext {
	if mmPushContext.mock.inspectFuncPushContext != nil {
		mmPushContext.mock.t.Fatalf("Inspect function is already set for GoGitRepositoryMock.PushContext")
	}

	mmPushContext.mock.inspectFuncPushContext = f

	return mmPushContext
}

// Return sets up results that will be returned by GoGitRepository.PushContext
func (mmPushContext *mGoGitRepositoryMockPushContext) Return(err error) *GoGitRepositoryMock {
	if mmPushContext.mock.funcPushContext != nil {
		mmPushContext.mock.t.Fatalf("GoGitRepositoryMock.PushContext mock is already set by Set")
	}

	if mmPushContext.defaultExpectation == nil {
		mmPushContext.defaultExpectation = &GoGitRepositoryMockPushContextExpectation{mock: mmPushContext.mock}
	}
	mmPushContext.defaultExpectation.results = &GoGitRepositoryMockPushContextResults{err}
	return mmPushContext.mock
}

// Set uses given function f to mock the GoGitRepository.PushContext method
func (mmPushContext *mGoGitRepositoryMockPushContext) Set(f func(ctx context.Context, o *git.PushOptions) (err error)) *GoGitRepositoryMock {
	if mmPushContext.defaultExpectation != nil {
		mmPushContext.mock.t.Fatalf("Default expectation is already set for the GoGitRepository.PushContext method")
	}

	if len(mmPushContext.expectations) > 0 {
		mmPushContext.mock.t.Fatalf("Some expectations are already set for the GoGitRepository.PushContext method")
	}

	mmPushContext.mock.funcPushContext = f
	return mmPushContext.mock
}

// When sets expectation for the GoGitRepository.PushContext which will trigger the result defined by the following
// Then helper
func (mmPushContext *mGoGitRepositoryMockPushContext) When(ctx context.Context, o *git.PushOptions) *GoGitRepositoryMockPushContextExpectation {
	if mmPushContext.mock.funcPushContext != nil {
		mmPushContext.mock.t.Fatalf("GoGitRepositoryMock.PushContext mock is already set by Set")
	}

	expectation := &GoGitRepositoryMockPushContextExpectation{
		mock:   mmPushContext.mock,
		params: &GoGitRepositoryMockPushContextParams{ctx, o},
	}
	mmPushContext.expectations = append(mmPushContext.expectations, expectation)
	return expectation
}

// Then sets up GoGitRepository.PushContext return parameters for the expectation previously defined by the When method
func (e *GoGitRepositoryMockPushContextExpectation) Then(err error) *GoGitRepositoryMock {
	e.results = &GoGitRepositoryMockPushContextResults{err}
	return e.mock
}

// PushContext implements vcs.GoGitRepository
func (mmPushContext *GoGitRepositoryMock) PushContext(ctx context.Context, o *git.PushOptions) (err error) {
	mm_atomic.AddUint64(&mmPushContext.beforePushContextCounter, 1)
	defer mm_atomic.AddUint64(&mmPushContext.afterPushContextCounter, 1)

	if mmPushContext.inspectFuncPushContext != nil {
		mmPushContext.inspectFuncPushContext(ctx, o)
	}

	mm_params := &GoGitRepositoryMockPushContextParams{ctx, o}

	// Record call args
	mmPushContext.PushContextMock.mutex.Lock()
	mmPushContext.PushContextMock.callArgs = append(mmPushContext.PushContextMock.callArgs, mm_params)
	mmPushContext.PushContextMock.mutex.Unlock()

	for _, e := range mmPushContext.PushContextMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmPushContext.PushContextMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPushContext.PushContextMock.defaultExpectation.Counter, 1)
		mm_want := mmPushContext.PushContextMock.defaultExpectation.params
		mm_got := GoGitRepositoryMockPushContextParams{ctx, o}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPushContext.t.Errorf("GoGitRepositoryMock.PushContext got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPushContext.PushContextMock.defaultExpectation.results
		if mm_results == nil {
			mmPushContext.t.Fatal("No results are set for the GoGitRepositoryMock.PushContext")
		}
		return (*mm_results).err
	}
	if mmPushContext.funcPushContext != nil {
		return mmPushContext.funcPushContext(ctx, o)
	}
	mmPushContext.t.Fatalf("Unexpected call to GoGitRepositoryMock.PushContext. %v %v", ctx, o)
	return
}

// PushContextAfterCounter returns a count of finished GoGitRepositoryMock.PushContext invocations
func (mmPushContext *GoGitRepositoryMock) PushContextAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPushContext.afterPushContextCounter)
}

// PushContextBeforeCounter returns a count of GoGitRepositoryMock.PushContext invocations
func (mmPushContext *GoGitRepositoryMock) PushContextBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPushContext.beforePushContextCounter)
}

// Calls returns a list of arguments used in each call to GoGitRepositoryMock.PushContext.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPushContext *mGoGitRepositoryMockPushContext) Calls() []*GoGitRepositoryMockPushContextParams {
	mmPushContext.mutex.RLock()

	argCopy := make([]*GoGitRepositoryMockPushContextParams, len(mmPushContext.callArgs))
	copy(argCopy, mmPushContext.callArgs)

	mmPushContext.mutex.RUnlock()

	return argCopy
}

// MinimockPushContextDone returns true if the count of the PushContext invocations corresponds
// the number of defined expectations
func (m *GoGitRepositoryMock) MinimockPushContextDone() bool {
	for _, e := range m.PushContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PushContextMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPushContextCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPushContext != nil && mm_atomic.LoadUint64(&m.afterPushContextCounter) < 1 {
		return false
	}
	return true
}

// MinimockPushContextInspect logs each unmet expectation
func (m *GoGitRepositoryMock) MinimockPushContextInspect() {
	for _, e := range m.PushContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GoGitRepositoryMock.PushContext with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PushContextMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPushContextCounter) < 1 {
		if m.PushContextMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GoGitRepositoryMock.PushContext")
		} else {
			m.t.Errorf("Expected call to GoGitRepositoryMock.PushContext with params: %#v", *m.PushContextMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPushContext != nil && mm_atomic.LoadUint64(&m.afterPushContextCounter) < 1 {
		m.t.Error("Expected call to GoGitRepositoryMock.PushContext")
	}
}

type mGoGitRepositoryMockReference struct {
	mock               *GoGitRepositoryMock
	defaultExpectation *GoGitRepositoryMockReferenceExpectation
	expectations       []*GoGitRepositoryMockReferenceExpectation

	callArgs []*GoGitRepositoryMockReferenceParams
	mutex    sync.RWMutex
}

// GoGitRepositoryMockReferenceExpectation specifies expectation struct of the GoGitRepository.Reference
type GoGitRepositoryMockReferenceExpectation struct {
	mock    *GoGitRepositoryMock
	params  *GoGitRepositoryMockReferenceParams
	results *GoGitRepositoryMockReferenceResults
	Counter uint64
}

// GoGitRepositoryMockReferenceParams contains parameters of the GoGitRepository.Reference
type GoGitRepositoryMockReferenceParams struct {
	name     plumbing.ReferenceName
	resolved bool
}

// GoGitRepositoryMockReferenceResults contains results of the GoGitRepository.Reference
type GoGitRepositoryMockReferenceResults struct {
	rp1 *plumbing.Reference
	err error
}

// Expect sets up expected params for GoGitRepository.Reference
func (mmReference *mGoGitRepositoryMockReference) Expect(name plumbing.ReferenceName, resolved bool) *mGoGitRepositoryMockReference {
	if mmReference.mock.funcReference != nil {
		mmReference.mock.t.Fatalf("GoGitRepositoryMock.Reference mock is already set by Set")
	}

	if mmReference.defaultExpectation == nil {
		mmReference.defaultExpectation = &GoGitRepositoryMockReferenceExpectation{}
	}

	mmReference.defaultExpectation.params = &GoGitRepositoryMockReferenceParams{name, resolved}
	for _, e := range mmReference.expectations {
		if minimock.Equal(e.params, mmReference.defaultExpectation.params) {
			mmReference.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReference.defaultExpectation.params)
		}
	}

	return mmReference
}

// Inspect accepts an inspector function that has same arguments as the GoGitRepository.Reference
func (mmReference *mGoGitRepositoryMockReference) Inspect(f func(name plumbing.ReferenceName, resolved bool)) *mGoGitRepositoryMockReference {
	if mmReference.mock.inspectFuncReference != nil {
		mmReference.mock.t.Fatalf("Inspect function is already set for GoGitRepositoryMock.Reference")
	}

	mmReference.mock.inspectFuncReference = f

	return mmReference
}

// Return sets up results that will be returned by GoGitRepository.Reference
func (mmReference *mGoGitRepositoryMockReference) Return(rp1 *plumbing.Reference, err error) *GoGitRepositoryMock {
	if mmReference.mock.funcReference != nil {
		mmReference.mock.t.Fatalf("GoGitRepositoryMock.Reference mock is already set by Set")
	}

	if mmReference.defaultExpectation == nil {
		mmReference.defaultExpectation = &GoGitRepositoryMockReferenceExpectation{mock: mmReference.mock}
	}
	mmReference.defaultExpectation.results = &GoGitRepositoryMockReferenceResults{rp1, err}
	return mmReference.mock
}

// Set uses given function f to mock the GoGitRepository.Reference method
func (mmReference *mGoGitRepositoryMockReference) Set(f func(name plumbing.ReferenceName, resolved bool) (rp1 *plumbing.Reference, err error)) *GoGitRepositoryMock {
	if mmReference.defaultExpectation != nil {
		mmReference.mock.t.Fatalf("Default expectation is already set for the GoGitRepository.Reference method")
	}

	if len(mmReference.expectations) > 0 {
		mmReference.mock.t.Fatalf("Some expectations are already set for the GoGitRepository.Reference method")
	}

	mmReference.mock.funcReference = f
	return mmReference.mock
}

// When sets expectation for the GoGitRepository.Reference which will trigger the result defined by the following
// Then helper
func (mmReference *mGoGitRepositoryMockReference) When(name plumbing.ReferenceName, resolved bool) *GoGitRepositoryMockReferenceExpectation {
	if mmReference.mock.funcReference != nil {
		mmReference.mock.t.Fatalf("GoGitRepositoryMock.Reference mock is already set by Set")
	}

	expectation := &GoGitRepositoryMockReferenceExpectation{
		mock:   mmReference.mock,
		params: &GoGitRepositoryMockReferenceParams{name, resolved},
	}
	mmReference.expectations = append(mmReference.expectations, expectation)
	return expectation
}

// Then sets up GoGitRepository.Reference return parameters for the expectation previously defined by the When method
func (e *GoGitRepositoryMockReferenceExpectation) Then(rp1 *plumbing.Reference, err error) *GoGitRepositoryMock {
	e.results = &GoGitRepositoryMockReferenceResults{rp1, err}
	return e.mock
}

// Reference implements vcs.GoGitRepository
func (mmReference *GoGitRepositoryMock) Reference(name plumbing.ReferenceName, resolved bool) (rp1 *plumbing.Reference, err error) {
	mm_atomic.AddUint64(&mmReference.beforeReferenceCounter, 1)
	defer mm_atomic.AddUint64(&mmReference.afterReferenceCounter, 1)

	if mmReference.inspectFuncReference != nil {
		mmReference.inspectFuncReference(name, resolved)
	}

	mm_params := &GoGitRepositoryMockReferenceParams{name, resolved}

	// Record call args
	mmReference.ReferenceMock.mutex.Lock()
	mmReference.ReferenceMock.callArgs = append(mmReference.ReferenceMock.callArgs, mm_params)
	mmReference.ReferenceMock.mutex.Unlock()

	for _, e := range mmReference.ReferenceMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.rp1, e.results.err
		}
	}

	if mmReference.ReferenceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReference.ReferenceMock.defaultExpectation.Counter, 1)
		mm_want := mmReference.ReferenceMock.defaultExpectation.params
		mm_got := GoGitRepositoryMockReferenceParams{name, resolved}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReference.t.Errorf("GoGitRepositoryMock.Reference got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReference.ReferenceMock.defaultExpectation.results
		if mm_results == nil {
			mmReference.t.Fatal("No results are set for the GoGitRepositoryMock.Reference")
		}
		return (*mm_results).rp1, (*mm_results).err
	}
	if mmReference.funcReference != nil {
		return mmReference.funcReference(name, resolved)
	}
	mmReference.t.Fatalf("Unexpected call to GoGitRepositoryMock.Reference. %v %v", name, resolved)
	return
}

// ReferenceAfterCounter returns a count of finished GoGitRepositoryMock.Reference invocations
func (mmReference *GoGitRepositoryMock) ReferenceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReference.afterReferenceCounter)
}

// ReferenceBeforeCounter returns a count of GoGitRepositoryMock.Reference invocations
func (mmReference *GoGitRepositoryMock) ReferenceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReference.beforeReferenceCounter)
}

// Calls returns a list of arguments used in each call to GoGitRepositoryMock.Reference.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReference *mGoGitRepositoryMockReference) Calls() []*GoGitRepositoryMockReferenceParams {
	mmReference.mutex.RLock()

	argCopy := make([]*GoGitRepositoryMockReferenceParams, len(mmReference.callArgs))
	copy(argCopy, mmReference.callArgs)

	mmReference.mutex.RUnlock()

	return argCopy
}

// MinimockReferenceDone returns true if the count of the Reference invocations corresponds
// the number of defined expectations
func (m *GoGitRepositoryMock) MinimockReferenceDone() bool {
	for _, e := range m.ReferenceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReferenceMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReferenceCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReference != nil && mm_atomic.LoadUint64(&m.afterReferenceCounter) < 1 {
		return false
	}
	return true
}

// MinimockReferenceInspect logs each unmet expectation
func (m *GoGitRepositoryMock) MinimockReferenceInspect() {
	for _, e := range m.ReferenceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GoGitRepositoryMock.Reference with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReferenceMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReferenceCounter) < 1 {
		if m.ReferenceMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GoGitRepositoryMock.Reference")
		} else {
			m.t.Errorf("Expected call to GoGitRepositoryMock.Reference with params: %#v", *m.ReferenceMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReference != nil && mm_atomic.LoadUint64(&m.afterReferenceCounter) < 1 {
		m.t.Error("Expected call to GoGitRepositoryMock.Reference")
	}
}

type mGoGitRepositoryMockReferences struct {
	mock               *GoGitRepositoryMock
	defaultExpectation *GoGitRepositoryMockReferencesExpectation
	expectations       []*GoGitRepositoryMockReferencesExpectation
}

// GoGitRepositoryMockReferencesExpectation specifies expectation struct of the GoGitRepository.References
type GoGitRepositoryMockReferencesExpectation struct {
	mock *GoGitRepositoryMock

	results *GoGitRepositoryMockReferencesResults
	Counter uint64
}

// GoGitRepositoryMockReferencesResults contains results of the GoGitRepository.References
type GoGitRepositoryMockReferencesResults struct {
	r1  storer.ReferenceIter
	err error
}

// Expect sets up expected params for GoGitRepository.References
func (mmReferences *mGoGitRepositoryMockReferences) Expect() *mGoGitRepositoryMockReferences {
	if mmReferences.mock.funcReferences != nil {
		mmReferences.mock.t.Fatalf("GoGitRepositoryMock.References mock is already set by Set")
	}

	if mmReferences.defaultExpectation == nil {
		mmReferences.defaultExpectation = &GoGitRepositoryMockReferencesExpectation{}
	}

	return mmReferences
}

// Inspect accepts an inspector function that has same arguments as the GoGitRepository.References
func (mmReferences *mGoGitRepositoryMockReferences) Inspect(f func()) *mGoGitRepositoryMockReferences {
	if mmReferences.mock.inspectFuncReferences != nil {
		mmReferences.mock.t.Fatalf("Inspect function is already set for GoGitRepositoryMock.References")
	}

	mmReferences.mock.inspectFuncReferences = f

	return mmReferences
}

// Return sets up results that will be returned by GoGitRepository.References
func (mmReferences *mGoGitRepositoryMockReferences) Return(r1 storer.ReferenceIter, err error) *GoGitRepositoryMock {
	if mmReferences.mock.funcReferences != nil {
		mmReferences.mock.t.Fatalf("GoGitRepositoryMock.References mock is already set by Set")
	}

	if mmReferences.defaultExpectation == nil {
		mmReferences.defaultExpectation = &GoGitRepositoryMockReferencesExpectation{mock: mmReferences.mock}
	}
	mmReferences.defaultExpectation.results = &GoGitRepositoryMockReferencesResults{r1, err}
	return mmReferences.mock
}

// Set uses given function f to mock the GoGitRepository.References method
func (mmReferences *mGoGitRepositoryMockReferences) Set(f func() (r1 storer.ReferenceIter, err error)) *GoGitRepositoryMock {
	if mmReferences.defaultExpectation != nil {
		mmReferences.mock.t.Fatalf("Default expectation is already set for the GoGitRepository.References method")
	}

	if len(mmReferences.expectations) > 0 {
		mmReferences.mock.t.Fatalf("Some expectations are already set for the GoGitRepository.References method")
	}

	mmReferences.mock.funcReferences = f
	return mmReferences.mock
}

// References implements vcs.GoGitRepository
func (mmReferences *GoGitRepositoryMock) References() (r1 storer.ReferenceIter, err error) {
	mm_atomic.AddUint64(&mmReferences.beforeReferencesCounter, 1)
	defer mm_atomic.AddUint64(&mmReferences.afterReferencesCounter, 1)

	if mmReferences.inspectFuncReferences != nil {
		mmReferences.inspectFuncReferences()
	}

	if mmReferences.ReferencesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReferences.ReferencesMock.defaultExpectation.Counter, 1)

		mm_results := mmReferences.ReferencesMock.defaultExpectation.results
		if mm_results == nil {
			mmReferences.t.Fatal("No results are set for the GoGitRepositoryMock.References")
		}
		return (*mm_results).r1, (*mm_results).err
	}
	if mmReferences.funcReferences != nil {
		return mmReferences.funcReferences()
	}
	mmReferences.t.Fatalf("Unexpected call to GoGitRepositoryMock.References.")
	return
}

// ReferencesAfterCounter returns a count of finished GoGitRepositoryMock.References invocations
func (mmReferences *GoGitRepositoryMock) ReferencesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReferences.afterReferencesCounter)
}

// ReferencesBeforeCounter returns a count of GoGitRepositoryMock.References invocations
func (mmReferences *GoGitRepositoryMock) ReferencesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReferences.beforeReferencesCounter)
}

// MinimockReferencesDone returns true if the count of the References invocations corresponds
// the number of defined expectations
func (m *GoGitRepositoryMock) MinimockReferencesDone() bool {
	for _, e := range m.ReferencesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReferencesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReferencesCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReferences != nil && mm_atomic.LoadUint64(&m.afterReferencesCounter) < 1 {
		return false
	}
	return true
}

// MinimockReferencesInspect logs each unmet expectation
func (m *GoGitRepositoryMock) MinimockReferencesInspect() {
	for _, e := range m.ReferencesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to GoGitRepositoryMock.References")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReferencesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReferencesCounter) < 1 {
		m.t.Error("Expected call to GoGitRepositoryMock.References")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReferences != nil && mm_atomic.LoadUint64(&m.afterReferencesCounter) < 1 {
		m.t.Error("Expected call to GoGitRepositoryMock.References")
	}
}

type mGoGitRepositoryMockRemote struct {
	mock               *GoGitRepositoryMock
	defaultExpectation *GoGitRepositoryMockRemoteExpectation
	expectations       []*GoGitRepositoryMockRemoteExpectation

	callArgs []*GoGitRepositoryMockRemoteParams
	mutex    sync.RWMutex
}

// GoGitRepositoryMockRemoteExpectation specifies expectation struct of the GoGitRepository.Remote
type GoGitRepositoryMockRemoteExpectation struct {
	mock    *GoGitRepositoryMock
	params  *GoGitRepositoryMockRemoteParams
	results *GoGitRepositoryMockRemoteResults
	Counter uint64
}

// GoGitRepositoryMockRemoteParams contains parameters of the GoGitRepository.Remote
type GoGitRepositoryMockRemoteParams struct {
	name string
}

// GoGitRepositoryMockRemoteResults contains results of the GoGitRepository.Remote
type GoGitRepositoryMockRemoteResults struct {
	rp1 *git.Remote
	err error
}

// Expect sets up expected params for GoGitRepository.Remote
func (mmRemote *mGoGitRepositoryMockRemote) Expect(name string) *mGoGitRepositoryMockRemote {
	if mmRemote.mock.funcRemote != nil {
		mmRemote.mock.t.Fatalf("GoGitRepositoryMock.Remote mock is already set by Set")
	}

	if mmRemote.defaultExpectation == nil {
		mmRemote.defaultExpectation = &GoGitRepositoryMockRemoteExpectation{}
	}

	mmRemote.defaultExpectation.params = &GoGitRepositoryMockRemoteParams{name}
	for _, e := range mmRemote.expectations {
		if minimock.Equal(e.params, mmRemote.defaultExpectation.params) {
			mmRemote.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRemote.defaultExpectation.params)
		}
	}

	return mmRemote
}

// Inspect accepts an inspector function that has same arguments as the GoGitRepository.Remote
func (mmRemote *mGoGitRepositoryMockRemote) Inspect(f func(name string)) *mGoGitRepositoryMockRemote {
	if mmRemote.mock.inspectFuncRemote != nil {
		mmRemote.mock.t.Fatalf("Inspect function is already set for GoGitRepositoryMock.Remote")
	}

	mmRemote.mock.inspectFuncRemote = f

	return mmRemote
}

// Return sets up results that will be returned by GoGitRepository.Remote
func (mmRemote *mGoGitRepositoryMockRemote) Return(rp1 *git.Remote, err error) *GoGitRepositoryMock {
	if mmRemote.mock.funcRemote != nil {
		mmRemote.mock.t.Fatalf("GoGitRepositoryMock.Remote mock is already set by Set")
	}

	if mmRemote.defaultExpectation == nil {
		mmRemote.defaultExpectation = &GoGitRepositoryMockRemoteExpectation{mock: mmRemote.mock}
	}
	mmRemote.defaultExpectation.results = &GoGitRepositoryMockRemoteResults{rp1, err}
	return mmRemote.mock
}

// Set uses given function f to mock the GoGitRepository.Remote method
func (mmRemote *mGoGitRepositoryMockRemote) Set(f func(name string) (rp1 *git.Remote, err error)) *GoGitRepositoryMock {
	if mmRemote.defaultExpectation != nil {
		mmRemote.mock.t.Fatalf("Default expectation is already set for the GoGitRepository.Remote method")
	}

	if len(mmRemote.expectations) > 0 {
		mmRemote.mock.t.Fatalf("Some expectations are already set for the GoGitRepository.Remote method")
	}

	mmRemote.mock.funcRemote = f
	return mmRemote.mock
}

// When sets expectation for the GoGitRepository.Remote which will trigger the result defined by the following
// Then helper
func (mmRemote *mGoGitRepositoryMockRemote) When(name string) *GoGitRepositoryMockRemoteExpectation {
	if mmRemote.mock.funcRemote != nil {
		mmRemote.mock.t.Fatalf("GoGitRepositoryMock.Remote mock is already set by Set")
	}

	expectation := &GoGitRepositoryMockRemoteExpectation{
		mock:   mmRemote.mock,
		params: &GoGitRepositoryMockRemoteParams{name},
	}
	mmRemote.expectations = append(mmRemote.expectations, expectation)
	return expectation
}

// Then sets up GoGitRepository.Remote return parameters for the expectation previously defined by the When method
func (e *GoGitRepositoryMockRemoteExpectation) Then(rp1 *git.Remote, err error) *GoGitRepositoryMock {
	e.results = &GoGitRepositoryMockRemoteResults{rp1, err}
	return e.mock
}

// Remote implements vcs.GoGitRepository
func (mmRemote *GoGitRepositoryMock) Remote(name string) (rp1 *git.Remote, err error) {
	mm_atomic.AddUint64(&mmRemote.beforeRemoteCounter, 1)
	defer mm_atomic.AddUint64(&mmRemote.afterRemoteCounter, 1)

	if mmRemote.inspectFuncRemote != nil {
		mmRemote.inspectFuncRemote(name)
	}

	mm_params := &GoGitRepositoryMockRemoteParams{name}

	// Record call args
	mmRemote.RemoteMock.mutex.Lock()
	mmRemote.RemoteMock.callArgs = append(mmRemote.RemoteMock.callArgs, mm_params)
	mmRemote.RemoteMock.mutex.Unlock()

	for _, e := range mmRemote.RemoteMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.rp1, e.results.err
		}
	}

	if mmRemote.RemoteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRemote.RemoteMock.defaultExpectation.Counter, 1)
		mm_want := mmRemote.RemoteMock.defaultExpectation.params
		mm_got := GoGitRepositoryMockRemoteParams{name}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRemote.t.Errorf("GoGitRepositoryMock.Remote got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRemote.RemoteMock.defaultExpectation.results
		if mm_results == nil {
			mmRemote.t.Fatal("No results are set for the GoGitRepositoryMock.Remote")
		}
		return (*mm_results).rp1, (*mm_results).err
	}
	if mmRemote.funcRemote != nil {
		return mmRemote.funcRemote(name)
	}
	mmRemote.t.Fatalf("Unexpected call to GoGitRepositoryMock.Remote. %v", name)
	return
}

// RemoteAfterCounter returns a count of finished GoGitRepositoryMock.Remote invocations
func (mmRemote *GoGitRepositoryMock) RemoteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemote.afterRemoteCounter)
}

// RemoteBeforeCounter returns a count of GoGitRepositoryMock.Remote invocations
func (mmRemote *GoGitRepositoryMock) RemoteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemote.beforeRemoteCounter)
}

// Calls returns a list of arguments used in each call to GoGitRepositoryMock.Remote.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRemote *mGoGitRepositoryMockRemote) Calls() []*GoGitRepositoryMockRemoteParams {
	mmRemote.mutex.RLock()

	argCopy := make([]*GoGitRepositoryMockRemoteParams, len(mmRemote.callArgs))
	copy(argCopy, mmRemote.callArgs)

	mmRemote.mutex.RUnlock()

	return argCopy
}

// MinimockRemoteDone returns true if the count of the Remote invocations corresponds
// the number of defined expectations
func (m *GoGitRepositoryMock) MinimockRemoteDone() bool {
	for _, e := range m.RemoteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RemoteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRemoteCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemote != nil && mm_atomic.LoadUint64(&m.afterRemoteCounter) < 1 {
		return false
	}
	return true
}

// MinimockRemoteInspect logs each unmet expectation
func (m *GoGitRepositoryMock) MinimockRemoteInspect() {
	for _, e := range m.RemoteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GoGitRepositoryMock.Remote with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RemoteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRemoteCounter) < 1 {
		if m.RemoteMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GoGitRepositoryMock.Remote")
		} else {
			m.t.Errorf("Expected call to GoGitRepositoryMock.Remote with params: %#v", *m.RemoteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemote != nil && mm_atomic.LoadUint64(&m.afterRemoteCounter) < 1 {
		m.t.Error("Expected call to GoGitRepositoryMock.Remote")
	}
}

type mGoGitRepositoryMockRemotes struct {
	mock               *GoGitRepositoryMock
	defaultExpectation *GoGitRepositoryMockRemotesExpectation
	expectations       []*GoGitRepositoryMockRemotesExpectation
}

// GoGitRepositoryMockRemotesExpectation specifies expectation struct of the GoGitRepository.Remotes
type GoGitRepositoryMockRemotesExpectation struct {
	mock *GoGitRepositoryMock

	results *GoGitRepositoryMockRemotesResults
	Counter uint64
}

// GoGitRepositoryMockRemotesResults contains results of the GoGitRepository.Remotes
type GoGitRepositoryMockRemotesResults struct {
	rpa1 []*git.Remote
	err  error
}

// Expect sets up expected params for GoGitRepository.Remotes
func (mmRemotes *mGoGitRepositoryMockRemotes) Expect() *mGoGitRepositoryMockRemotes {
	if mmRemotes.mock.funcRemotes != nil {
		mmRemotes.mock.t.Fatalf("GoGitRepositoryMock.Remotes mock is already set by Set")
	}

	if mmRemotes.defaultExpectation == nil {
		mmRemotes.defaultExpectation = &GoGitRepositoryMockRemotesExpectation{}
	}

	return mmRemotes
}

// Inspect accepts an inspector function that has same arguments as the GoGitRepository.Remotes
func (mmRemotes *mGoGitRepositoryMockRemotes) Inspect(f func()) *mGoGitRepositoryMockRemotes {
	if mmRemotes.mock.inspectFuncRemotes != nil {
		mmRemotes.mock.t.Fatalf("Inspect function is already set for GoGitRepositoryMock.Remotes")
	}

	mmRemotes.mock.inspectFuncRemotes = f

	return mmRemotes
}

// Return sets up results that will be returned by GoGitRepository.Remotes
func (mmRemotes *mGoGitRepositoryMockRemotes) Return(rpa1 []*git.Remote, err error) *GoGitRepositoryMock {
	if mmRemotes.mock.funcRemotes != nil {
		mmRemotes.mock.t.Fatalf("GoGitRepositoryMock.Remotes mock is already set by Set")
	}

	if mmRemotes.defaultExpectation == nil {
		mmRemotes.defaultExpectation = &GoGitRepositoryMockRemotesExpectation{mock: mmRemotes.mock}
	}
	mmRemotes.defaultExpectation.results = &GoGitRepositoryMockRemotesResults{rpa1, err}
	return mmRemotes.mock
}

// Set uses given function f to mock the GoGitRepository.Remotes method
func (mmRemotes *mGoGitRepositoryMockRemotes) Set(f func() (rpa1 []*git.Remote, err error)) *GoGitRepositoryMock {
	if mmRemotes.defaultExpectation != nil {
		mmRemotes.mock.t.Fatalf("Default expectation is already set for the GoGitRepository.Remotes method")
	}

	if len(mmRemotes.expectations) > 0 {
		mmRemotes.mock.t.Fatalf("Some expectations are already set for the GoGitRepository.Remotes method")
	}

	mmRemotes.mock.funcRemotes = f
	return mmRemotes.mock
}

// Remotes implements vcs.GoGitRepository
func (mmRemotes *GoGitRepositoryMock) Remotes() (rpa1 []*git.Remote, err error) {
	mm_atomic.AddUint64(&mmRemotes.beforeRemotesCounter, 1)
	defer mm_atomic.AddUint64(&mmRemotes.afterRemotesCounter, 1)

	if mmRemotes.inspectFuncRemotes != nil {
		mmRemotes.inspectFuncRemotes()
	}

	if mmRemotes.RemotesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRemotes.RemotesMock.defaultExpectation.Counter, 1)

		mm_results := mmRemotes.RemotesMock.defaultExpectation.results
		if mm_results == nil {
			mmRemotes.t.Fatal("No results are set for the GoGitRepositoryMock.Remotes")
		}
		return (*mm_results).rpa1, (*mm_results).err
	}
	if mmRemotes.funcRemotes != nil {
		return mmRemotes.funcRemotes()
	}
	mmRemotes.t.Fatalf("Unexpected call to GoGitRepositoryMock.Remotes.")
	return
}

// RemotesAfterCounter returns a count of finished GoGitRepositoryMock.Remotes invocations
func (mmRemotes *GoGitRepositoryMock) RemotesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemotes.afterRemotesCounter)
}

// RemotesBeforeCounter returns a count of GoGitRepositoryMock.Remotes invocations
func (mmRemotes *GoGitRepositoryMock) RemotesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemotes.beforeRemotesCounter)
}

// MinimockRemotesDone returns true if the count of the Remotes invocations corresponds
// the number of defined expectations
func (m *GoGitRepositoryMock) MinimockRemotesDone() bool {
	for _, e := range m.RemotesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RemotesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRemotesCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemotes != nil && mm_atomic.LoadUint64(&m.afterRemotesCounter) < 1 {
		return false
	}
	return true
}

// MinimockRemotesInspect logs each unmet expectation
func (m *GoGitRepositoryMock) MinimockRemotesInspect() {
	for _, e := range m.RemotesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to GoGitRepositoryMock.Remotes")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RemotesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRemotesCounter) < 1 {
		m.t.Error("Expected call to GoGitRepositoryMock.Remotes")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemotes != nil && mm_atomic.LoadUint64(&m.afterRemotesCounter) < 1 {
		m.t.Error("Expected call to GoGitRepositoryMock.Remotes")
	}
}

type mGoGitRepositoryMockRepackObjects struct {
	mock               *GoGitRepositoryMock
	defaultExpectation *GoGitRepositoryMockRepackObjectsExpectation
	expectations       []*GoGitRepositoryMockRepackObjectsExpectation

	callArgs []*GoGitRepositoryMockRepackObjectsParams
	mutex    sync.RWMutex
}

// GoGitRepositoryMockRepackObjectsExpectation specifies expectation struct of the GoGitRepository.RepackObjects
type GoGitRepositoryMockRepackObjectsExpectation struct {
	mock    *GoGitRepositoryMock
	params  *GoGitRepositoryMockRepackObjectsParams
	results *GoGitRepositoryMockRepackObjectsResults
	Counter uint64
}

// GoGitRepositoryMockRepackObjectsParams contains parameters of the GoGitRepository.RepackObjects
type GoGitRepositoryMockRepackObjectsParams struct {
	cfg *git.RepackConfig
}

// GoGitRepositoryMockRepackObjectsResults contains results of the GoGitRepository.RepackObjects
type GoGitRepositoryMockRepackObjectsResults struct {
	err error
}

// Expect sets up expected params for GoGitRepository.RepackObjects
func (mmRepackObjects *mGoGitRepositoryMockRepackObjects) Expect(cfg *git.RepackConfig) *mGoGitRepositoryMockRepackObjects {
	if mmRepackObjects.mock.funcRepackObjects != nil {
		mmRepackObjects.mock.t.Fatalf("GoGitRepositoryMock.RepackObjects mock is already set by Set")
	}

	if mmRepackObjects.defaultExpectation == nil {
		mmRepackObjects.defaultExpectation = &GoGitRepositoryMockRepackObjectsExpectation{}
	}

	mmRepackObjects.defaultExpectation.params = &GoGitRepositoryMockRepackObjectsParams{cfg}
	for _, e := range mmRepackObjects.expectations {
		if minimock.Equal(e.params, mmRepackObjects.defaultExpectation.params) {
			mmRepackObjects.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRepackObjects.defaultExpectation.params)
		}
	}

	return mmRepackObjects
}

// Inspect accepts an inspector function that has same arguments as the GoGitRepository.RepackObjects
func (mmRepackObjects *mGoGitRepositoryMockRepackObjects) Inspect(f func(cfg *git.RepackConfig)) *mGoGitRepositoryMockRepackObjects {
	if mmRepackObjects.mock.inspectFuncRepackObjects != nil {
		mmRepackObjects.mock.t.Fatalf("Inspect function is already set for GoGitRepositoryMock.RepackObjects")
	}

	mmRepackObjects.mock.inspectFuncRepackObjects = f

	return mmRepackObjects
}

// Return sets up results that will be returned by GoGitRepository.RepackObjects
func (mmRepackObjects *mGoGitRepositoryMockRepackObjects) Return(err error) *GoGitRepositoryMock {
	if mmRepackObjects.mock.funcRepackObjects != nil {
		mmRepackObjects.mock.t.Fatalf("GoGitRepositoryMock.RepackObjects mock is already set by Set")
	}

	if mmRepackObjects.defaultExpectation == nil {
		mmRepackObjects.defaultExpectation = &GoGitRepositoryMockRepackObjectsExpectation{mock: mmRepackObjects.mock}
	}
	mmRepackObjects.defaultExpectation.results = &GoGitRepositoryMockRepackObjectsResults{err}
	return mmRepackObjects.mock
}

// Set uses given function f to mock the GoGitRepository.RepackObjects method
func (mmRepackObjects *mGoGitRepositoryMockRepackObjects) Set(f func(cfg *git.RepackConfig) (err error)) *GoGitRepositoryMock {
	if mmRepackObjects.defaultExpectation != nil {
		mmRepackObjects.mock.t.Fatalf("Default expectation is already set for the GoGitRepository.RepackObjects method")
	}

	if len(mmRepackObjects.expectations) > 0 {
		mmRepackObjects.mock.t.Fatalf("Some expectations are already set for the GoGitRepository.RepackObjects method")
	}

	mmRepackObjects.mock.funcRepackObjects = f
	return mmRepackObjects.mock
}

// When sets expectation for the GoGitRepository.RepackObjects which will trigger the result defined by the following
// Then helper
func (mmRepackObjects *mGoGitRepositoryMockRepackObjects) When(cfg *git.RepackConfig) *GoGitRepositoryMockRepackObjectsExpectation {
	if mmRepackObjects.mock.funcRepackObjects != nil {
		mmRepackObjects.mock.t.Fatalf("GoGitRepositoryMock.RepackObjects mock is already set by Set")
	}

	expectation := &GoGitRepositoryMockRepackObjectsExpectation{
		mock:   mmRepackObjects.mock,
		params: &GoGitRepositoryMockRepackObjectsParams{cfg},
	}
	mmRepackObjects.expectations = append(mmRepackObjects.expectations, expectation)
	return expectation
}

// Then sets up GoGitRepository.RepackObjects return parameters for the expectation previously defined by the When method
func (e *GoGitRepositoryMockRepackObjectsExpectation) Then(err error) *GoGitRepositoryMock {
	e.results = &GoGitRepositoryMockRepackObjectsResults{err}
	return e.mock
}

// RepackObjects implements vcs.GoGitRepository
func (mmRepackObjects *GoGitRepositoryMock) RepackObjects(cfg *git.RepackConfig) (err error) {
	mm_atomic.AddUint64(&mmRepackObjects.beforeRepackObjectsCounter, 1)
	defer mm_atomic.AddUint64(&mmRepackObjects.afterRepackObjectsCounter, 1)

	if mmRepackObjects.inspectFuncRepackObjects != nil {
		mmRepackObjects.inspectFuncRepackObjects(cfg)
	}

	mm_params := &GoGitRepositoryMockRepackObjectsParams{cfg}

	// Record call args
	mmRepackObjects.RepackObjectsMock.mutex.Lock()
	mmRepackObjects.RepackObjectsMock.callArgs = append(mmRepackObjects.RepackObjectsMock.callArgs, mm_params)
	mmRepackObjects.RepackObjectsMock.mutex.Unlock()

	for _, e := range mmRepackObjects.RepackObjectsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRepackObjects.RepackObjectsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRepackObjects.RepackObjectsMock.defaultExpectation.Counter, 1)
		mm_want := mmRepackObjects.RepackObjectsMock.defaultExpectation.params
		mm_got := GoGitRepositoryMockRepackObjectsParams{cfg}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRepackObjects.t.Errorf("GoGitRepositoryMock.RepackObjects got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRepackObjects.RepackObjectsMock.defaultExpectation.results
		if mm_results == nil {
			mmRepackObjects.t.Fatal("No results are set for the GoGitRepositoryMock.RepackObjects")
		}
		return (*mm_results).err
	}
	if mmRepackObjects.funcRepackObjects != nil {
		return mmRepackObjects.funcRepackObjects(cfg)
	}
	mmRepackObjects.t.Fatalf("Unexpected call to GoGitRepositoryMock.RepackObjects. %v", cfg)
	return
}

// RepackObjectsAfterCounter returns a count of finished GoGitRepositoryMock.RepackObjects invocations
func (mmRepackObjects *GoGitRepositoryMock) RepackObjectsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRepackObjects.afterRepackObjectsCounter)
}

// RepackObjectsBeforeCounter returns a count of GoGitRepositoryMock.RepackObjects invocations
func (mmRepackObjects *GoGitRepositoryMock) RepackObjectsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRepackObjects.beforeRepackObjectsCounter)
}

// Calls returns a list of arguments used in each call to GoGitRepositoryMock.RepackObjects.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRepackObjects *mGoGitRepositoryMockRepackObjects) Calls() []*GoGitRepositoryMockRepackObjectsParams {
	mmRepackObjects.mutex.RLock()

	argCopy := make([]*GoGitRepositoryMockRepackObjectsParams, len(mmRepackObjects.callArgs))
	copy(argCopy, mmRepackObjects.callArgs)

	mmRepackObjects.mutex.RUnlock()

	return argCopy
}

// MinimockRepackObjectsDone returns true if the count of the RepackObjects invocations corresponds
// the number of defined expectations
func (m *GoGitRepositoryMock) MinimockRepackObjectsDone() bool {
	for _, e := range m.RepackObjectsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RepackObjectsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRepackObjectsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRepackObjects != nil && mm_atomic.LoadUint64(&m.afterRepackObjectsCounter) < 1 {
		return false
	}
	return true
}

// MinimockRepackObjectsInspect logs each unmet expectation
func (m *GoGitRepositoryMock) MinimockRepackObjectsInspect() {
	for _, e := range m.RepackObjectsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GoGitRepositoryMock.RepackObjects with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RepackObjectsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRepackObjectsCounter) < 1 {
		if m.RepackObjectsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GoGitRepositoryMock.RepackObjects")
		} else {
			m.t.Errorf("Expected call to GoGitRepositoryMock.RepackObjects with params: %#v", *m.RepackObjectsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRepackObjects != nil && mm_atomic.LoadUint64(&m.afterRepackObjectsCounter) < 1 {
		m.t.Error("Expected call to GoGitRepositoryMock.RepackObjects")
	}
}

type mGoGitRepositoryMockResolveRevision struct {
	mock               *GoGitRepositoryMock
	defaultExpectation *GoGitRepositoryMockResolveRevisionExpectation
	expectations       []*GoGitRepositoryMockResolveRevisionExpectation

	callArgs []*GoGitRepositoryMockResolveRevisionParams
	mutex    sync.RWMutex
}

// GoGitRepositoryMockResolveRevisionExpectation specifies expectation struct of the GoGitRepository.ResolveRevision
type GoGitRepositoryMockResolveRevisionExpectation struct {
	mock    *GoGitRepositoryMock
	params  *GoGitRepositoryMockResolveRevisionParams
	results *GoGitRepositoryMockResolveRevisionResults
	Counter uint64
}

// GoGitRepositoryMockResolveRevisionParams contains parameters of the GoGitRepository.ResolveRevision
type GoGitRepositoryMockResolveRevisionParams struct {
	rev plumbing.Revision
}

// GoGitRepositoryMockResolveRevisionResults contains results of the GoGitRepository.ResolveRevision
type GoGitRepositoryMockResolveRevisionResults struct {
	hp1 *plumbing.Hash
	err error
}

// Expect sets up expected params for GoGitRepository.ResolveRevision
func (mmResolveRevision *mGoGitRepositoryMockResolveRevision) Expect(rev plumbing.Revision) *mGoGitRepositoryMockResolveRevision {
	if mmResolveRevision.mock.funcResolveRevision != nil {
		mmResolveRevision.mock.t.Fatalf("GoGitRepositoryMock.ResolveRevision mock is already set by Set")
	}

	if mmResolveRevision.defaultExpectation == nil {
		mmResolveRevision.defaultExpectation = &GoGitRepositoryMockResolveRevisionExpectation{}
	}

	mmResolveRevision.defaultExpectation.params = &GoGitRepositoryMockResolveRevisionParams{rev}
	for _, e := range mmResolveRevision.expectations {
		if minimock.Equal(e.params, mmResolveRevision.defaultExpectation.params) {
			mmResolveRevision.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmResolveRevision.defaultExpectation.params)
		}
	}

	return mmResolveRevision
}

// Inspect accepts an inspector function that has same arguments as the GoGitRepository.ResolveRevision
func (mmResolveRevision *mGoGitRepositoryMockResolveRevision) Inspect(f func(rev plumbing.Revision)) *mGoGitRepositoryMockResolveRevision {
	if mmResolveRevision.mock.inspectFuncResolveRevision != nil {
		mmResolveRevision.mock.t.Fatalf("Inspect function is already set for GoGitRepositoryMock.ResolveRevision")
	}

	mmResolveRevision.mock.inspectFuncResolveRevision = f

	return mmResolveRevision
}

// Return sets up results that will be returned by GoGitRepository.ResolveRevision
func (mmResolveRevision *mGoGitRepositoryMockResolveRevision) Return(hp1 *plumbing.Hash, err error) *GoGitRepositoryMock {
	if mmResolveRevision.mock.funcResolveRevision != nil {
		mmResolveRevision.mock.t.Fatalf("GoGitRepositoryMock.ResolveRevision mock is already set by Set")
	}

	if mmResolveRevision.defaultExpectation == nil {
		mmResolveRevision.defaultExpectation = &GoGitRepositoryMockResolveRevisionExpectation{mock: mmResolveRevision.mock}
	}
	mmResolveRevision.defaultExpectation.results = &GoGitRepositoryMockResolveRevisionResults{hp1, err}
	return mmResolveRevision.mock
}

// Set uses given function f to mock the GoGitRepository.ResolveRevision method
func (mmResolveRevision *mGoGitRepositoryMockResolveRevision) Set(f func(rev plumbing.Revision) (hp1 *plumbing.Hash, err error)) *GoGitRepositoryMock {
	if mmResolveRevision.defaultExpectation != nil {
		mmResolveRevision.mock.t.Fatalf("Default expectation is already set for the GoGitRepository.ResolveRevision method")
	}

	if len(mmResolveRevision.expectations) > 0 {
		mmResolveRevision.mock.t.Fatalf("Some expectations are already set for the GoGitRepository.ResolveRevision method")
	}

	mmResolveRevision.mock.funcResolveRevision = f
	return mmResolveRevision.mock
}

// When sets expectation for the GoGitRepository.ResolveRevision which will trigger the result defined by the following
// Then helper
func (mmResolveRevision *mGoGitRepositoryMockResolveRevision) When(rev plumbing.Revision) *GoGitRepositoryMockResolveRevisionExpectation {
	if mmResolveRevision.mock.funcResolveRevision != nil {
		mmResolveRevision.mock.t.Fatalf("GoGitRepositoryMock.ResolveRevision mock is already set by Set")
	}

	expectation := &GoGitRepositoryMockResolveRevisionExpectation{
		mock:   mmResolveRevision.mock,
		params: &GoGitRepositoryMockResolveRevisionParams{rev},
	}
	mmResolveRevision.expectations = append(mmResolveRevision.expectations, expectation)
	return expectation
}

// Then sets up GoGitRepository.ResolveRevision return parameters for the expectation previously defined by the When method
func (e *GoGitRepositoryMockResolveRevisionExpectation) Then(hp1 *plumbing.Hash, err error) *GoGitRepositoryMock {
	e.results = &GoGitRepositoryMockResolveRevisionResults{hp1, err}
	return e.mock
}

// ResolveRevision implements vcs.GoGitRepository
func (mmResolveRevision *GoGitRepositoryMock) ResolveRevision(rev plumbing.Revision) (hp1 *plumbing.Hash, err error) {
	mm_atomic.AddUint64(&mmResolveRevision.beforeResolveRevisionCounter, 1)
	defer mm_atomic.AddUint64(&mmResolveRevision.afterResolveRevisionCounter, 1)

	if mmResolveRevision.inspectFuncResolveRevision != nil {
		mmResolveRevision.inspectFuncResolveRevision(rev)
	}

	mm_params := &GoGitRepositoryMockResolveRevisionParams{rev}

	// Record call args
	mmResolveRevision.ResolveRevisionMock.mutex.Lock()
	mmResolveRevision.ResolveRevisionMock.callArgs = append(mmResolveRevision.ResolveRevisionMock.callArgs, mm_params)
	mmResolveRevision.ResolveRevisionMock.mutex.Unlock()

	for _, e := range mmResolveRevision.ResolveRevisionMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.hp1, e.results.err
		}
	}

	if mmResolveRevision.ResolveRevisionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmResolveRevision.ResolveRevisionMock.defaultExpectation.Counter, 1)
		mm_want := mmResolveRevision.ResolveRevisionMock.defaultExpectation.params
		mm_got := GoGitRepositoryMockResolveRevisionParams{rev}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmResolveRevision.t.Errorf("GoGitRepositoryMock.ResolveRevision got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmResolveRevision.ResolveRevisionMock.defaultExpectation.results
		if mm_results == nil {
			mmResolveRevision.t.Fatal("No results are set for the GoGitRepositoryMock.ResolveRevision")
		}
		return (*mm_results).hp1, (*mm_results).err
	}
	if mmResolveRevision.funcResolveRevision != nil {
		return mmResolveRevision.funcResolveRevision(rev)
	}
	mmResolveRevision.t.Fatalf("Unexpected call to GoGitRepositoryMock.ResolveRevision. %v", rev)
	return
}

// ResolveRevisionAfterCounter returns a count of finished GoGitRepositoryMock.ResolveRevision invocations
func (mmResolveRevision *GoGitRepositoryMock) ResolveRevisionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmResolveRevision.afterResolveRevisionCounter)
}

// ResolveRevisionBeforeCounter returns a count of GoGitRepositoryMock.ResolveRevision invocations
func (mmResolveRevision *GoGitRepositoryMock) ResolveRevisionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmResolveRevision.beforeResolveRevisionCounter)
}

// Calls returns a list of arguments used in each call to GoGitRepositoryMock.ResolveRevision.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmResolveRevision *mGoGitRepositoryMockResolveRevision) Calls() []*GoGitRepositoryMockResolveRevisionParams {
	mmResolveRevision.mutex.RLock()

	argCopy := make([]*GoGitRepositoryMockResolveRevisionParams, len(mmResolveRevision.callArgs))
	copy(argCopy, mmResolveRevision.callArgs)

	mmResolveRevision.mutex.RUnlock()

	return argCopy
}

// MinimockResolveRevisionDone returns true if the count of the ResolveRevision invocations corresponds
// the number of defined expectations
func (m *GoGitRepositoryMock) MinimockResolveRevisionDone() bool {
	for _, e := range m.ResolveRevisionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ResolveRevisionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterResolveRevisionCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcResolveRevision != nil && mm_atomic.LoadUint64(&m.afterResolveRevisionCounter) < 1 {
		return false
	}
	return true
}

// MinimockResolveRevisionInspect logs each unmet expectation
func (m *GoGitRepositoryMock) MinimockResolveRevisionInspect() {
	for _, e := range m.ResolveRevisionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GoGitRepositoryMock.ResolveRevision with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ResolveRevisionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterResolveRevisionCounter) < 1 {
		if m.ResolveRevisionMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GoGitRepositoryMock.ResolveRevision")
		} else {
			m.t.Errorf("Expected call to GoGitRepositoryMock.ResolveRevision with params: %#v", *m.ResolveRevisionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcResolveRevision != nil && mm_atomic.LoadUint64(&m.afterResolveRevisionCounter) < 1 {
		m.t.Error("Expected call to GoGitRepositoryMock.ResolveRevision")
	}
}

type mGoGitRepositoryMockSetConfig struct {
	mock               *GoGitRepositoryMock
	defaultExpectation *GoGitRepositoryMockSetConfigExpectation
	expectations       []*GoGitRepositoryMockSetConfigExpectation

	callArgs []*GoGitRepositoryMockSetConfigParams
	mutex    sync.RWMutex
}

// GoGitRepositoryMockSetConfigExpectation specifies expectation struct of the GoGitRepository.SetConfig
type GoGitRepositoryMockSetConfigExpectation struct {
	mock    *GoGitRepositoryMock
	params  *GoGitRepositoryMockSetConfigParams
	results *GoGitRepositoryMockSetConfigResults
	Counter uint64
}

// GoGitRepositoryMockSetConfigParams contains parameters of the GoGitRepository.SetConfig
type GoGitRepositoryMockSetConfigParams struct {
	cfg *config.Config
}

// GoGitRepositoryMockSetConfigResults contains results of the GoGitRepository.SetConfig
type GoGitRepositoryMockSetConfigResults struct {
	err error
}

// Expect sets up expected params for GoGitRepository.SetConfig
func (mmSetConfig *mGoGitRepositoryMockSetConfig) Expect(cfg *config.Config) *mGoGitRepositoryMockSetConfig {
	if mmSetConfig.mock.funcSetConfig != nil {
		mmSetConfig.mock.t.Fatalf("GoGitRepositoryMock.SetConfig mock is already set by Set")
	}

	if mmSetConfig.defaultExpectation == nil {
		mmSetConfig.defaultExpectation = &GoGitRepositoryMockSetConfigExpectation{}
	}

	mmSetConfig.defaultExpectation.params = &GoGitRepositoryMockSetConfigParams{cfg}
	for _, e := range mmSetConfig.expectations {
		if minimock.Equal(e.params, mmSetConfig.defaultExpectation.params) {
			mmSetConfig.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetConfig.defaultExpectation.params)
		}
	}

	return mmSetConfig
}

// Inspect accepts an inspector function that has same arguments as the GoGitRepository.SetConfig
func (mmSetConfig *mGoGitRepositoryMockSetConfig) Inspect(f func(cfg *config.Config)) *mGoGitRepositoryMockSetConfig {
	if mmSetConfig.mock.inspectFuncSetConfig != nil {
		mmSetConfig.mock.t.Fatalf("Inspect function is already set for GoGitRepositoryMock.SetConfig")
	}

	mmSetConfig.mock.inspectFuncSetConfig = f

	return mmSetConfig
}

// Return sets up results that will be returned by GoGitRepository.SetConfig
func (mmSetConfig *mGoGitRepositoryMockSetConfig) Return(err error) *GoGitRepositoryMock {
	if mmSetConfig.mock.funcSetConfig != nil {
		mmSetConfig.mock.t.Fatalf("GoGitRepositoryMock.SetConfig mock is already set by Set")
	}

	if mmSetConfig.defaultExpectation == nil {
		mmSetConfig.defaultExpectation = &GoGitRepositoryMockSetConfigExpectation{mock: mmSetConfig.mock}
	}
	mmSetConfig.defaultExpectation.results = &GoGitRepositoryMockSetConfigResults{err}
	return mmSetConfig.mock
}

// Set uses given function f to mock the GoGitRepository.SetConfig method
func (mmSetConfig *mGoGitRepositoryMockSetConfig) Set(f func(cfg *config.Config) (err error)) *GoGitRepositoryMock {
	if mmSetConfig.defaultExpectation != nil {
		mmSetConfig.mock.t.Fatalf("Default expectation is already set for the GoGitRepository.SetConfig method")
	}

	if len(mmSetConfig.expectations) > 0 {
		mmSetConfig.mock.t.Fatalf("Some expectations are already set for the GoGitRepository.SetConfig method")
	}

	mmSetConfig.mock.funcSetConfig = f
	return mmSetConfig.mock
}

// When sets expectation for the GoGitRepository.SetConfig which will trigger the result defined by the following
// Then helper
func (mmSetConfig *mGoGitRepositoryMockSetConfig) When(cfg *config.Config) *GoGitRepositoryMockSetConfigExpectation {
	if mmSetConfig.mock.funcSetConfig != nil {
		mmSetConfig.mock.t.Fatalf("GoGitRepositoryMock.SetConfig mock is already set by Set")
	}

	expectation := &GoGitRepositoryMockSetConfigExpectation{
		mock:   mmSetConfig.mock,
		params: &GoGitRepositoryMockSetConfigParams{cfg},
	}
	mmSetConfig.expectations = append(mmSetConfig.expectations, expectation)
	return expectation
}

// Then sets up GoGitRepository.SetConfig return parameters for the expectation previously defined by the When method
func (e *GoGitRepositoryMockSetConfigExpectation) Then(err error) *GoGitRepositoryMock {
	e.results = &GoGitRepositoryMockSetConfigResults{err}
	return e.mock
}

// SetConfig implements vcs.GoGitRepository
func (mmSetConfig *GoGitRepositoryMock) SetConfig(cfg *config.Config) (err error) {
	mm_atomic.AddUint64(&mmSetConfig.beforeSetConfigCounter, 1)
	defer mm_atomic.AddUint64(&mmSetConfig.afterSetConfigCounter, 1)

	if mmSetConfig.inspectFuncSetConfig != nil {
		mmSetConfig.inspectFuncSetConfig(cfg)
	}

	mm_params := &GoGitRepositoryMockSetConfigParams{cfg}

	// Record call args
	mmSetConfig.SetConfigMock.mutex.Lock()
	mmSetConfig.SetConfigMock.callArgs = append(mmSetConfig.SetConfigMock.callArgs, mm_params)
	mmSetConfig.SetConfigMock.mutex.Unlock()

	for _, e := range mmSetConfig.SetConfigMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetConfig.SetConfigMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetConfig.SetConfigMock.defaultExpectation.Counter, 1)
		mm_want := mmSetConfig.SetConfigMock.defaultExpectation.params
		mm_got := GoGitRepositoryMockSetConfigParams{cfg}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetConfig.t.Errorf("GoGitRepositoryMock.SetConfig got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetConfig.SetConfigMock.defaultExpectation.results
		if mm_results == nil {
			mmSetConfig.t.Fatal("No results are set for the GoGitRepositoryMock.SetConfig")
		}
		return (*mm_results).err
	}
	if mmSetConfig.funcSetConfig != nil {
		return mmSetConfig.funcSetConfig(cfg)
	}
	mmSetConfig.t.Fatalf("Unexpected call to GoGitRepositoryMock.SetConfig. %v", cfg)
	return
}

// SetConfigAfterCounter returns a count of finished GoGitRepositoryMock.SetConfig invocations
func (mmSetConfig *GoGitRepositoryMock) SetConfigAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetConfig.afterSetConfigCounter)
}

// SetConfigBeforeCounter returns a count of GoGitRepositoryMock.SetConfig invocations
func (mmSetConfig *GoGitRepositoryMock) SetConfigBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetConfig.beforeSetConfigCounter)
}

// Calls returns a list of arguments used in each call to GoGitRepositoryMock.SetConfig.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetConfig *mGoGitRepositoryMockSetConfig) Calls() []*GoGitRepositoryMockSetConfigParams {
	mmSetConfig.mutex.RLock()

	argCopy := make([]*GoGitRepositoryMockSetConfigParams, len(mmSetConfig.callArgs))
	copy(argCopy, mmSetConfig.callArgs)

	mmSetConfig.mutex.RUnlock()

	return argCopy
}

// MinimockSetConfigDone returns true if the count of the SetConfig invocations corresponds
// the number of defined expectations
func (m *GoGitRepositoryMock) MinimockSetConfigDone() bool {
	for _, e := range m.SetConfigMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetConfigMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetConfigCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetConfig != nil && mm_atomic.LoadUint64(&m.afterSetConfigCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetConfigInspect logs each unmet expectation
func (m *GoGitRepositoryMock) MinimockSetConfigInspect() {
	for _, e := range m.SetConfigMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GoGitRepositoryMock.SetConfig with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetConfigMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetConfigCounter) < 1 {
		if m.SetConfigMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GoGitRepositoryMock.SetConfig")
		} else {
			m.t.Errorf("Expected call to GoGitRepositoryMock.SetConfig with params: %#v", *m.SetConfigMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetConfig != nil && mm_atomic.LoadUint64(&m.afterSetConfigCounter) < 1 {
		m.t.Error("Expected call to GoGitRepositoryMock.SetConfig")
	}
}

type mGoGitRepositoryMockTag struct {
	mock               *GoGitRepositoryMock
	defaultExpectation *GoGitRepositoryMockTagExpectation
	expectations       []*GoGitRepositoryMockTagExpectation

	callArgs []*GoGitRepositoryMockTagParams
	mutex    sync.RWMutex
}

// GoGitRepositoryMockTagExpectation specifies expectation struct of the GoGitRepository.Tag
type GoGitRepositoryMockTagExpectation struct {
	mock    *GoGitRepositoryMock
	params  *GoGitRepositoryMockTagParams
	results *GoGitRepositoryMockTagResults
	Counter uint64
}

// GoGitRepositoryMockTagParams contains parameters of the GoGitRepository.Tag
type GoGitRepositoryMockTagParams struct {
	name string
}

// GoGitRepositoryMockTagResults contains results of the GoGitRepository.Tag
type GoGitRepositoryMockTagResults struct {
	rp1 *plumbing.Reference
	err error
}

// Expect sets up expected params for GoGitRepository.Tag
func (mmTag *mGoGitRepositoryMockTag) Expect(name string) *mGoGitRepositoryMockTag {
	if mmTag.mock.funcTag != nil {
		mmTag.mock.t.Fatalf("GoGitRepositoryMock.Tag mock is already set by Set")
	}

	if mmTag.defaultExpectation == nil {
		mmTag.defaultExpectation = &GoGitRepositoryMockTagExpectation{}
	}

	mmTag.defaultExpectation.params = &GoGitRepositoryMockTagParams{name}
	for _, e := range mmTag.expectations {
		if minimock.Equal(e.params, mmTag.defaultExpectation.params) {
			mmTag.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmTag.defaultExpectation.params)
		}
	}

	return mmTag
}

// Inspect accepts an inspector function that has same arguments as the GoGitRepository.Tag
func (mmTag *mGoGitRepositoryMockTag) Inspect(f func(name string)) *mGoGitRepositoryMockTag {
	if mmTag.mock.inspectFuncTag != nil {
		mmTag.mock.t.Fatalf("Inspect function is already set for GoGitRepositoryMock.Tag")
	}

	mmTag.mock.inspectFuncTag = f

	return mmTag
}

// Return sets up results that will be returned by GoGitRepository.Tag
func (mmTag *mGoGitRepositoryMockTag) Return(rp1 *plumbing.Reference, err error) *GoGitRepositoryMock {
	if mmTag.mock.funcTag != nil {
		mmTag.mock.t.Fatalf("GoGitRepositoryMock.Tag mock is already set by Set")
	}

	if mmTag.defaultExpectation == nil {
		mmTag.defaultExpectation = &GoGitRepositoryMockTagExpectation{mock: mmTag.mock}
	}
	mmTag.defaultExpectation.results = &GoGitRepositoryMockTagResults{rp1, err}
	return mmTag.mock
}

// Set uses given function f to mock the GoGitRepository.Tag method
func (mmTag *mGoGitRepositoryMockTag) Set(f func(name string) (rp1 *plumbing.Reference, err error)) *GoGitRepositoryMock {
	if mmTag.defaultExpectation != nil {
		mmTag.mock.t.Fatalf("Default expectation is already set for the GoGitRepository.Tag method")
	}

	if len(mmTag.expectations) > 0 {
		mmTag.mock.t.Fatalf("Some expectations are already set for the GoGitRepository.Tag method")
	}

	mmTag.mock.funcTag = f
	return mmTag.mock
}

// When sets expectation for the GoGitRepository.Tag which will trigger the result defined by the following
// Then helper
func (mmTag *mGoGitRepositoryMockTag) When(name string) *GoGitRepositoryMockTagExpectation {
	if mmTag.mock.funcTag != nil {
		mmTag.mock.t.Fatalf("GoGitRepositoryMock.Tag mock is already set by Set")
	}

	expectation := &GoGitRepositoryMockTagExpectation{
		mock:   mmTag.mock,
		params: &GoGitRepositoryMockTagParams{name},
	}
	mmTag.expectations = append(mmTag.expectations, expectation)
	return expectation
}

// Then sets up GoGitRepository.Tag return parameters for the expectation previously defined by the When method
func (e *GoGitRepositoryMockTagExpectation) Then(rp1 *plumbing.Reference, err error) *GoGitRepositoryMock {
	e.results = &GoGitRepositoryMockTagResults{rp1, err}
	return e.mock
}

// Tag implements vcs.GoGitRepository
func (mmTag *GoGitRepositoryMock) Tag(name string) (rp1 *plumbing.Reference, err error) {
	mm_atomic.AddUint64(&mmTag.beforeTagCounter, 1)
	defer mm_atomic.AddUint64(&mmTag.afterTagCounter, 1)

	if mmTag.inspectFuncTag != nil {
		mmTag.inspectFuncTag(name)
	}

	mm_params := &GoGitRepositoryMockTagParams{name}

	// Record call args
	mmTag.TagMock.mutex.Lock()
	mmTag.TagMock.callArgs = append(mmTag.TagMock.callArgs, mm_params)
	mmTag.TagMock.mutex.Unlock()

	for _, e := range mmTag.TagMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.rp1, e.results.err
		}
	}

	if mmTag.TagMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTag.TagMock.defaultExpectation.Counter, 1)
		mm_want := mmTag.TagMock.defaultExpectation.params
		mm_got := GoGitRepositoryMockTagParams{name}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmTag.t.Errorf("GoGitRepositoryMock.Tag got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmTag.TagMock.defaultExpectation.results
		if mm_results == nil {
			mmTag.t.Fatal("No results are set for the GoGitRepositoryMock.Tag")
		}
		return (*mm_results).rp1, (*mm_results).err
	}
	if mmTag.funcTag != nil {
		return mmTag.funcTag(name)
	}
	mmTag.t.Fatalf("Unexpected call to GoGitRepositoryMock.Tag. %v", name)
	return
}

// TagAfterCounter returns a count of finished GoGitRepositoryMock.Tag invocations
func (mmTag *GoGitRepositoryMock) TagAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTag.afterTagCounter)
}

// TagBeforeCounter returns a count of GoGitRepositoryMock.Tag invocations
func (mmTag *GoGitRepositoryMock) TagBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTag.beforeTagCounter)
}

// Calls returns a list of arguments used in each call to GoGitRepositoryMock.Tag.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmTag *mGoGitRepositoryMockTag) Calls() []*GoGitRepositoryMockTagParams {
	mmTag.mutex.RLock()

	argCopy := make([]*GoGitRepositoryMockTagParams, len(mmTag.callArgs))
	copy(argCopy, mmTag.callArgs)

	mmTag.mutex.RUnlock()

	return argCopy
}

// MinimockTagDone returns true if the count of the Tag invocations corresponds
// the number of defined expectations
func (m *GoGitRepositoryMock) MinimockTagDone() bool {
	for _, e := range m.TagMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TagMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTagCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTag != nil && mm_atomic.LoadUint64(&m.afterTagCounter) < 1 {
		return false
	}
	return true
}

// MinimockTagInspect logs each unmet expectation
func (m *GoGitRepositoryMock) MinimockTagInspect() {
	for _, e := range m.TagMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GoGitRepositoryMock.Tag with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TagMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTagCounter) < 1 {
		if m.TagMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GoGitRepositoryMock.Tag")
		} else {
			m.t.Errorf("Expected call to GoGitRepositoryMock.Tag with params: %#v", *m.TagMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTag != nil && mm_atomic.LoadUint64(&m.afterTagCounter) < 1 {
		m.t.Error("Expected call to GoGitRepositoryMock.Tag")
	}
}

type mGoGitRepositoryMockTagObject struct {
	mock               *GoGitRepositoryMock
	defaultExpectation *GoGitRepositoryMockTagObjectExpectation
	expectations       []*GoGitRepositoryMockTagObjectExpectation

	callArgs []*GoGitRepositoryMockTagObjectParams
	mutex    sync.RWMutex
}

// GoGitRepositoryMockTagObjectExpectation specifies expectation struct of the GoGitRepository.TagObject
type GoGitRepositoryMockTagObjectExpectation struct {
	mock    *GoGitRepositoryMock
	params  *GoGitRepositoryMockTagObjectParams
	results *GoGitRepositoryMockTagObjectResults
	Counter uint64
}

// GoGitRepositoryMockTagObjectParams contains parameters of the GoGitRepository.TagObject
type GoGitRepositoryMockTagObjectParams struct {
	h plumbing.Hash
}

// GoGitRepositoryMockTagObjectResults contains results of the GoGitRepository.TagObject
type GoGitRepositoryMockTagObjectResults struct {
	tp1 *object.Tag
	err error
}

// Expect sets up expected params for GoGitRepository.TagObject
func (mmTagObject *mGoGitRepositoryMockTagObject) Expect(h plumbing.Hash) *mGoGitRepositoryMockTagObject {
	if mmTagObject.mock.funcTagObject != nil {
		mmTagObject.mock.t.Fatalf("GoGitRepositoryMock.TagObject mock is already set by Set")
	}

	if mmTagObject.defaultExpectation == nil {
		mmTagObject.defaultExpectation = &GoGitRepositoryMockTagObjectExpectation{}
	}

	mmTagObject.defaultExpectation.params = &GoGitRepositoryMockTagObjectParams{h}
	for _, e := range mmTagObject.expectations {
		if minimock.Equal(e.params, mmTagObject.defaultExpectation.params) {
			mmTagObject.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmTagObject.defaultExpectation.params)
		}
	}

	return mmTagObject
}

// Inspect accepts an inspector function that has same arguments as the GoGitRepository.TagObject
func (mmTagObject *mGoGitRepositoryMockTagObject) Inspect(f func(h plumbing.Hash)) *mGoGitRepositoryMockTagObject {
	if mmTagObject.mock.inspectFuncTagObject != nil {
		mmTagObject.mock.t.Fatalf("Inspect function is already set for GoGitRepositoryMock.TagObject")
	}

	mmTagObject.mock.inspectFuncTagObject = f

	return mmTagObject
}

// Return sets up results that will be returned by GoGitRepository.TagObject
func (mmTagObject *mGoGitRepositoryMockTagObject) Return(tp1 *object.Tag, err error) *GoGitRepositoryMock {
	if mmTagObject.mock.funcTagObject != nil {
		mmTagObject.mock.t.Fatalf("GoGitRepositoryMock.TagObject mock is already set by Set")
	}

	if mmTagObject.defaultExpectation == nil {
		mmTagObject.defaultExpectation = &GoGitRepositoryMockTagObjectExpectation{mock: mmTagObject.mock}
	}
	mmTagObject.defaultExpectation.results = &GoGitRepositoryMockTagObjectResults{tp1, err}
	return mmTagObject.mock
}

// Set uses given function f to mock the GoGitRepository.TagObject method
func (mmTagObject *mGoGitRepositoryMockTagObject) Set(f func(h plumbing.Hash) (tp1 *object.Tag, err error)) *GoGitRepositoryMock {
	if mmTagObject.defaultExpectation != nil {
		mmTagObject.mock.t.Fatalf("Default expectation is already set for the GoGitRepository.TagObject method")
	}

	if len(mmTagObject.expectations) > 0 {
		mmTagObject.mock.t.Fatalf("Some expectations are already set for the GoGitRepository.TagObject method")
	}

	mmTagObject.mock.funcTagObject = f
	return mmTagObject.mock
}

// When sets expectation for the GoGitRepository.TagObject which will trigger the result defined by the following
// Then helper
func (mmTagObject *mGoGitRepositoryMockTagObject) When(h plumbing.Hash) *GoGitRepositoryMockTagObjectExpectation {
	if mmTagObject.mock.funcTagObject != nil {
		mmTagObject.mock.t.Fatalf("GoGitRepositoryMock.TagObject mock is already set by Set")
	}

	expectation := &GoGitRepositoryMockTagObjectExpectation{
		mock:   mmTagObject.mock,
		params: &GoGitRepositoryMockTagObjectParams{h},
	}
	mmTagObject.expectations = append(mmTagObject.expectations, expectation)
	return expectation
}

// Then sets up GoGitRepository.TagObject return parameters for the expectation previously defined by the When method
func (e *GoGitRepositoryMockTagObjectExpectation) Then(tp1 *object.Tag, err error) *GoGitRepositoryMock {
	e.results = &GoGitRepositoryMockTagObjectResults{tp1, err}
	return e.mock
}

// TagObject implements vcs.GoGitRepository
func (mmTagObject *GoGitRepositoryMock) TagObject(h plumbing.Hash) (tp1 *object.Tag, err error) {
	mm_atomic.AddUint64(&mmTagObject.beforeTagObjectCounter, 1)
	defer mm_atomic.AddUint64(&mmTagObject.afterTagObjectCounter, 1)

	if mmTagObject.inspectFuncTagObject != nil {
		mmTagObject.inspectFuncTagObject(h)
	}

	mm_params := &GoGitRepositoryMockTagObjectParams{h}

	// Record call args
	mmTagObject.TagObjectMock.mutex.Lock()
	mmTagObject.TagObjectMock.callArgs = append(mmTagObject.TagObjectMock.callArgs, mm_params)
	mmTagObject.TagObjectMock.mutex.Unlock()

	for _, e := range mmTagObject.TagObjectMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.tp1, e.results.err
		}
	}

	if mmTagObject.TagObjectMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTagObject.TagObjectMock.defaultExpectation.Counter, 1)
		mm_want := mmTagObject.TagObjectMock.defaultExpectation.params
		mm_got := GoGitRepositoryMockTagObjectParams{h}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmTagObject.t.Errorf("GoGitRepositoryMock.TagObject got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmTagObject.TagObjectMock.defaultExpectation.results
		if mm_results == nil {
			mmTagObject.t.Fatal("No results are set for the GoGitRepositoryMock.TagObject")
		}
		return (*mm_results).tp1, (*mm_results).err
	}
	if mmTagObject.funcTagObject != nil {
		return mmTagObject.funcTagObject(h)
	}
	mmTagObject.t.Fatalf("Unexpected call to GoGitRepositoryMock.TagObject. %v", h)
	return
}

// TagObjectAfterCounter returns a count of finished GoGitRepositoryMock.TagObject invocations
func (mmTagObject *GoGitRepositoryMock) TagObjectAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTagObject.afterTagObjectCounter)
}

// TagObjectBeforeCounter returns a count of GoGitRepositoryMock.TagObject invocations
func (mmTagObject *GoGitRepositoryMock) TagObjectBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTagObject.beforeTagObjectCounter)
}

// Calls returns a list of arguments used in each call to GoGitRepositoryMock.TagObject.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmTagObject *mGoGitRepositoryMockTagObject) Calls() []*GoGitRepositoryMockTagObjectParams {
	mmTagObject.mutex.RLock()

	argCopy := make([]*GoGitRepositoryMockTagObjectParams, len(mmTagObject.callArgs))
	copy(argCopy, mmTagObject.callArgs)

	mmTagObject.mutex.RUnlock()

	return argCopy
}

// MinimockTagObjectDone returns true if the count of the TagObject invocations corresponds
// the number of defined expectations
func (m *GoGitRepositoryMock) MinimockTagObjectDone() bool {
	for _, e := range m.TagObjectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TagObjectMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTagObjectCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTagObject != nil && mm_atomic.LoadUint64(&m.afterTagObjectCounter) < 1 {
		return false
	}
	return true
}

// MinimockTagObjectInspect logs each unmet expectation
func (m *GoGitRepositoryMock) MinimockTagObjectInspect() {
	for _, e := range m.TagObjectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GoGitRepositoryMock.TagObject with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TagObjectMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTagObjectCounter) < 1 {
		if m.TagObjectMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GoGitRepositoryMock.TagObject")
		} else {
			m.t.Errorf("Expected call to GoGitRepositoryMock.TagObject with params: %#v", *m.TagObjectMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTagObject != nil && mm_atomic.LoadUint64(&m.afterTagObjectCounter) < 1 {
		m.t.Error("Expected call to GoGitRepositoryMock.TagObject")
	}
}

type mGoGitRepositoryMockTagObjects struct {
	mock               *GoGitRepositoryMock
	defaultExpectation *GoGitRepositoryMockTagObjectsExpectation
	expectations       []*GoGitRepositoryMockTagObjectsExpectation
}

// GoGitRepositoryMockTagObjectsExpectation specifies expectation struct of the GoGitRepository.TagObjects
type GoGitRepositoryMockTagObjectsExpectation struct {
	mock *GoGitRepositoryMock

	results *GoGitRepositoryMockTagObjectsResults
	Counter uint64
}

// GoGitRepositoryMockTagObjectsResults contains results of the GoGitRepository.TagObjects
type GoGitRepositoryMockTagObjectsResults struct {
	tp1 *object.TagIter
	err error
}

// Expect sets up expected params for GoGitRepository.TagObjects
func (mmTagObjects *mGoGitRepositoryMockTagObjects) Expect() *mGoGitRepositoryMockTagObjects {
	if mmTagObjects.mock.funcTagObjects != nil {
		mmTagObjects.mock.t.Fatalf("GoGitRepositoryMock.TagObjects mock is already set by Set")
	}

	if mmTagObjects.defaultExpectation == nil {
		mmTagObjects.defaultExpectation = &GoGitRepositoryMockTagObjectsExpectation{}
	}

	return mmTagObjects
}

// Inspect accepts an inspector function that has same arguments as the GoGitRepository.TagObjects
func (mmTagObjects *mGoGitRepositoryMockTagObjects) Inspect(f func()) *mGoGitRepositoryMockTagObjects {
	if mmTagObjects.mock.inspectFuncTagObjects != nil {
		mmTagObjects.mock.t.Fatalf("Inspect function is already set for GoGitRepositoryMock.TagObjects")
	}

	mmTagObjects.mock.inspectFuncTagObjects = f

	return mmTagObjects
}

// Return sets up results that will be returned by GoGitRepository.TagObjects
func (mmTagObjects *mGoGitRepositoryMockTagObjects) Return(tp1 *object.TagIter, err error) *GoGitRepositoryMock {
	if mmTagObjects.mock.funcTagObjects != nil {
		mmTagObjects.mock.t.Fatalf("GoGitRepositoryMock.TagObjects mock is already set by Set")
	}

	if mmTagObjects.defaultExpectation == nil {
		mmTagObjects.defaultExpectation = &GoGitRepositoryMockTagObjectsExpectation{mock: mmTagObjects.mock}
	}
	mmTagObjects.defaultExpectation.results = &GoGitRepositoryMockTagObjectsResults{tp1, err}
	return mmTagObjects.mock
}

// Set uses given function f to mock the GoGitRepository.TagObjects method
func (mmTagObjects *mGoGitRepositoryMockTagObjects) Set(f func() (tp1 *object.TagIter, err error)) *GoGitRepositoryMock {
	if mmTagObjects.defaultExpectation != nil {
		mmTagObjects.mock.t.Fatalf("Default expectation is already set for the GoGitRepository.TagObjects method")
	}

	if len(mmTagObjects.expectations) > 0 {
		mmTagObjects.mock.t.Fatalf("Some expectations are already set for the GoGitRepository.TagObjects method")
	}

	mmTagObjects.mock.funcTagObjects = f
	return mmTagObjects.mock
}

// TagObjects implements vcs.GoGitRepository
func (mmTagObjects *GoGitRepositoryMock) TagObjects() (tp1 *object.TagIter, err error) {
	mm_atomic.AddUint64(&mmTagObjects.beforeTagObjectsCounter, 1)
	defer mm_atomic.AddUint64(&mmTagObjects.afterTagObjectsCounter, 1)

	if mmTagObjects.inspectFuncTagObjects != nil {
		mmTagObjects.inspectFuncTagObjects()
	}

	if mmTagObjects.TagObjectsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTagObjects.TagObjectsMock.defaultExpectation.Counter, 1)

		mm_results := mmTagObjects.TagObjectsMock.defaultExpectation.results
		if mm_results == nil {
			mmTagObjects.t.Fatal("No results are set for the GoGitRepositoryMock.TagObjects")
		}
		return (*mm_results).tp1, (*mm_results).err
	}
	if mmTagObjects.funcTagObjects != nil {
		return mmTagObjects.funcTagObjects()
	}
	mmTagObjects.t.Fatalf("Unexpected call to GoGitRepositoryMock.TagObjects.")
	return
}

// TagObjectsAfterCounter returns a count of finished GoGitRepositoryMock.TagObjects invocations
func (mmTagObjects *GoGitRepositoryMock) TagObjectsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTagObjects.afterTagObjectsCounter)
}

// TagObjectsBeforeCounter returns a count of GoGitRepositoryMock.TagObjects invocations
func (mmTagObjects *GoGitRepositoryMock) TagObjectsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTagObjects.beforeTagObjectsCounter)
}

// MinimockTagObjectsDone returns true if the count of the TagObjects invocations corresponds
// the number of defined expectations
func (m *GoGitRepositoryMock) MinimockTagObjectsDone() bool {
	for _, e := range m.TagObjectsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TagObjectsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTagObjectsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTagObjects != nil && mm_atomic.LoadUint64(&m.afterTagObjectsCounter) < 1 {
		return false
	}
	return true
}

// MinimockTagObjectsInspect logs each unmet expectation
func (m *GoGitRepositoryMock) MinimockTagObjectsInspect() {
	for _, e := range m.TagObjectsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to GoGitRepositoryMock.TagObjects")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TagObjectsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTagObjectsCounter) < 1 {
		m.t.Error("Expected call to GoGitRepositoryMock.TagObjects")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTagObjects != nil && mm_atomic.LoadUint64(&m.afterTagObjectsCounter) < 1 {
		m.t.Error("Expected call to GoGitRepositoryMock.TagObjects")
	}
}

type mGoGitRepositoryMockTags struct {
	mock               *GoGitRepositoryMock
	defaultExpectation *GoGitRepositoryMockTagsExpectation
	expectations       []*GoGitRepositoryMockTagsExpectation
}

// GoGitRepositoryMockTagsExpectation specifies expectation struct of the GoGitRepository.Tags
type GoGitRepositoryMockTagsExpectation struct {
	mock *GoGitRepositoryMock

	results *GoGitRepositoryMockTagsResults
	Counter uint64
}

// GoGitRepositoryMockTagsResults contains results of the GoGitRepository.Tags
type GoGitRepositoryMockTagsResults struct {
	r1  storer.ReferenceIter
	err error
}

// Expect sets up expected params for GoGitRepository.Tags
func (mmTags *mGoGitRepositoryMockTags) Expect() *mGoGitRepositoryMockTags {
	if mmTags.mock.funcTags != nil {
		mmTags.mock.t.Fatalf("GoGitRepositoryMock.Tags mock is already set by Set")
	}

	if mmTags.defaultExpectation == nil {
		mmTags.defaultExpectation = &GoGitRepositoryMockTagsExpectation{}
	}

	return mmTags
}

// Inspect accepts an inspector function that has same arguments as the GoGitRepository.Tags
func (mmTags *mGoGitRepositoryMockTags) Inspect(f func()) *mGoGitRepositoryMockTags {
	if mmTags.mock.inspectFuncTags != nil {
		mmTags.mock.t.Fatalf("Inspect function is already set for GoGitRepositoryMock.Tags")
	}

	mmTags.mock.inspectFuncTags = f

	return mmTags
}

// Return sets up results that will be returned by GoGitRepository.Tags
func (mmTags *mGoGitRepositoryMockTags) Return(r1 storer.ReferenceIter, err error) *GoGitRepositoryMock {
	if mmTags.mock.funcTags != nil {
		mmTags.mock.t.Fatalf("GoGitRepositoryMock.Tags mock is already set by Set")
	}

	if mmTags.defaultExpectation == nil {
		mmTags.defaultExpectation = &GoGitRepositoryMockTagsExpectation{mock: mmTags.mock}
	}
	mmTags.defaultExpectation.results = &GoGitRepositoryMockTagsResults{r1, err}
	return mmTags.mock
}

// Set uses given function f to mock the GoGitRepository.Tags method
func (mmTags *mGoGitRepositoryMockTags) Set(f func() (r1 storer.ReferenceIter, err error)) *GoGitRepositoryMock {
	if mmTags.defaultExpectation != nil {
		mmTags.mock.t.Fatalf("Default expectation is already set for the GoGitRepository.Tags method")
	}

	if len(mmTags.expectations) > 0 {
		mmTags.mock.t.Fatalf("Some expectations are already set for the GoGitRepository.Tags method")
	}

	mmTags.mock.funcTags = f
	return mmTags.mock
}

// Tags implements vcs.GoGitRepository
func (mmTags *GoGitRepositoryMock) Tags() (r1 storer.ReferenceIter, err error) {
	mm_atomic.AddUint64(&mmTags.beforeTagsCounter, 1)
	defer mm_atomic.AddUint64(&mmTags.afterTagsCounter, 1)

	if mmTags.inspectFuncTags != nil {
		mmTags.inspectFuncTags()
	}

	if mmTags.TagsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTags.TagsMock.defaultExpectation.Counter, 1)

		mm_results := mmTags.TagsMock.defaultExpectation.results
		if mm_results == nil {
			mmTags.t.Fatal("No results are set for the GoGitRepositoryMock.Tags")
		}
		return (*mm_results).r1, (*mm_results).err
	}
	if mmTags.funcTags != nil {
		return mmTags.funcTags()
	}
	mmTags.t.Fatalf("Unexpected call to GoGitRepositoryMock.Tags.")
	return
}

// TagsAfterCounter returns a count of finished GoGitRepositoryMock.Tags invocations
func (mmTags *GoGitRepositoryMock) TagsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTags.afterTagsCounter)
}

// TagsBeforeCounter returns a count of GoGitRepositoryMock.Tags invocations
func (mmTags *GoGitRepositoryMock) TagsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTags.beforeTagsCounter)
}

// MinimockTagsDone returns true if the count of the Tags invocations corresponds
// the number of defined expectations
func (m *GoGitRepositoryMock) MinimockTagsDone() bool {
	for _, e := range m.TagsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TagsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTagsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTags != nil && mm_atomic.LoadUint64(&m.afterTagsCounter) < 1 {
		return false
	}
	return true
}

// MinimockTagsInspect logs each unmet expectation
func (m *GoGitRepositoryMock) MinimockTagsInspect() {
	for _, e := range m.TagsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to GoGitRepositoryMock.Tags")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TagsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTagsCounter) < 1 {
		m.t.Error("Expected call to GoGitRepositoryMock.Tags")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTags != nil && mm_atomic.LoadUint64(&m.afterTagsCounter) < 1 {
		m.t.Error("Expected call to GoGitRepositoryMock.Tags")
	}
}

type mGoGitRepositoryMockTreeObject struct {
	mock               *GoGitRepositoryMock
	defaultExpectation *GoGitRepositoryMockTreeObjectExpectation
	expectations       []*GoGitRepositoryMockTreeObjectExpectation

	callArgs []*GoGitRepositoryMockTreeObjectParams
	mutex    sync.RWMutex
}

// GoGitRepositoryMockTreeObjectExpectation specifies expectation struct of the GoGitRepository.TreeObject
type GoGitRepositoryMockTreeObjectExpectation struct {
	mock    *GoGitRepositoryMock
	params  *GoGitRepositoryMockTreeObjectParams
	results *GoGitRepositoryMockTreeObjectResults
	Counter uint64
}

// GoGitRepositoryMockTreeObjectParams contains parameters of the GoGitRepository.TreeObject
type GoGitRepositoryMockTreeObjectParams struct {
	h plumbing.Hash
}

// GoGitRepositoryMockTreeObjectResults contains results of the GoGitRepository.TreeObject
type GoGitRepositoryMockTreeObjectResults struct {
	tp1 *object.Tree
	err error
}

// Expect sets up expected params for GoGitRepository.TreeObject
func (mmTreeObject *mGoGitRepositoryMockTreeObject) Expect(h plumbing.Hash) *mGoGitRepositoryMockTreeObject {
	if mmTreeObject.mock.funcTreeObject != nil {
		mmTreeObject.mock.t.Fatalf("GoGitRepositoryMock.TreeObject mock is already set by Set")
	}

	if mmTreeObject.defaultExpectation == nil {
		mmTreeObject.defaultExpectation = &GoGitRepositoryMockTreeObjectExpectation{}
	}

	mmTreeObject.defaultExpectation.params = &GoGitRepositoryMockTreeObjectParams{h}
	for _, e := range mmTreeObject.expectations {
		if minimock.Equal(e.params, mmTreeObject.defaultExpectation.params) {
			mmTreeObject.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmTreeObject.defaultExpectation.params)
		}
	}

	return mmTreeObject
}

// Inspect accepts an inspector function that has same arguments as the GoGitRepository.TreeObject
func (mmTreeObject *mGoGitRepositoryMockTreeObject) Inspect(f func(h plumbing.Hash)) *mGoGitRepositoryMockTreeObject {
	if mmTreeObject.mock.inspectFuncTreeObject != nil {
		mmTreeObject.mock.t.Fatalf("Inspect function is already set for GoGitRepositoryMock.TreeObject")
	}

	mmTreeObject.mock.inspectFuncTreeObject = f

	return mmTreeObject
}

// Return sets up results that will be returned by GoGitRepository.TreeObject
func (mmTreeObject *mGoGitRepositoryMockTreeObject) Return(tp1 *object.Tree, err error) *GoGitRepositoryMock {
	if mmTreeObject.mock.funcTreeObject != nil {
		mmTreeObject.mock.t.Fatalf("GoGitRepositoryMock.TreeObject mock is already set by Set")
	}

	if mmTreeObject.defaultExpectation == nil {
		mmTreeObject.defaultExpectation = &GoGitRepositoryMockTreeObjectExpectation{mock: mmTreeObject.mock}
	}
	mmTreeObject.defaultExpectation.results = &GoGitRepositoryMockTreeObjectResults{tp1, err}
	return mmTreeObject.mock
}

// Set uses given function f to mock the GoGitRepository.TreeObject method
func (mmTreeObject *mGoGitRepositoryMockTreeObject) Set(f func(h plumbing.Hash) (tp1 *object.Tree, err error)) *GoGitRepositoryMock {
	if mmTreeObject.defaultExpectation != nil {
		mmTreeObject.mock.t.Fatalf("Default expectation is already set for the GoGitRepository.TreeObject method")
	}

	if len(mmTreeObject.expectations) > 0 {
		mmTreeObject.mock.t.Fatalf("Some expectations are already set for the GoGitRepository.TreeObject method")
	}

	mmTreeObject.mock.funcTreeObject = f
	return mmTreeObject.mock
}

// When sets expectation for the GoGitRepository.TreeObject which will trigger the result defined by the following
// Then helper
func (mmTreeObject *mGoGitRepositoryMockTreeObject) When(h plumbing.Hash) *GoGitRepositoryMockTreeObjectExpectation {
	if mmTreeObject.mock.funcTreeObject != nil {
		mmTreeObject.mock.t.Fatalf("GoGitRepositoryMock.TreeObject mock is already set by Set")
	}

	expectation := &GoGitRepositoryMockTreeObjectExpectation{
		mock:   mmTreeObject.mock,
		params: &GoGitRepositoryMockTreeObjectParams{h},
	}
	mmTreeObject.expectations = append(mmTreeObject.expectations, expectation)
	return expectation
}

// Then sets up GoGitRepository.TreeObject return parameters for the expectation previously defined by the When method
func (e *GoGitRepositoryMockTreeObjectExpectation) Then(tp1 *object.Tree, err error) *GoGitRepositoryMock {
	e.results = &GoGitRepositoryMockTreeObjectResults{tp1, err}
	return e.mock
}

// TreeObject implements vcs.GoGitRepository
func (mmTreeObject *GoGitRepositoryMock) TreeObject(h plumbing.Hash) (tp1 *object.Tree, err error) {
	mm_atomic.AddUint64(&mmTreeObject.beforeTreeObjectCounter, 1)
	defer mm_atomic.AddUint64(&mmTreeObject.afterTreeObjectCounter, 1)

	if mmTreeObject.inspectFuncTreeObject != nil {
		mmTreeObject.inspectFuncTreeObject(h)
	}

	mm_params := &GoGitRepositoryMockTreeObjectParams{h}

	// Record call args
	mmTreeObject.TreeObjectMock.mutex.Lock()
	mmTreeObject.TreeObjectMock.callArgs = append(mmTreeObject.TreeObjectMock.callArgs, mm_params)
	mmTreeObject.TreeObjectMock.mutex.Unlock()

	for _, e := range mmTreeObject.TreeObjectMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.tp1, e.results.err
		}
	}

	if mmTreeObject.TreeObjectMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTreeObject.TreeObjectMock.defaultExpectation.Counter, 1)
		mm_want := mmTreeObject.TreeObjectMock.defaultExpectation.params
		mm_got := GoGitRepositoryMockTreeObjectParams{h}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmTreeObject.t.Errorf("GoGitRepositoryMock.TreeObject got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmTreeObject.TreeObjectMock.defaultExpectation.results
		if mm_results == nil {
			mmTreeObject.t.Fatal("No results are set for the GoGitRepositoryMock.TreeObject")
		}
		return (*mm_results).tp1, (*mm_results).err
	}
	if mmTreeObject.funcTreeObject != nil {
		return mmTreeObject.funcTreeObject(h)
	}
	mmTreeObject.t.Fatalf("Unexpected call to GoGitRepositoryMock.TreeObject. %v", h)
	return
}

// TreeObjectAfterCounter returns a count of finished GoGitRepositoryMock.TreeObject invocations
func (mmTreeObject *GoGitRepositoryMock) TreeObjectAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTreeObject.afterTreeObjectCounter)
}

// TreeObjectBeforeCounter returns a count of GoGitRepositoryMock.TreeObject invocations
func (mmTreeObject *GoGitRepositoryMock) TreeObjectBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTreeObject.beforeTreeObjectCounter)
}

// Calls returns a list of arguments used in each call to GoGitRepositoryMock.TreeObject.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmTreeObject *mGoGitRepositoryMockTreeObject) Calls() []*GoGitRepositoryMockTreeObjectParams {
	mmTreeObject.mutex.RLock()

	argCopy := make([]*GoGitRepositoryMockTreeObjectParams, len(mmTreeObject.callArgs))
	copy(argCopy, mmTreeObject.callArgs)

	mmTreeObject.mutex.RUnlock()

	return argCopy
}

// MinimockTreeObjectDone returns true if the count of the TreeObject invocations corresponds
// the number of defined expectations
func (m *GoGitRepositoryMock) MinimockTreeObjectDone() bool {
	for _, e := range m.TreeObjectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TreeObjectMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTreeObjectCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTreeObject != nil && mm_atomic.LoadUint64(&m.afterTreeObjectCounter) < 1 {
		return false
	}
	return true
}

// MinimockTreeObjectInspect logs each unmet expectation
func (m *GoGitRepositoryMock) MinimockTreeObjectInspect() {
	for _, e := range m.TreeObjectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GoGitRepositoryMock.TreeObject with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TreeObjectMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTreeObjectCounter) < 1 {
		if m.TreeObjectMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GoGitRepositoryMock.TreeObject")
		} else {
			m.t.Errorf("Expected call to GoGitRepositoryMock.TreeObject with params: %#v", *m.TreeObjectMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTreeObject != nil && mm_atomic.LoadUint64(&m.afterTreeObjectCounter) < 1 {
		m.t.Error("Expected call to GoGitRepositoryMock.TreeObject")
	}
}

type mGoGitRepositoryMockTreeObjects struct {
	mock               *GoGitRepositoryMock
	defaultExpectation *GoGitRepositoryMockTreeObjectsExpectation
	expectations       []*GoGitRepositoryMockTreeObjectsExpectation
}

// GoGitRepositoryMockTreeObjectsExpectation specifies expectation struct of the GoGitRepository.TreeObjects
type GoGitRepositoryMockTreeObjectsExpectation struct {
	mock *GoGitRepositoryMock

	results *GoGitRepositoryMockTreeObjectsResults
	Counter uint64
}

// GoGitRepositoryMockTreeObjectsResults contains results of the GoGitRepository.TreeObjects
type GoGitRepositoryMockTreeObjectsResults struct {
	tp1 *object.TreeIter
	err error
}

// Expect sets up expected params for GoGitRepository.TreeObjects
func (mmTreeObjects *mGoGitRepositoryMockTreeObjects) Expect() *mGoGitRepositoryMockTreeObjects {
	if mmTreeObjects.mock.funcTreeObjects != nil {
		mmTreeObjects.mock.t.Fatalf("GoGitRepositoryMock.TreeObjects mock is already set by Set")
	}

	if mmTreeObjects.defaultExpectation == nil {
		mmTreeObjects.defaultExpectation = &GoGitRepositoryMockTreeObjectsExpectation{}
	}

	return mmTreeObjects
}

// Inspect accepts an inspector function that has same arguments as the GoGitRepository.TreeObjects
func (mmTreeObjects *mGoGitRepositoryMockTreeObjects) Inspect(f func()) *mGoGitRepositoryMockTreeObjects {
	if mmTreeObjects.mock.inspectFuncTreeObjects != nil {
		mmTreeObjects.mock.t.Fatalf("Inspect function is already set for GoGitRepositoryMock.TreeObjects")
	}

	mmTreeObjects.mock.inspectFuncTreeObjects = f

	return mmTreeObjects
}

// Return sets up results that will be returned by GoGitRepository.TreeObjects
func (mmTreeObjects *mGoGitRepositoryMockTreeObjects) Return(tp1 *object.TreeIter, err error) *GoGitRepositoryMock {
	if mmTreeObjects.mock.funcTreeObjects != nil {
		mmTreeObjects.mock.t.Fatalf("GoGitRepositoryMock.TreeObjects mock is already set by Set")
	}

	if mmTreeObjects.defaultExpectation == nil {
		mmTreeObjects.defaultExpectation = &GoGitRepositoryMockTreeObjectsExpectation{mock: mmTreeObjects.mock}
	}
	mmTreeObjects.defaultExpectation.results = &GoGitRepositoryMockTreeObjectsResults{tp1, err}
	return mmTreeObjects.mock
}

// Set uses given function f to mock the GoGitRepository.TreeObjects method
func (mmTreeObjects *mGoGitRepositoryMockTreeObjects) Set(f func() (tp1 *object.TreeIter, err error)) *GoGitRepositoryMock {
	if mmTreeObjects.defaultExpectation != nil {
		mmTreeObjects.mock.t.Fatalf("Default expectation is already set for the GoGitRepository.TreeObjects method")
	}

	if len(mmTreeObjects.expectations) > 0 {
		mmTreeObjects.mock.t.Fatalf("Some expectations are already set for the GoGitRepository.TreeObjects method")
	}

	mmTreeObjects.mock.funcTreeObjects = f
	return mmTreeObjects.mock
}

// TreeObjects implements vcs.GoGitRepository
func (mmTreeObjects *GoGitRepositoryMock) TreeObjects() (tp1 *object.TreeIter, err error) {
	mm_atomic.AddUint64(&mmTreeObjects.beforeTreeObjectsCounter, 1)
	defer mm_atomic.AddUint64(&mmTreeObjects.afterTreeObjectsCounter, 1)

	if mmTreeObjects.inspectFuncTreeObjects != nil {
		mmTreeObjects.inspectFuncTreeObjects()
	}

	if mmTreeObjects.TreeObjectsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTreeObjects.TreeObjectsMock.defaultExpectation.Counter, 1)

		mm_results := mmTreeObjects.TreeObjectsMock.defaultExpectation.results
		if mm_results == nil {
			mmTreeObjects.t.Fatal("No results are set for the GoGitRepositoryMock.TreeObjects")
		}
		return (*mm_results).tp1, (*mm_results).err
	}
	if mmTreeObjects.funcTreeObjects != nil {
		return mmTreeObjects.funcTreeObjects()
	}
	mmTreeObjects.t.Fatalf("Unexpected call to GoGitRepositoryMock.TreeObjects.")
	return
}

// TreeObjectsAfterCounter returns a count of finished GoGitRepositoryMock.TreeObjects invocations
func (mmTreeObjects *GoGitRepositoryMock) TreeObjectsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTreeObjects.afterTreeObjectsCounter)
}

// TreeObjectsBeforeCounter returns a count of GoGitRepositoryMock.TreeObjects invocations
func (mmTreeObjects *GoGitRepositoryMock) TreeObjectsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTreeObjects.beforeTreeObjectsCounter)
}

// MinimockTreeObjectsDone returns true if the count of the TreeObjects invocations corresponds
// the number of defined expectations
func (m *GoGitRepositoryMock) MinimockTreeObjectsDone() bool {
	for _, e := range m.TreeObjectsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TreeObjectsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTreeObjectsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTreeObjects != nil && mm_atomic.LoadUint64(&m.afterTreeObjectsCounter) < 1 {
		return false
	}
	return true
}

// MinimockTreeObjectsInspect logs each unmet expectation
func (m *GoGitRepositoryMock) MinimockTreeObjectsInspect() {
	for _, e := range m.TreeObjectsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to GoGitRepositoryMock.TreeObjects")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TreeObjectsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTreeObjectsCounter) < 1 {
		m.t.Error("Expected call to GoGitRepositoryMock.TreeObjects")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTreeObjects != nil && mm_atomic.LoadUint64(&m.afterTreeObjectsCounter) < 1 {
		m.t.Error("Expected call to GoGitRepositoryMock.TreeObjects")
	}
}

type mGoGitRepositoryMockWorktree struct {
	mock               *GoGitRepositoryMock
	defaultExpectation *GoGitRepositoryMockWorktreeExpectation
	expectations       []*GoGitRepositoryMockWorktreeExpectation
}

// GoGitRepositoryMockWorktreeExpectation specifies expectation struct of the GoGitRepository.Worktree
type GoGitRepositoryMockWorktreeExpectation struct {
	mock *GoGitRepositoryMock

	results *GoGitRepositoryMockWorktreeResults
	Counter uint64
}

// GoGitRepositoryMockWorktreeResults contains results of the GoGitRepository.Worktree
type GoGitRepositoryMockWorktreeResults struct {
	wp1 *git.Worktree
	err error
}

// Expect sets up expected params for GoGitRepository.Worktree
func (mmWorktree *mGoGitRepositoryMockWorktree) Expect() *mGoGitRepositoryMockWorktree {
	if mmWorktree.mock.funcWorktree != nil {
		mmWorktree.mock.t.Fatalf("GoGitRepositoryMock.Worktree mock is already set by Set")
	}

	if mmWorktree.defaultExpectation == nil {
		mmWorktree.defaultExpectation = &GoGitRepositoryMockWorktreeExpectation{}
	}

	return mmWorktree
}

// Inspect accepts an inspector function that has same arguments as the GoGitRepository.Worktree
func (mmWorktree *mGoGitRepositoryMockWorktree) Inspect(f func()) *mGoGitRepositoryMockWorktree {
	if mmWorktree.mock.inspectFuncWorktree != nil {
		mmWorktree.mock.t.Fatalf("Inspect function is already set for GoGitRepositoryMock.Worktree")
	}

	mmWorktree.mock.inspectFuncWorktree = f

	return mmWorktree
}

// Return sets up results that will be returned by GoGitRepository.Worktree
func (mmWorktree *mGoGitRepositoryMockWorktree) Return(wp1 *git.Worktree, err error) *GoGitRepositoryMock {
	if mmWorktree.mock.funcWorktree != nil {
		mmWorktree.mock.t.Fatalf("GoGitRepositoryMock.Worktree mock is already set by Set")
	}

	if mmWorktree.defaultExpectation == nil {
		mmWorktree.defaultExpectation = &GoGitRepositoryMockWorktreeExpectation{mock: mmWorktree.mock}
	}
	mmWorktree.defaultExpectation.results = &GoGitRepositoryMockWorktreeResults{wp1, err}
	return mmWorktree.mock
}

// Set uses given function f to mock the GoGitRepository.Worktree method
func (mmWorktree *mGoGitRepositoryMockWorktree) Set(f func() (wp1 *git.Worktree, err error)) *GoGitRepositoryMock {
	if mmWorktree.defaultExpectation != nil {
		mmWorktree.mock.t.Fatalf("Default expectation is already set for the GoGitRepository.Worktree method")
	}

	if len(mmWorktree.expectations) > 0 {
		mmWorktree.mock.t.Fatalf("Some expectations are already set for the GoGitRepository.Worktree method")
	}

	mmWorktree.mock.funcWorktree = f
	return mmWorktree.mock
}

// Worktree implements vcs.GoGitRepository
func (mmWorktree *GoGitRepositoryMock) Worktree() (wp1 *git.Worktree, err error) {
	mm_atomic.AddUint64(&mmWorktree.beforeWorktreeCounter, 1)
	defer mm_atomic.AddUint64(&mmWorktree.afterWorktreeCounter, 1)

	if mmWorktree.inspectFuncWorktree != nil {
		mmWorktree.inspectFuncWorktree()
	}

	if mmWorktree.WorktreeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWorktree.WorktreeMock.defaultExpectation.Counter, 1)

		mm_results := mmWorktree.WorktreeMock.defaultExpectation.results
		if mm_results == nil {
			mmWorktree.t.Fatal("No results are set for the GoGitRepositoryMock.Worktree")
		}
		return (*mm_results).wp1, (*mm_results).err
	}
	if mmWorktree.funcWorktree != nil {
		return mmWorktree.funcWorktree()
	}
	mmWorktree.t.Fatalf("Unexpected call to GoGitRepositoryMock.Worktree.")
	return
}

// WorktreeAfterCounter returns a count of finished GoGitRepositoryMock.Worktree invocations
func (mmWorktree *GoGitRepositoryMock) WorktreeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWorktree.afterWorktreeCounter)
}

// WorktreeBeforeCounter returns a count of GoGitRepositoryMock.Worktree invocations
func (mmWorktree *GoGitRepositoryMock) WorktreeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWorktree.beforeWorktreeCounter)
}

// MinimockWorktreeDone returns true if the count of the Worktree invocations corresponds
// the number of defined expectations
func (m *GoGitRepositoryMock) MinimockWorktreeDone() bool {
	for _, e := range m.WorktreeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WorktreeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWorktreeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWorktree != nil && mm_atomic.LoadUint64(&m.afterWorktreeCounter) < 1 {
		return false
	}
	return true
}

// MinimockWorktreeInspect logs each unmet expectation
func (m *GoGitRepositoryMock) MinimockWorktreeInspect() {
	for _, e := range m.WorktreeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to GoGitRepositoryMock.Worktree")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WorktreeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWorktreeCounter) < 1 {
		m.t.Error("Expected call to GoGitRepositoryMock.Worktree")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWorktree != nil && mm_atomic.LoadUint64(&m.afterWorktreeCounter) < 1 {
		m.t.Error("Expected call to GoGitRepositoryMock.Worktree")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *GoGitRepositoryMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockBlobObjectInspect()

		m.MinimockBlobObjectsInspect()

		m.MinimockBranchInspect()

		m.MinimockBranchesInspect()

		m.MinimockCommitObjectInspect()

		m.MinimockCommitObjectsInspect()

		m.MinimockConfigInspect()

		m.MinimockConfigScopedInspect()

		m.MinimockCreateBranchInspect()

		m.MinimockCreateRemoteInspect()

		m.MinimockCreateRemoteAnonymousInspect()

		m.MinimockCreateTagInspect()

		m.MinimockDeleteBranchInspect()

		m.MinimockDeleteObjectInspect()

		m.MinimockDeleteRemoteInspect()

		m.MinimockDeleteTagInspect()

		m.MinimockFetchInspect()

		m.MinimockFetchContextInspect()

		m.MinimockHeadInspect()

		m.MinimockLogInspect()

		m.MinimockNotesInspect()

		m.MinimockObjectInspect()

		m.MinimockObjectsInspect()

		m.MinimockPruneInspect()

		m.MinimockPushInspect()

		m.MinimockPushContextInspect()

		m.MinimockReferenceInspect()

		m.MinimockReferencesInspect()

		m.MinimockRemoteInspect()

		m.MinimockRemotesInspect()

		m.MinimockRepackObjectsInspect()

		m.MinimockResolveRevisionInspect()

		m.MinimockSetConfigInspect()

		m.MinimockTagInspect()

		m.MinimockTagObjectInspect()

		m.MinimockTagObjectsInspect()

		m.MinimockTagsInspect()

		m.MinimockTreeObjectInspect()

		m.MinimockTreeObjectsInspect()

		m.MinimockWorktreeInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *GoGitRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *GoGitRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockBlobObjectDone() &&
		m.MinimockBlobObjectsDone() &&
		m.MinimockBranchDone() &&
		m.MinimockBranchesDone() &&
		m.MinimockCommitObjectDone() &&
		m.MinimockCommitObjectsDone() &&
		m.MinimockConfigDone() &&
		m.MinimockConfigScopedDone() &&
		m.MinimockCreateBranchDone() &&
		m.MinimockCreateRemoteDone() &&
		m.MinimockCreateRemoteAnonymousDone() &&
		m.MinimockCreateTagDone() &&
		m.MinimockDeleteBranchDone() &&
		m.MinimockDeleteObjectDone() &&
		m.MinimockDeleteRemoteDone() &&
		m.MinimockDeleteTagDone() &&
		m.MinimockFetchDone() &&
		m.MinimockFetchContextDone() &&
		m.MinimockHeadDone() &&
		m.MinimockLogDone() &&
		m.MinimockNotesDone() &&
		m.MinimockObjectDone() &&
		m.MinimockObjectsDone() &&
		m.MinimockPruneDone() &&
		m.MinimockPushDone() &&
		m.MinimockPushContextDone() &&
		m.MinimockReferenceDone() &&
		m.MinimockReferencesDone() &&
		m.MinimockRemoteDone() &&
		m.MinimockRemotesDone() &&
		m.MinimockRepackObjectsDone() &&
		m.MinimockResolveRevisionDone() &&
		m.MinimockSetConfigDone() &&
		m.MinimockTagDone() &&
		m.MinimockTagObjectDone() &&
		m.MinimockTagObjectsDone() &&
		m.MinimockTagsDone() &&
		m.MinimockTreeObjectDone() &&
		m.MinimockTreeObjectsDone() &&
		m.MinimockWorktreeDone()
}
