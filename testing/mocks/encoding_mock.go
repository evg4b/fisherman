package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i golang.org/x/text/encoding.Encoding -o ./testing/mocks/encoding_mock.go -n EncodingMock

import (
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	mm_encoding "golang.org/x/text/encoding"
)

// EncodingMock implements encoding.Encoding
type EncodingMock struct {
	t minimock.Tester

	funcNewDecoder          func() (dp1 *mm_encoding.Decoder)
	inspectFuncNewDecoder   func()
	afterNewDecoderCounter  uint64
	beforeNewDecoderCounter uint64
	NewDecoderMock          mEncodingMockNewDecoder

	funcNewEncoder          func() (ep1 *mm_encoding.Encoder)
	inspectFuncNewEncoder   func()
	afterNewEncoderCounter  uint64
	beforeNewEncoderCounter uint64
	NewEncoderMock          mEncodingMockNewEncoder
}

// NewEncodingMock returns a mock for encoding.Encoding
func NewEncodingMock(t minimock.Tester) *EncodingMock {
	m := &EncodingMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.NewDecoderMock = mEncodingMockNewDecoder{mock: m}

	m.NewEncoderMock = mEncodingMockNewEncoder{mock: m}

	return m
}

type mEncodingMockNewDecoder struct {
	mock               *EncodingMock
	defaultExpectation *EncodingMockNewDecoderExpectation
	expectations       []*EncodingMockNewDecoderExpectation
}

// EncodingMockNewDecoderExpectation specifies expectation struct of the Encoding.NewDecoder
type EncodingMockNewDecoderExpectation struct {
	mock *EncodingMock

	results *EncodingMockNewDecoderResults
	Counter uint64
}

// EncodingMockNewDecoderResults contains results of the Encoding.NewDecoder
type EncodingMockNewDecoderResults struct {
	dp1 *mm_encoding.Decoder
}

// Expect sets up expected params for Encoding.NewDecoder
func (mmNewDecoder *mEncodingMockNewDecoder) Expect() *mEncodingMockNewDecoder {
	if mmNewDecoder.mock.funcNewDecoder != nil {
		mmNewDecoder.mock.t.Fatalf("EncodingMock.NewDecoder mock is already set by Set")
	}

	if mmNewDecoder.defaultExpectation == nil {
		mmNewDecoder.defaultExpectation = &EncodingMockNewDecoderExpectation{}
	}

	return mmNewDecoder
}

// Inspect accepts an inspector function that has same arguments as the Encoding.NewDecoder
func (mmNewDecoder *mEncodingMockNewDecoder) Inspect(f func()) *mEncodingMockNewDecoder {
	if mmNewDecoder.mock.inspectFuncNewDecoder != nil {
		mmNewDecoder.mock.t.Fatalf("Inspect function is already set for EncodingMock.NewDecoder")
	}

	mmNewDecoder.mock.inspectFuncNewDecoder = f

	return mmNewDecoder
}

// Return sets up results that will be returned by Encoding.NewDecoder
func (mmNewDecoder *mEncodingMockNewDecoder) Return(dp1 *mm_encoding.Decoder) *EncodingMock {
	if mmNewDecoder.mock.funcNewDecoder != nil {
		mmNewDecoder.mock.t.Fatalf("EncodingMock.NewDecoder mock is already set by Set")
	}

	if mmNewDecoder.defaultExpectation == nil {
		mmNewDecoder.defaultExpectation = &EncodingMockNewDecoderExpectation{mock: mmNewDecoder.mock}
	}
	mmNewDecoder.defaultExpectation.results = &EncodingMockNewDecoderResults{dp1}
	return mmNewDecoder.mock
}

// Set uses given function f to mock the Encoding.NewDecoder method
func (mmNewDecoder *mEncodingMockNewDecoder) Set(f func() (dp1 *mm_encoding.Decoder)) *EncodingMock {
	if mmNewDecoder.defaultExpectation != nil {
		mmNewDecoder.mock.t.Fatalf("Default expectation is already set for the Encoding.NewDecoder method")
	}

	if len(mmNewDecoder.expectations) > 0 {
		mmNewDecoder.mock.t.Fatalf("Some expectations are already set for the Encoding.NewDecoder method")
	}

	mmNewDecoder.mock.funcNewDecoder = f
	return mmNewDecoder.mock
}

// NewDecoder implements encoding.Encoding
func (mmNewDecoder *EncodingMock) NewDecoder() (dp1 *mm_encoding.Decoder) {
	mm_atomic.AddUint64(&mmNewDecoder.beforeNewDecoderCounter, 1)
	defer mm_atomic.AddUint64(&mmNewDecoder.afterNewDecoderCounter, 1)

	if mmNewDecoder.inspectFuncNewDecoder != nil {
		mmNewDecoder.inspectFuncNewDecoder()
	}

	if mmNewDecoder.NewDecoderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmNewDecoder.NewDecoderMock.defaultExpectation.Counter, 1)

		mm_results := mmNewDecoder.NewDecoderMock.defaultExpectation.results
		if mm_results == nil {
			mmNewDecoder.t.Fatal("No results are set for the EncodingMock.NewDecoder")
		}
		return (*mm_results).dp1
	}
	if mmNewDecoder.funcNewDecoder != nil {
		return mmNewDecoder.funcNewDecoder()
	}
	mmNewDecoder.t.Fatalf("Unexpected call to EncodingMock.NewDecoder.")
	return
}

// NewDecoderAfterCounter returns a count of finished EncodingMock.NewDecoder invocations
func (mmNewDecoder *EncodingMock) NewDecoderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNewDecoder.afterNewDecoderCounter)
}

// NewDecoderBeforeCounter returns a count of EncodingMock.NewDecoder invocations
func (mmNewDecoder *EncodingMock) NewDecoderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNewDecoder.beforeNewDecoderCounter)
}

// MinimockNewDecoderDone returns true if the count of the NewDecoder invocations corresponds
// the number of defined expectations
func (m *EncodingMock) MinimockNewDecoderDone() bool {
	for _, e := range m.NewDecoderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.NewDecoderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterNewDecoderCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNewDecoder != nil && mm_atomic.LoadUint64(&m.afterNewDecoderCounter) < 1 {
		return false
	}
	return true
}

// MinimockNewDecoderInspect logs each unmet expectation
func (m *EncodingMock) MinimockNewDecoderInspect() {
	for _, e := range m.NewDecoderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to EncodingMock.NewDecoder")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.NewDecoderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterNewDecoderCounter) < 1 {
		m.t.Error("Expected call to EncodingMock.NewDecoder")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNewDecoder != nil && mm_atomic.LoadUint64(&m.afterNewDecoderCounter) < 1 {
		m.t.Error("Expected call to EncodingMock.NewDecoder")
	}
}

type mEncodingMockNewEncoder struct {
	mock               *EncodingMock
	defaultExpectation *EncodingMockNewEncoderExpectation
	expectations       []*EncodingMockNewEncoderExpectation
}

// EncodingMockNewEncoderExpectation specifies expectation struct of the Encoding.NewEncoder
type EncodingMockNewEncoderExpectation struct {
	mock *EncodingMock

	results *EncodingMockNewEncoderResults
	Counter uint64
}

// EncodingMockNewEncoderResults contains results of the Encoding.NewEncoder
type EncodingMockNewEncoderResults struct {
	ep1 *mm_encoding.Encoder
}

// Expect sets up expected params for Encoding.NewEncoder
func (mmNewEncoder *mEncodingMockNewEncoder) Expect() *mEncodingMockNewEncoder {
	if mmNewEncoder.mock.funcNewEncoder != nil {
		mmNewEncoder.mock.t.Fatalf("EncodingMock.NewEncoder mock is already set by Set")
	}

	if mmNewEncoder.defaultExpectation == nil {
		mmNewEncoder.defaultExpectation = &EncodingMockNewEncoderExpectation{}
	}

	return mmNewEncoder
}

// Inspect accepts an inspector function that has same arguments as the Encoding.NewEncoder
func (mmNewEncoder *mEncodingMockNewEncoder) Inspect(f func()) *mEncodingMockNewEncoder {
	if mmNewEncoder.mock.inspectFuncNewEncoder != nil {
		mmNewEncoder.mock.t.Fatalf("Inspect function is already set for EncodingMock.NewEncoder")
	}

	mmNewEncoder.mock.inspectFuncNewEncoder = f

	return mmNewEncoder
}

// Return sets up results that will be returned by Encoding.NewEncoder
func (mmNewEncoder *mEncodingMockNewEncoder) Return(ep1 *mm_encoding.Encoder) *EncodingMock {
	if mmNewEncoder.mock.funcNewEncoder != nil {
		mmNewEncoder.mock.t.Fatalf("EncodingMock.NewEncoder mock is already set by Set")
	}

	if mmNewEncoder.defaultExpectation == nil {
		mmNewEncoder.defaultExpectation = &EncodingMockNewEncoderExpectation{mock: mmNewEncoder.mock}
	}
	mmNewEncoder.defaultExpectation.results = &EncodingMockNewEncoderResults{ep1}
	return mmNewEncoder.mock
}

// Set uses given function f to mock the Encoding.NewEncoder method
func (mmNewEncoder *mEncodingMockNewEncoder) Set(f func() (ep1 *mm_encoding.Encoder)) *EncodingMock {
	if mmNewEncoder.defaultExpectation != nil {
		mmNewEncoder.mock.t.Fatalf("Default expectation is already set for the Encoding.NewEncoder method")
	}

	if len(mmNewEncoder.expectations) > 0 {
		mmNewEncoder.mock.t.Fatalf("Some expectations are already set for the Encoding.NewEncoder method")
	}

	mmNewEncoder.mock.funcNewEncoder = f
	return mmNewEncoder.mock
}

// NewEncoder implements encoding.Encoding
func (mmNewEncoder *EncodingMock) NewEncoder() (ep1 *mm_encoding.Encoder) {
	mm_atomic.AddUint64(&mmNewEncoder.beforeNewEncoderCounter, 1)
	defer mm_atomic.AddUint64(&mmNewEncoder.afterNewEncoderCounter, 1)

	if mmNewEncoder.inspectFuncNewEncoder != nil {
		mmNewEncoder.inspectFuncNewEncoder()
	}

	if mmNewEncoder.NewEncoderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmNewEncoder.NewEncoderMock.defaultExpectation.Counter, 1)

		mm_results := mmNewEncoder.NewEncoderMock.defaultExpectation.results
		if mm_results == nil {
			mmNewEncoder.t.Fatal("No results are set for the EncodingMock.NewEncoder")
		}
		return (*mm_results).ep1
	}
	if mmNewEncoder.funcNewEncoder != nil {
		return mmNewEncoder.funcNewEncoder()
	}
	mmNewEncoder.t.Fatalf("Unexpected call to EncodingMock.NewEncoder.")
	return
}

// NewEncoderAfterCounter returns a count of finished EncodingMock.NewEncoder invocations
func (mmNewEncoder *EncodingMock) NewEncoderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNewEncoder.afterNewEncoderCounter)
}

// NewEncoderBeforeCounter returns a count of EncodingMock.NewEncoder invocations
func (mmNewEncoder *EncodingMock) NewEncoderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNewEncoder.beforeNewEncoderCounter)
}

// MinimockNewEncoderDone returns true if the count of the NewEncoder invocations corresponds
// the number of defined expectations
func (m *EncodingMock) MinimockNewEncoderDone() bool {
	for _, e := range m.NewEncoderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.NewEncoderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterNewEncoderCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNewEncoder != nil && mm_atomic.LoadUint64(&m.afterNewEncoderCounter) < 1 {
		return false
	}
	return true
}

// MinimockNewEncoderInspect logs each unmet expectation
func (m *EncodingMock) MinimockNewEncoderInspect() {
	for _, e := range m.NewEncoderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to EncodingMock.NewEncoder")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.NewEncoderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterNewEncoderCounter) < 1 {
		m.t.Error("Expected call to EncodingMock.NewEncoder")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNewEncoder != nil && mm_atomic.LoadUint64(&m.afterNewEncoderCounter) < 1 {
		m.t.Error("Expected call to EncodingMock.NewEncoder")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *EncodingMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockNewDecoderInspect()

		m.MinimockNewEncoderInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *EncodingMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *EncodingMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockNewDecoderDone() &&
		m.MinimockNewEncoderDone()
}
