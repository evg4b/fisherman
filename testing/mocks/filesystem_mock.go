package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/go-git/go-billy/v5.Filesystem -o ./testing/mocks/filesystem_mock.go -n FilesystemMock

import (
	"os"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	mm_billy "github.com/go-git/go-billy/v5"
	"github.com/gojuno/minimock/v3"
)

// FilesystemMock implements billy.Filesystem
type FilesystemMock struct {
	t minimock.Tester

	funcChroot          func(path string) (f1 mm_billy.Filesystem, err error)
	inspectFuncChroot   func(path string)
	afterChrootCounter  uint64
	beforeChrootCounter uint64
	ChrootMock          mFilesystemMockChroot

	funcCreate          func(filename string) (f1 mm_billy.File, err error)
	inspectFuncCreate   func(filename string)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mFilesystemMockCreate

	funcJoin          func(elem ...string) (s1 string)
	inspectFuncJoin   func(elem ...string)
	afterJoinCounter  uint64
	beforeJoinCounter uint64
	JoinMock          mFilesystemMockJoin

	funcLstat          func(filename string) (f1 os.FileInfo, err error)
	inspectFuncLstat   func(filename string)
	afterLstatCounter  uint64
	beforeLstatCounter uint64
	LstatMock          mFilesystemMockLstat

	funcMkdirAll          func(filename string, perm os.FileMode) (err error)
	inspectFuncMkdirAll   func(filename string, perm os.FileMode)
	afterMkdirAllCounter  uint64
	beforeMkdirAllCounter uint64
	MkdirAllMock          mFilesystemMockMkdirAll

	funcOpen          func(filename string) (f1 mm_billy.File, err error)
	inspectFuncOpen   func(filename string)
	afterOpenCounter  uint64
	beforeOpenCounter uint64
	OpenMock          mFilesystemMockOpen

	funcOpenFile          func(filename string, flag int, perm os.FileMode) (f1 mm_billy.File, err error)
	inspectFuncOpenFile   func(filename string, flag int, perm os.FileMode)
	afterOpenFileCounter  uint64
	beforeOpenFileCounter uint64
	OpenFileMock          mFilesystemMockOpenFile

	funcReadDir          func(path string) (fa1 []os.FileInfo, err error)
	inspectFuncReadDir   func(path string)
	afterReadDirCounter  uint64
	beforeReadDirCounter uint64
	ReadDirMock          mFilesystemMockReadDir

	funcReadlink          func(link string) (s1 string, err error)
	inspectFuncReadlink   func(link string)
	afterReadlinkCounter  uint64
	beforeReadlinkCounter uint64
	ReadlinkMock          mFilesystemMockReadlink

	funcRemove          func(filename string) (err error)
	inspectFuncRemove   func(filename string)
	afterRemoveCounter  uint64
	beforeRemoveCounter uint64
	RemoveMock          mFilesystemMockRemove

	funcRename          func(oldpath string, newpath string) (err error)
	inspectFuncRename   func(oldpath string, newpath string)
	afterRenameCounter  uint64
	beforeRenameCounter uint64
	RenameMock          mFilesystemMockRename

	funcRoot          func() (s1 string)
	inspectFuncRoot   func()
	afterRootCounter  uint64
	beforeRootCounter uint64
	RootMock          mFilesystemMockRoot

	funcStat          func(filename string) (f1 os.FileInfo, err error)
	inspectFuncStat   func(filename string)
	afterStatCounter  uint64
	beforeStatCounter uint64
	StatMock          mFilesystemMockStat

	funcSymlink          func(target string, link string) (err error)
	inspectFuncSymlink   func(target string, link string)
	afterSymlinkCounter  uint64
	beforeSymlinkCounter uint64
	SymlinkMock          mFilesystemMockSymlink

	funcTempFile          func(dir string, prefix string) (f1 mm_billy.File, err error)
	inspectFuncTempFile   func(dir string, prefix string)
	afterTempFileCounter  uint64
	beforeTempFileCounter uint64
	TempFileMock          mFilesystemMockTempFile
}

// NewFilesystemMock returns a mock for billy.Filesystem
func NewFilesystemMock(t minimock.Tester) *FilesystemMock {
	m := &FilesystemMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ChrootMock = mFilesystemMockChroot{mock: m}
	m.ChrootMock.callArgs = []*FilesystemMockChrootParams{}

	m.CreateMock = mFilesystemMockCreate{mock: m}
	m.CreateMock.callArgs = []*FilesystemMockCreateParams{}

	m.JoinMock = mFilesystemMockJoin{mock: m}
	m.JoinMock.callArgs = []*FilesystemMockJoinParams{}

	m.LstatMock = mFilesystemMockLstat{mock: m}
	m.LstatMock.callArgs = []*FilesystemMockLstatParams{}

	m.MkdirAllMock = mFilesystemMockMkdirAll{mock: m}
	m.MkdirAllMock.callArgs = []*FilesystemMockMkdirAllParams{}

	m.OpenMock = mFilesystemMockOpen{mock: m}
	m.OpenMock.callArgs = []*FilesystemMockOpenParams{}

	m.OpenFileMock = mFilesystemMockOpenFile{mock: m}
	m.OpenFileMock.callArgs = []*FilesystemMockOpenFileParams{}

	m.ReadDirMock = mFilesystemMockReadDir{mock: m}
	m.ReadDirMock.callArgs = []*FilesystemMockReadDirParams{}

	m.ReadlinkMock = mFilesystemMockReadlink{mock: m}
	m.ReadlinkMock.callArgs = []*FilesystemMockReadlinkParams{}

	m.RemoveMock = mFilesystemMockRemove{mock: m}
	m.RemoveMock.callArgs = []*FilesystemMockRemoveParams{}

	m.RenameMock = mFilesystemMockRename{mock: m}
	m.RenameMock.callArgs = []*FilesystemMockRenameParams{}

	m.RootMock = mFilesystemMockRoot{mock: m}

	m.StatMock = mFilesystemMockStat{mock: m}
	m.StatMock.callArgs = []*FilesystemMockStatParams{}

	m.SymlinkMock = mFilesystemMockSymlink{mock: m}
	m.SymlinkMock.callArgs = []*FilesystemMockSymlinkParams{}

	m.TempFileMock = mFilesystemMockTempFile{mock: m}
	m.TempFileMock.callArgs = []*FilesystemMockTempFileParams{}

	return m
}

type mFilesystemMockChroot struct {
	mock               *FilesystemMock
	defaultExpectation *FilesystemMockChrootExpectation
	expectations       []*FilesystemMockChrootExpectation

	callArgs []*FilesystemMockChrootParams
	mutex    sync.RWMutex
}

// FilesystemMockChrootExpectation specifies expectation struct of the Filesystem.Chroot
type FilesystemMockChrootExpectation struct {
	mock    *FilesystemMock
	params  *FilesystemMockChrootParams
	results *FilesystemMockChrootResults
	Counter uint64
}

// FilesystemMockChrootParams contains parameters of the Filesystem.Chroot
type FilesystemMockChrootParams struct {
	path string
}

// FilesystemMockChrootResults contains results of the Filesystem.Chroot
type FilesystemMockChrootResults struct {
	f1  mm_billy.Filesystem
	err error
}

// Expect sets up expected params for Filesystem.Chroot
func (mmChroot *mFilesystemMockChroot) Expect(path string) *mFilesystemMockChroot {
	if mmChroot.mock.funcChroot != nil {
		mmChroot.mock.t.Fatalf("FilesystemMock.Chroot mock is already set by Set")
	}

	if mmChroot.defaultExpectation == nil {
		mmChroot.defaultExpectation = &FilesystemMockChrootExpectation{}
	}

	mmChroot.defaultExpectation.params = &FilesystemMockChrootParams{path}
	for _, e := range mmChroot.expectations {
		if minimock.Equal(e.params, mmChroot.defaultExpectation.params) {
			mmChroot.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmChroot.defaultExpectation.params)
		}
	}

	return mmChroot
}

// Inspect accepts an inspector function that has same arguments as the Filesystem.Chroot
func (mmChroot *mFilesystemMockChroot) Inspect(f func(path string)) *mFilesystemMockChroot {
	if mmChroot.mock.inspectFuncChroot != nil {
		mmChroot.mock.t.Fatalf("Inspect function is already set for FilesystemMock.Chroot")
	}

	mmChroot.mock.inspectFuncChroot = f

	return mmChroot
}

// Return sets up results that will be returned by Filesystem.Chroot
func (mmChroot *mFilesystemMockChroot) Return(f1 mm_billy.Filesystem, err error) *FilesystemMock {
	if mmChroot.mock.funcChroot != nil {
		mmChroot.mock.t.Fatalf("FilesystemMock.Chroot mock is already set by Set")
	}

	if mmChroot.defaultExpectation == nil {
		mmChroot.defaultExpectation = &FilesystemMockChrootExpectation{mock: mmChroot.mock}
	}
	mmChroot.defaultExpectation.results = &FilesystemMockChrootResults{f1, err}
	return mmChroot.mock
}

// Set uses given function f to mock the Filesystem.Chroot method
func (mmChroot *mFilesystemMockChroot) Set(f func(path string) (f1 mm_billy.Filesystem, err error)) *FilesystemMock {
	if mmChroot.defaultExpectation != nil {
		mmChroot.mock.t.Fatalf("Default expectation is already set for the Filesystem.Chroot method")
	}

	if len(mmChroot.expectations) > 0 {
		mmChroot.mock.t.Fatalf("Some expectations are already set for the Filesystem.Chroot method")
	}

	mmChroot.mock.funcChroot = f
	return mmChroot.mock
}

// When sets expectation for the Filesystem.Chroot which will trigger the result defined by the following
// Then helper
func (mmChroot *mFilesystemMockChroot) When(path string) *FilesystemMockChrootExpectation {
	if mmChroot.mock.funcChroot != nil {
		mmChroot.mock.t.Fatalf("FilesystemMock.Chroot mock is already set by Set")
	}

	expectation := &FilesystemMockChrootExpectation{
		mock:   mmChroot.mock,
		params: &FilesystemMockChrootParams{path},
	}
	mmChroot.expectations = append(mmChroot.expectations, expectation)
	return expectation
}

// Then sets up Filesystem.Chroot return parameters for the expectation previously defined by the When method
func (e *FilesystemMockChrootExpectation) Then(f1 mm_billy.Filesystem, err error) *FilesystemMock {
	e.results = &FilesystemMockChrootResults{f1, err}
	return e.mock
}

// Chroot implements billy.Filesystem
func (mmChroot *FilesystemMock) Chroot(path string) (f1 mm_billy.Filesystem, err error) {
	mm_atomic.AddUint64(&mmChroot.beforeChrootCounter, 1)
	defer mm_atomic.AddUint64(&mmChroot.afterChrootCounter, 1)

	if mmChroot.inspectFuncChroot != nil {
		mmChroot.inspectFuncChroot(path)
	}

	mm_params := &FilesystemMockChrootParams{path}

	// Record call args
	mmChroot.ChrootMock.mutex.Lock()
	mmChroot.ChrootMock.callArgs = append(mmChroot.ChrootMock.callArgs, mm_params)
	mmChroot.ChrootMock.mutex.Unlock()

	for _, e := range mmChroot.ChrootMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.f1, e.results.err
		}
	}

	if mmChroot.ChrootMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmChroot.ChrootMock.defaultExpectation.Counter, 1)
		mm_want := mmChroot.ChrootMock.defaultExpectation.params
		mm_got := FilesystemMockChrootParams{path}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmChroot.t.Errorf("FilesystemMock.Chroot got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmChroot.ChrootMock.defaultExpectation.results
		if mm_results == nil {
			mmChroot.t.Fatal("No results are set for the FilesystemMock.Chroot")
		}
		return (*mm_results).f1, (*mm_results).err
	}
	if mmChroot.funcChroot != nil {
		return mmChroot.funcChroot(path)
	}
	mmChroot.t.Fatalf("Unexpected call to FilesystemMock.Chroot. %v", path)
	return
}

// ChrootAfterCounter returns a count of finished FilesystemMock.Chroot invocations
func (mmChroot *FilesystemMock) ChrootAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmChroot.afterChrootCounter)
}

// ChrootBeforeCounter returns a count of FilesystemMock.Chroot invocations
func (mmChroot *FilesystemMock) ChrootBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmChroot.beforeChrootCounter)
}

// Calls returns a list of arguments used in each call to FilesystemMock.Chroot.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmChroot *mFilesystemMockChroot) Calls() []*FilesystemMockChrootParams {
	mmChroot.mutex.RLock()

	argCopy := make([]*FilesystemMockChrootParams, len(mmChroot.callArgs))
	copy(argCopy, mmChroot.callArgs)

	mmChroot.mutex.RUnlock()

	return argCopy
}

// MinimockChrootDone returns true if the count of the Chroot invocations corresponds
// the number of defined expectations
func (m *FilesystemMock) MinimockChrootDone() bool {
	for _, e := range m.ChrootMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ChrootMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterChrootCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcChroot != nil && mm_atomic.LoadUint64(&m.afterChrootCounter) < 1 {
		return false
	}
	return true
}

// MinimockChrootInspect logs each unmet expectation
func (m *FilesystemMock) MinimockChrootInspect() {
	for _, e := range m.ChrootMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FilesystemMock.Chroot with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ChrootMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterChrootCounter) < 1 {
		if m.ChrootMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FilesystemMock.Chroot")
		} else {
			m.t.Errorf("Expected call to FilesystemMock.Chroot with params: %#v", *m.ChrootMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcChroot != nil && mm_atomic.LoadUint64(&m.afterChrootCounter) < 1 {
		m.t.Error("Expected call to FilesystemMock.Chroot")
	}
}

type mFilesystemMockCreate struct {
	mock               *FilesystemMock
	defaultExpectation *FilesystemMockCreateExpectation
	expectations       []*FilesystemMockCreateExpectation

	callArgs []*FilesystemMockCreateParams
	mutex    sync.RWMutex
}

// FilesystemMockCreateExpectation specifies expectation struct of the Filesystem.Create
type FilesystemMockCreateExpectation struct {
	mock    *FilesystemMock
	params  *FilesystemMockCreateParams
	results *FilesystemMockCreateResults
	Counter uint64
}

// FilesystemMockCreateParams contains parameters of the Filesystem.Create
type FilesystemMockCreateParams struct {
	filename string
}

// FilesystemMockCreateResults contains results of the Filesystem.Create
type FilesystemMockCreateResults struct {
	f1  mm_billy.File
	err error
}

// Expect sets up expected params for Filesystem.Create
func (mmCreate *mFilesystemMockCreate) Expect(filename string) *mFilesystemMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("FilesystemMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &FilesystemMockCreateExpectation{}
	}

	mmCreate.defaultExpectation.params = &FilesystemMockCreateParams{filename}
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the Filesystem.Create
func (mmCreate *mFilesystemMockCreate) Inspect(f func(filename string)) *mFilesystemMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for FilesystemMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by Filesystem.Create
func (mmCreate *mFilesystemMockCreate) Return(f1 mm_billy.File, err error) *FilesystemMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("FilesystemMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &FilesystemMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &FilesystemMockCreateResults{f1, err}
	return mmCreate.mock
}

// Set uses given function f to mock the Filesystem.Create method
func (mmCreate *mFilesystemMockCreate) Set(f func(filename string) (f1 mm_billy.File, err error)) *FilesystemMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the Filesystem.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the Filesystem.Create method")
	}

	mmCreate.mock.funcCreate = f
	return mmCreate.mock
}

// When sets expectation for the Filesystem.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mFilesystemMockCreate) When(filename string) *FilesystemMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("FilesystemMock.Create mock is already set by Set")
	}

	expectation := &FilesystemMockCreateExpectation{
		mock:   mmCreate.mock,
		params: &FilesystemMockCreateParams{filename},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up Filesystem.Create return parameters for the expectation previously defined by the When method
func (e *FilesystemMockCreateExpectation) Then(f1 mm_billy.File, err error) *FilesystemMock {
	e.results = &FilesystemMockCreateResults{f1, err}
	return e.mock
}

// Create implements billy.Filesystem
func (mmCreate *FilesystemMock) Create(filename string) (f1 mm_billy.File, err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(filename)
	}

	mm_params := &FilesystemMockCreateParams{filename}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.f1, e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_got := FilesystemMockCreateParams{filename}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("FilesystemMock.Create got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the FilesystemMock.Create")
		}
		return (*mm_results).f1, (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(filename)
	}
	mmCreate.t.Fatalf("Unexpected call to FilesystemMock.Create. %v", filename)
	return
}

// CreateAfterCounter returns a count of finished FilesystemMock.Create invocations
func (mmCreate *FilesystemMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of FilesystemMock.Create invocations
func (mmCreate *FilesystemMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to FilesystemMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mFilesystemMockCreate) Calls() []*FilesystemMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*FilesystemMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *FilesystemMock) MinimockCreateDone() bool {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateInspect logs each unmet expectation
func (m *FilesystemMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FilesystemMock.Create with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FilesystemMock.Create")
		} else {
			m.t.Errorf("Expected call to FilesystemMock.Create with params: %#v", *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		m.t.Error("Expected call to FilesystemMock.Create")
	}
}

type mFilesystemMockJoin struct {
	mock               *FilesystemMock
	defaultExpectation *FilesystemMockJoinExpectation
	expectations       []*FilesystemMockJoinExpectation

	callArgs []*FilesystemMockJoinParams
	mutex    sync.RWMutex
}

// FilesystemMockJoinExpectation specifies expectation struct of the Filesystem.Join
type FilesystemMockJoinExpectation struct {
	mock    *FilesystemMock
	params  *FilesystemMockJoinParams
	results *FilesystemMockJoinResults
	Counter uint64
}

// FilesystemMockJoinParams contains parameters of the Filesystem.Join
type FilesystemMockJoinParams struct {
	elem []string
}

// FilesystemMockJoinResults contains results of the Filesystem.Join
type FilesystemMockJoinResults struct {
	s1 string
}

// Expect sets up expected params for Filesystem.Join
func (mmJoin *mFilesystemMockJoin) Expect(elem ...string) *mFilesystemMockJoin {
	if mmJoin.mock.funcJoin != nil {
		mmJoin.mock.t.Fatalf("FilesystemMock.Join mock is already set by Set")
	}

	if mmJoin.defaultExpectation == nil {
		mmJoin.defaultExpectation = &FilesystemMockJoinExpectation{}
	}

	mmJoin.defaultExpectation.params = &FilesystemMockJoinParams{elem}
	for _, e := range mmJoin.expectations {
		if minimock.Equal(e.params, mmJoin.defaultExpectation.params) {
			mmJoin.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmJoin.defaultExpectation.params)
		}
	}

	return mmJoin
}

// Inspect accepts an inspector function that has same arguments as the Filesystem.Join
func (mmJoin *mFilesystemMockJoin) Inspect(f func(elem ...string)) *mFilesystemMockJoin {
	if mmJoin.mock.inspectFuncJoin != nil {
		mmJoin.mock.t.Fatalf("Inspect function is already set for FilesystemMock.Join")
	}

	mmJoin.mock.inspectFuncJoin = f

	return mmJoin
}

// Return sets up results that will be returned by Filesystem.Join
func (mmJoin *mFilesystemMockJoin) Return(s1 string) *FilesystemMock {
	if mmJoin.mock.funcJoin != nil {
		mmJoin.mock.t.Fatalf("FilesystemMock.Join mock is already set by Set")
	}

	if mmJoin.defaultExpectation == nil {
		mmJoin.defaultExpectation = &FilesystemMockJoinExpectation{mock: mmJoin.mock}
	}
	mmJoin.defaultExpectation.results = &FilesystemMockJoinResults{s1}
	return mmJoin.mock
}

// Set uses given function f to mock the Filesystem.Join method
func (mmJoin *mFilesystemMockJoin) Set(f func(elem ...string) (s1 string)) *FilesystemMock {
	if mmJoin.defaultExpectation != nil {
		mmJoin.mock.t.Fatalf("Default expectation is already set for the Filesystem.Join method")
	}

	if len(mmJoin.expectations) > 0 {
		mmJoin.mock.t.Fatalf("Some expectations are already set for the Filesystem.Join method")
	}

	mmJoin.mock.funcJoin = f
	return mmJoin.mock
}

// When sets expectation for the Filesystem.Join which will trigger the result defined by the following
// Then helper
func (mmJoin *mFilesystemMockJoin) When(elem ...string) *FilesystemMockJoinExpectation {
	if mmJoin.mock.funcJoin != nil {
		mmJoin.mock.t.Fatalf("FilesystemMock.Join mock is already set by Set")
	}

	expectation := &FilesystemMockJoinExpectation{
		mock:   mmJoin.mock,
		params: &FilesystemMockJoinParams{elem},
	}
	mmJoin.expectations = append(mmJoin.expectations, expectation)
	return expectation
}

// Then sets up Filesystem.Join return parameters for the expectation previously defined by the When method
func (e *FilesystemMockJoinExpectation) Then(s1 string) *FilesystemMock {
	e.results = &FilesystemMockJoinResults{s1}
	return e.mock
}

// Join implements billy.Filesystem
func (mmJoin *FilesystemMock) Join(elem ...string) (s1 string) {
	mm_atomic.AddUint64(&mmJoin.beforeJoinCounter, 1)
	defer mm_atomic.AddUint64(&mmJoin.afterJoinCounter, 1)

	if mmJoin.inspectFuncJoin != nil {
		mmJoin.inspectFuncJoin(elem...)
	}

	mm_params := &FilesystemMockJoinParams{elem}

	// Record call args
	mmJoin.JoinMock.mutex.Lock()
	mmJoin.JoinMock.callArgs = append(mmJoin.JoinMock.callArgs, mm_params)
	mmJoin.JoinMock.mutex.Unlock()

	for _, e := range mmJoin.JoinMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1
		}
	}

	if mmJoin.JoinMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmJoin.JoinMock.defaultExpectation.Counter, 1)
		mm_want := mmJoin.JoinMock.defaultExpectation.params
		mm_got := FilesystemMockJoinParams{elem}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmJoin.t.Errorf("FilesystemMock.Join got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmJoin.JoinMock.defaultExpectation.results
		if mm_results == nil {
			mmJoin.t.Fatal("No results are set for the FilesystemMock.Join")
		}
		return (*mm_results).s1
	}
	if mmJoin.funcJoin != nil {
		return mmJoin.funcJoin(elem...)
	}
	mmJoin.t.Fatalf("Unexpected call to FilesystemMock.Join. %v", elem)
	return
}

// JoinAfterCounter returns a count of finished FilesystemMock.Join invocations
func (mmJoin *FilesystemMock) JoinAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmJoin.afterJoinCounter)
}

// JoinBeforeCounter returns a count of FilesystemMock.Join invocations
func (mmJoin *FilesystemMock) JoinBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmJoin.beforeJoinCounter)
}

// Calls returns a list of arguments used in each call to FilesystemMock.Join.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmJoin *mFilesystemMockJoin) Calls() []*FilesystemMockJoinParams {
	mmJoin.mutex.RLock()

	argCopy := make([]*FilesystemMockJoinParams, len(mmJoin.callArgs))
	copy(argCopy, mmJoin.callArgs)

	mmJoin.mutex.RUnlock()

	return argCopy
}

// MinimockJoinDone returns true if the count of the Join invocations corresponds
// the number of defined expectations
func (m *FilesystemMock) MinimockJoinDone() bool {
	for _, e := range m.JoinMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.JoinMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterJoinCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcJoin != nil && mm_atomic.LoadUint64(&m.afterJoinCounter) < 1 {
		return false
	}
	return true
}

// MinimockJoinInspect logs each unmet expectation
func (m *FilesystemMock) MinimockJoinInspect() {
	for _, e := range m.JoinMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FilesystemMock.Join with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.JoinMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterJoinCounter) < 1 {
		if m.JoinMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FilesystemMock.Join")
		} else {
			m.t.Errorf("Expected call to FilesystemMock.Join with params: %#v", *m.JoinMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcJoin != nil && mm_atomic.LoadUint64(&m.afterJoinCounter) < 1 {
		m.t.Error("Expected call to FilesystemMock.Join")
	}
}

type mFilesystemMockLstat struct {
	mock               *FilesystemMock
	defaultExpectation *FilesystemMockLstatExpectation
	expectations       []*FilesystemMockLstatExpectation

	callArgs []*FilesystemMockLstatParams
	mutex    sync.RWMutex
}

// FilesystemMockLstatExpectation specifies expectation struct of the Filesystem.Lstat
type FilesystemMockLstatExpectation struct {
	mock    *FilesystemMock
	params  *FilesystemMockLstatParams
	results *FilesystemMockLstatResults
	Counter uint64
}

// FilesystemMockLstatParams contains parameters of the Filesystem.Lstat
type FilesystemMockLstatParams struct {
	filename string
}

// FilesystemMockLstatResults contains results of the Filesystem.Lstat
type FilesystemMockLstatResults struct {
	f1  os.FileInfo
	err error
}

// Expect sets up expected params for Filesystem.Lstat
func (mmLstat *mFilesystemMockLstat) Expect(filename string) *mFilesystemMockLstat {
	if mmLstat.mock.funcLstat != nil {
		mmLstat.mock.t.Fatalf("FilesystemMock.Lstat mock is already set by Set")
	}

	if mmLstat.defaultExpectation == nil {
		mmLstat.defaultExpectation = &FilesystemMockLstatExpectation{}
	}

	mmLstat.defaultExpectation.params = &FilesystemMockLstatParams{filename}
	for _, e := range mmLstat.expectations {
		if minimock.Equal(e.params, mmLstat.defaultExpectation.params) {
			mmLstat.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmLstat.defaultExpectation.params)
		}
	}

	return mmLstat
}

// Inspect accepts an inspector function that has same arguments as the Filesystem.Lstat
func (mmLstat *mFilesystemMockLstat) Inspect(f func(filename string)) *mFilesystemMockLstat {
	if mmLstat.mock.inspectFuncLstat != nil {
		mmLstat.mock.t.Fatalf("Inspect function is already set for FilesystemMock.Lstat")
	}

	mmLstat.mock.inspectFuncLstat = f

	return mmLstat
}

// Return sets up results that will be returned by Filesystem.Lstat
func (mmLstat *mFilesystemMockLstat) Return(f1 os.FileInfo, err error) *FilesystemMock {
	if mmLstat.mock.funcLstat != nil {
		mmLstat.mock.t.Fatalf("FilesystemMock.Lstat mock is already set by Set")
	}

	if mmLstat.defaultExpectation == nil {
		mmLstat.defaultExpectation = &FilesystemMockLstatExpectation{mock: mmLstat.mock}
	}
	mmLstat.defaultExpectation.results = &FilesystemMockLstatResults{f1, err}
	return mmLstat.mock
}

// Set uses given function f to mock the Filesystem.Lstat method
func (mmLstat *mFilesystemMockLstat) Set(f func(filename string) (f1 os.FileInfo, err error)) *FilesystemMock {
	if mmLstat.defaultExpectation != nil {
		mmLstat.mock.t.Fatalf("Default expectation is already set for the Filesystem.Lstat method")
	}

	if len(mmLstat.expectations) > 0 {
		mmLstat.mock.t.Fatalf("Some expectations are already set for the Filesystem.Lstat method")
	}

	mmLstat.mock.funcLstat = f
	return mmLstat.mock
}

// When sets expectation for the Filesystem.Lstat which will trigger the result defined by the following
// Then helper
func (mmLstat *mFilesystemMockLstat) When(filename string) *FilesystemMockLstatExpectation {
	if mmLstat.mock.funcLstat != nil {
		mmLstat.mock.t.Fatalf("FilesystemMock.Lstat mock is already set by Set")
	}

	expectation := &FilesystemMockLstatExpectation{
		mock:   mmLstat.mock,
		params: &FilesystemMockLstatParams{filename},
	}
	mmLstat.expectations = append(mmLstat.expectations, expectation)
	return expectation
}

// Then sets up Filesystem.Lstat return parameters for the expectation previously defined by the When method
func (e *FilesystemMockLstatExpectation) Then(f1 os.FileInfo, err error) *FilesystemMock {
	e.results = &FilesystemMockLstatResults{f1, err}
	return e.mock
}

// Lstat implements billy.Filesystem
func (mmLstat *FilesystemMock) Lstat(filename string) (f1 os.FileInfo, err error) {
	mm_atomic.AddUint64(&mmLstat.beforeLstatCounter, 1)
	defer mm_atomic.AddUint64(&mmLstat.afterLstatCounter, 1)

	if mmLstat.inspectFuncLstat != nil {
		mmLstat.inspectFuncLstat(filename)
	}

	mm_params := &FilesystemMockLstatParams{filename}

	// Record call args
	mmLstat.LstatMock.mutex.Lock()
	mmLstat.LstatMock.callArgs = append(mmLstat.LstatMock.callArgs, mm_params)
	mmLstat.LstatMock.mutex.Unlock()

	for _, e := range mmLstat.LstatMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.f1, e.results.err
		}
	}

	if mmLstat.LstatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLstat.LstatMock.defaultExpectation.Counter, 1)
		mm_want := mmLstat.LstatMock.defaultExpectation.params
		mm_got := FilesystemMockLstatParams{filename}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmLstat.t.Errorf("FilesystemMock.Lstat got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmLstat.LstatMock.defaultExpectation.results
		if mm_results == nil {
			mmLstat.t.Fatal("No results are set for the FilesystemMock.Lstat")
		}
		return (*mm_results).f1, (*mm_results).err
	}
	if mmLstat.funcLstat != nil {
		return mmLstat.funcLstat(filename)
	}
	mmLstat.t.Fatalf("Unexpected call to FilesystemMock.Lstat. %v", filename)
	return
}

// LstatAfterCounter returns a count of finished FilesystemMock.Lstat invocations
func (mmLstat *FilesystemMock) LstatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLstat.afterLstatCounter)
}

// LstatBeforeCounter returns a count of FilesystemMock.Lstat invocations
func (mmLstat *FilesystemMock) LstatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLstat.beforeLstatCounter)
}

// Calls returns a list of arguments used in each call to FilesystemMock.Lstat.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmLstat *mFilesystemMockLstat) Calls() []*FilesystemMockLstatParams {
	mmLstat.mutex.RLock()

	argCopy := make([]*FilesystemMockLstatParams, len(mmLstat.callArgs))
	copy(argCopy, mmLstat.callArgs)

	mmLstat.mutex.RUnlock()

	return argCopy
}

// MinimockLstatDone returns true if the count of the Lstat invocations corresponds
// the number of defined expectations
func (m *FilesystemMock) MinimockLstatDone() bool {
	for _, e := range m.LstatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LstatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLstatCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLstat != nil && mm_atomic.LoadUint64(&m.afterLstatCounter) < 1 {
		return false
	}
	return true
}

// MinimockLstatInspect logs each unmet expectation
func (m *FilesystemMock) MinimockLstatInspect() {
	for _, e := range m.LstatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FilesystemMock.Lstat with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LstatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLstatCounter) < 1 {
		if m.LstatMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FilesystemMock.Lstat")
		} else {
			m.t.Errorf("Expected call to FilesystemMock.Lstat with params: %#v", *m.LstatMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLstat != nil && mm_atomic.LoadUint64(&m.afterLstatCounter) < 1 {
		m.t.Error("Expected call to FilesystemMock.Lstat")
	}
}

type mFilesystemMockMkdirAll struct {
	mock               *FilesystemMock
	defaultExpectation *FilesystemMockMkdirAllExpectation
	expectations       []*FilesystemMockMkdirAllExpectation

	callArgs []*FilesystemMockMkdirAllParams
	mutex    sync.RWMutex
}

// FilesystemMockMkdirAllExpectation specifies expectation struct of the Filesystem.MkdirAll
type FilesystemMockMkdirAllExpectation struct {
	mock    *FilesystemMock
	params  *FilesystemMockMkdirAllParams
	results *FilesystemMockMkdirAllResults
	Counter uint64
}

// FilesystemMockMkdirAllParams contains parameters of the Filesystem.MkdirAll
type FilesystemMockMkdirAllParams struct {
	filename string
	perm     os.FileMode
}

// FilesystemMockMkdirAllResults contains results of the Filesystem.MkdirAll
type FilesystemMockMkdirAllResults struct {
	err error
}

// Expect sets up expected params for Filesystem.MkdirAll
func (mmMkdirAll *mFilesystemMockMkdirAll) Expect(filename string, perm os.FileMode) *mFilesystemMockMkdirAll {
	if mmMkdirAll.mock.funcMkdirAll != nil {
		mmMkdirAll.mock.t.Fatalf("FilesystemMock.MkdirAll mock is already set by Set")
	}

	if mmMkdirAll.defaultExpectation == nil {
		mmMkdirAll.defaultExpectation = &FilesystemMockMkdirAllExpectation{}
	}

	mmMkdirAll.defaultExpectation.params = &FilesystemMockMkdirAllParams{filename, perm}
	for _, e := range mmMkdirAll.expectations {
		if minimock.Equal(e.params, mmMkdirAll.defaultExpectation.params) {
			mmMkdirAll.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmMkdirAll.defaultExpectation.params)
		}
	}

	return mmMkdirAll
}

// Inspect accepts an inspector function that has same arguments as the Filesystem.MkdirAll
func (mmMkdirAll *mFilesystemMockMkdirAll) Inspect(f func(filename string, perm os.FileMode)) *mFilesystemMockMkdirAll {
	if mmMkdirAll.mock.inspectFuncMkdirAll != nil {
		mmMkdirAll.mock.t.Fatalf("Inspect function is already set for FilesystemMock.MkdirAll")
	}

	mmMkdirAll.mock.inspectFuncMkdirAll = f

	return mmMkdirAll
}

// Return sets up results that will be returned by Filesystem.MkdirAll
func (mmMkdirAll *mFilesystemMockMkdirAll) Return(err error) *FilesystemMock {
	if mmMkdirAll.mock.funcMkdirAll != nil {
		mmMkdirAll.mock.t.Fatalf("FilesystemMock.MkdirAll mock is already set by Set")
	}

	if mmMkdirAll.defaultExpectation == nil {
		mmMkdirAll.defaultExpectation = &FilesystemMockMkdirAllExpectation{mock: mmMkdirAll.mock}
	}
	mmMkdirAll.defaultExpectation.results = &FilesystemMockMkdirAllResults{err}
	return mmMkdirAll.mock
}

// Set uses given function f to mock the Filesystem.MkdirAll method
func (mmMkdirAll *mFilesystemMockMkdirAll) Set(f func(filename string, perm os.FileMode) (err error)) *FilesystemMock {
	if mmMkdirAll.defaultExpectation != nil {
		mmMkdirAll.mock.t.Fatalf("Default expectation is already set for the Filesystem.MkdirAll method")
	}

	if len(mmMkdirAll.expectations) > 0 {
		mmMkdirAll.mock.t.Fatalf("Some expectations are already set for the Filesystem.MkdirAll method")
	}

	mmMkdirAll.mock.funcMkdirAll = f
	return mmMkdirAll.mock
}

// When sets expectation for the Filesystem.MkdirAll which will trigger the result defined by the following
// Then helper
func (mmMkdirAll *mFilesystemMockMkdirAll) When(filename string, perm os.FileMode) *FilesystemMockMkdirAllExpectation {
	if mmMkdirAll.mock.funcMkdirAll != nil {
		mmMkdirAll.mock.t.Fatalf("FilesystemMock.MkdirAll mock is already set by Set")
	}

	expectation := &FilesystemMockMkdirAllExpectation{
		mock:   mmMkdirAll.mock,
		params: &FilesystemMockMkdirAllParams{filename, perm},
	}
	mmMkdirAll.expectations = append(mmMkdirAll.expectations, expectation)
	return expectation
}

// Then sets up Filesystem.MkdirAll return parameters for the expectation previously defined by the When method
func (e *FilesystemMockMkdirAllExpectation) Then(err error) *FilesystemMock {
	e.results = &FilesystemMockMkdirAllResults{err}
	return e.mock
}

// MkdirAll implements billy.Filesystem
func (mmMkdirAll *FilesystemMock) MkdirAll(filename string, perm os.FileMode) (err error) {
	mm_atomic.AddUint64(&mmMkdirAll.beforeMkdirAllCounter, 1)
	defer mm_atomic.AddUint64(&mmMkdirAll.afterMkdirAllCounter, 1)

	if mmMkdirAll.inspectFuncMkdirAll != nil {
		mmMkdirAll.inspectFuncMkdirAll(filename, perm)
	}

	mm_params := &FilesystemMockMkdirAllParams{filename, perm}

	// Record call args
	mmMkdirAll.MkdirAllMock.mutex.Lock()
	mmMkdirAll.MkdirAllMock.callArgs = append(mmMkdirAll.MkdirAllMock.callArgs, mm_params)
	mmMkdirAll.MkdirAllMock.mutex.Unlock()

	for _, e := range mmMkdirAll.MkdirAllMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmMkdirAll.MkdirAllMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmMkdirAll.MkdirAllMock.defaultExpectation.Counter, 1)
		mm_want := mmMkdirAll.MkdirAllMock.defaultExpectation.params
		mm_got := FilesystemMockMkdirAllParams{filename, perm}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmMkdirAll.t.Errorf("FilesystemMock.MkdirAll got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmMkdirAll.MkdirAllMock.defaultExpectation.results
		if mm_results == nil {
			mmMkdirAll.t.Fatal("No results are set for the FilesystemMock.MkdirAll")
		}
		return (*mm_results).err
	}
	if mmMkdirAll.funcMkdirAll != nil {
		return mmMkdirAll.funcMkdirAll(filename, perm)
	}
	mmMkdirAll.t.Fatalf("Unexpected call to FilesystemMock.MkdirAll. %v %v", filename, perm)
	return
}

// MkdirAllAfterCounter returns a count of finished FilesystemMock.MkdirAll invocations
func (mmMkdirAll *FilesystemMock) MkdirAllAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMkdirAll.afterMkdirAllCounter)
}

// MkdirAllBeforeCounter returns a count of FilesystemMock.MkdirAll invocations
func (mmMkdirAll *FilesystemMock) MkdirAllBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMkdirAll.beforeMkdirAllCounter)
}

// Calls returns a list of arguments used in each call to FilesystemMock.MkdirAll.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmMkdirAll *mFilesystemMockMkdirAll) Calls() []*FilesystemMockMkdirAllParams {
	mmMkdirAll.mutex.RLock()

	argCopy := make([]*FilesystemMockMkdirAllParams, len(mmMkdirAll.callArgs))
	copy(argCopy, mmMkdirAll.callArgs)

	mmMkdirAll.mutex.RUnlock()

	return argCopy
}

// MinimockMkdirAllDone returns true if the count of the MkdirAll invocations corresponds
// the number of defined expectations
func (m *FilesystemMock) MinimockMkdirAllDone() bool {
	for _, e := range m.MkdirAllMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MkdirAllMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMkdirAllCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMkdirAll != nil && mm_atomic.LoadUint64(&m.afterMkdirAllCounter) < 1 {
		return false
	}
	return true
}

// MinimockMkdirAllInspect logs each unmet expectation
func (m *FilesystemMock) MinimockMkdirAllInspect() {
	for _, e := range m.MkdirAllMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FilesystemMock.MkdirAll with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MkdirAllMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMkdirAllCounter) < 1 {
		if m.MkdirAllMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FilesystemMock.MkdirAll")
		} else {
			m.t.Errorf("Expected call to FilesystemMock.MkdirAll with params: %#v", *m.MkdirAllMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMkdirAll != nil && mm_atomic.LoadUint64(&m.afterMkdirAllCounter) < 1 {
		m.t.Error("Expected call to FilesystemMock.MkdirAll")
	}
}

type mFilesystemMockOpen struct {
	mock               *FilesystemMock
	defaultExpectation *FilesystemMockOpenExpectation
	expectations       []*FilesystemMockOpenExpectation

	callArgs []*FilesystemMockOpenParams
	mutex    sync.RWMutex
}

// FilesystemMockOpenExpectation specifies expectation struct of the Filesystem.Open
type FilesystemMockOpenExpectation struct {
	mock    *FilesystemMock
	params  *FilesystemMockOpenParams
	results *FilesystemMockOpenResults
	Counter uint64
}

// FilesystemMockOpenParams contains parameters of the Filesystem.Open
type FilesystemMockOpenParams struct {
	filename string
}

// FilesystemMockOpenResults contains results of the Filesystem.Open
type FilesystemMockOpenResults struct {
	f1  mm_billy.File
	err error
}

// Expect sets up expected params for Filesystem.Open
func (mmOpen *mFilesystemMockOpen) Expect(filename string) *mFilesystemMockOpen {
	if mmOpen.mock.funcOpen != nil {
		mmOpen.mock.t.Fatalf("FilesystemMock.Open mock is already set by Set")
	}

	if mmOpen.defaultExpectation == nil {
		mmOpen.defaultExpectation = &FilesystemMockOpenExpectation{}
	}

	mmOpen.defaultExpectation.params = &FilesystemMockOpenParams{filename}
	for _, e := range mmOpen.expectations {
		if minimock.Equal(e.params, mmOpen.defaultExpectation.params) {
			mmOpen.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmOpen.defaultExpectation.params)
		}
	}

	return mmOpen
}

// Inspect accepts an inspector function that has same arguments as the Filesystem.Open
func (mmOpen *mFilesystemMockOpen) Inspect(f func(filename string)) *mFilesystemMockOpen {
	if mmOpen.mock.inspectFuncOpen != nil {
		mmOpen.mock.t.Fatalf("Inspect function is already set for FilesystemMock.Open")
	}

	mmOpen.mock.inspectFuncOpen = f

	return mmOpen
}

// Return sets up results that will be returned by Filesystem.Open
func (mmOpen *mFilesystemMockOpen) Return(f1 mm_billy.File, err error) *FilesystemMock {
	if mmOpen.mock.funcOpen != nil {
		mmOpen.mock.t.Fatalf("FilesystemMock.Open mock is already set by Set")
	}

	if mmOpen.defaultExpectation == nil {
		mmOpen.defaultExpectation = &FilesystemMockOpenExpectation{mock: mmOpen.mock}
	}
	mmOpen.defaultExpectation.results = &FilesystemMockOpenResults{f1, err}
	return mmOpen.mock
}

// Set uses given function f to mock the Filesystem.Open method
func (mmOpen *mFilesystemMockOpen) Set(f func(filename string) (f1 mm_billy.File, err error)) *FilesystemMock {
	if mmOpen.defaultExpectation != nil {
		mmOpen.mock.t.Fatalf("Default expectation is already set for the Filesystem.Open method")
	}

	if len(mmOpen.expectations) > 0 {
		mmOpen.mock.t.Fatalf("Some expectations are already set for the Filesystem.Open method")
	}

	mmOpen.mock.funcOpen = f
	return mmOpen.mock
}

// When sets expectation for the Filesystem.Open which will trigger the result defined by the following
// Then helper
func (mmOpen *mFilesystemMockOpen) When(filename string) *FilesystemMockOpenExpectation {
	if mmOpen.mock.funcOpen != nil {
		mmOpen.mock.t.Fatalf("FilesystemMock.Open mock is already set by Set")
	}

	expectation := &FilesystemMockOpenExpectation{
		mock:   mmOpen.mock,
		params: &FilesystemMockOpenParams{filename},
	}
	mmOpen.expectations = append(mmOpen.expectations, expectation)
	return expectation
}

// Then sets up Filesystem.Open return parameters for the expectation previously defined by the When method
func (e *FilesystemMockOpenExpectation) Then(f1 mm_billy.File, err error) *FilesystemMock {
	e.results = &FilesystemMockOpenResults{f1, err}
	return e.mock
}

// Open implements billy.Filesystem
func (mmOpen *FilesystemMock) Open(filename string) (f1 mm_billy.File, err error) {
	mm_atomic.AddUint64(&mmOpen.beforeOpenCounter, 1)
	defer mm_atomic.AddUint64(&mmOpen.afterOpenCounter, 1)

	if mmOpen.inspectFuncOpen != nil {
		mmOpen.inspectFuncOpen(filename)
	}

	mm_params := &FilesystemMockOpenParams{filename}

	// Record call args
	mmOpen.OpenMock.mutex.Lock()
	mmOpen.OpenMock.callArgs = append(mmOpen.OpenMock.callArgs, mm_params)
	mmOpen.OpenMock.mutex.Unlock()

	for _, e := range mmOpen.OpenMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.f1, e.results.err
		}
	}

	if mmOpen.OpenMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmOpen.OpenMock.defaultExpectation.Counter, 1)
		mm_want := mmOpen.OpenMock.defaultExpectation.params
		mm_got := FilesystemMockOpenParams{filename}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmOpen.t.Errorf("FilesystemMock.Open got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmOpen.OpenMock.defaultExpectation.results
		if mm_results == nil {
			mmOpen.t.Fatal("No results are set for the FilesystemMock.Open")
		}
		return (*mm_results).f1, (*mm_results).err
	}
	if mmOpen.funcOpen != nil {
		return mmOpen.funcOpen(filename)
	}
	mmOpen.t.Fatalf("Unexpected call to FilesystemMock.Open. %v", filename)
	return
}

// OpenAfterCounter returns a count of finished FilesystemMock.Open invocations
func (mmOpen *FilesystemMock) OpenAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOpen.afterOpenCounter)
}

// OpenBeforeCounter returns a count of FilesystemMock.Open invocations
func (mmOpen *FilesystemMock) OpenBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOpen.beforeOpenCounter)
}

// Calls returns a list of arguments used in each call to FilesystemMock.Open.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmOpen *mFilesystemMockOpen) Calls() []*FilesystemMockOpenParams {
	mmOpen.mutex.RLock()

	argCopy := make([]*FilesystemMockOpenParams, len(mmOpen.callArgs))
	copy(argCopy, mmOpen.callArgs)

	mmOpen.mutex.RUnlock()

	return argCopy
}

// MinimockOpenDone returns true if the count of the Open invocations corresponds
// the number of defined expectations
func (m *FilesystemMock) MinimockOpenDone() bool {
	for _, e := range m.OpenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OpenMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOpenCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOpen != nil && mm_atomic.LoadUint64(&m.afterOpenCounter) < 1 {
		return false
	}
	return true
}

// MinimockOpenInspect logs each unmet expectation
func (m *FilesystemMock) MinimockOpenInspect() {
	for _, e := range m.OpenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FilesystemMock.Open with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OpenMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOpenCounter) < 1 {
		if m.OpenMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FilesystemMock.Open")
		} else {
			m.t.Errorf("Expected call to FilesystemMock.Open with params: %#v", *m.OpenMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOpen != nil && mm_atomic.LoadUint64(&m.afterOpenCounter) < 1 {
		m.t.Error("Expected call to FilesystemMock.Open")
	}
}

type mFilesystemMockOpenFile struct {
	mock               *FilesystemMock
	defaultExpectation *FilesystemMockOpenFileExpectation
	expectations       []*FilesystemMockOpenFileExpectation

	callArgs []*FilesystemMockOpenFileParams
	mutex    sync.RWMutex
}

// FilesystemMockOpenFileExpectation specifies expectation struct of the Filesystem.OpenFile
type FilesystemMockOpenFileExpectation struct {
	mock    *FilesystemMock
	params  *FilesystemMockOpenFileParams
	results *FilesystemMockOpenFileResults
	Counter uint64
}

// FilesystemMockOpenFileParams contains parameters of the Filesystem.OpenFile
type FilesystemMockOpenFileParams struct {
	filename string
	flag     int
	perm     os.FileMode
}

// FilesystemMockOpenFileResults contains results of the Filesystem.OpenFile
type FilesystemMockOpenFileResults struct {
	f1  mm_billy.File
	err error
}

// Expect sets up expected params for Filesystem.OpenFile
func (mmOpenFile *mFilesystemMockOpenFile) Expect(filename string, flag int, perm os.FileMode) *mFilesystemMockOpenFile {
	if mmOpenFile.mock.funcOpenFile != nil {
		mmOpenFile.mock.t.Fatalf("FilesystemMock.OpenFile mock is already set by Set")
	}

	if mmOpenFile.defaultExpectation == nil {
		mmOpenFile.defaultExpectation = &FilesystemMockOpenFileExpectation{}
	}

	mmOpenFile.defaultExpectation.params = &FilesystemMockOpenFileParams{filename, flag, perm}
	for _, e := range mmOpenFile.expectations {
		if minimock.Equal(e.params, mmOpenFile.defaultExpectation.params) {
			mmOpenFile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmOpenFile.defaultExpectation.params)
		}
	}

	return mmOpenFile
}

// Inspect accepts an inspector function that has same arguments as the Filesystem.OpenFile
func (mmOpenFile *mFilesystemMockOpenFile) Inspect(f func(filename string, flag int, perm os.FileMode)) *mFilesystemMockOpenFile {
	if mmOpenFile.mock.inspectFuncOpenFile != nil {
		mmOpenFile.mock.t.Fatalf("Inspect function is already set for FilesystemMock.OpenFile")
	}

	mmOpenFile.mock.inspectFuncOpenFile = f

	return mmOpenFile
}

// Return sets up results that will be returned by Filesystem.OpenFile
func (mmOpenFile *mFilesystemMockOpenFile) Return(f1 mm_billy.File, err error) *FilesystemMock {
	if mmOpenFile.mock.funcOpenFile != nil {
		mmOpenFile.mock.t.Fatalf("FilesystemMock.OpenFile mock is already set by Set")
	}

	if mmOpenFile.defaultExpectation == nil {
		mmOpenFile.defaultExpectation = &FilesystemMockOpenFileExpectation{mock: mmOpenFile.mock}
	}
	mmOpenFile.defaultExpectation.results = &FilesystemMockOpenFileResults{f1, err}
	return mmOpenFile.mock
}

// Set uses given function f to mock the Filesystem.OpenFile method
func (mmOpenFile *mFilesystemMockOpenFile) Set(f func(filename string, flag int, perm os.FileMode) (f1 mm_billy.File, err error)) *FilesystemMock {
	if mmOpenFile.defaultExpectation != nil {
		mmOpenFile.mock.t.Fatalf("Default expectation is already set for the Filesystem.OpenFile method")
	}

	if len(mmOpenFile.expectations) > 0 {
		mmOpenFile.mock.t.Fatalf("Some expectations are already set for the Filesystem.OpenFile method")
	}

	mmOpenFile.mock.funcOpenFile = f
	return mmOpenFile.mock
}

// When sets expectation for the Filesystem.OpenFile which will trigger the result defined by the following
// Then helper
func (mmOpenFile *mFilesystemMockOpenFile) When(filename string, flag int, perm os.FileMode) *FilesystemMockOpenFileExpectation {
	if mmOpenFile.mock.funcOpenFile != nil {
		mmOpenFile.mock.t.Fatalf("FilesystemMock.OpenFile mock is already set by Set")
	}

	expectation := &FilesystemMockOpenFileExpectation{
		mock:   mmOpenFile.mock,
		params: &FilesystemMockOpenFileParams{filename, flag, perm},
	}
	mmOpenFile.expectations = append(mmOpenFile.expectations, expectation)
	return expectation
}

// Then sets up Filesystem.OpenFile return parameters for the expectation previously defined by the When method
func (e *FilesystemMockOpenFileExpectation) Then(f1 mm_billy.File, err error) *FilesystemMock {
	e.results = &FilesystemMockOpenFileResults{f1, err}
	return e.mock
}

// OpenFile implements billy.Filesystem
func (mmOpenFile *FilesystemMock) OpenFile(filename string, flag int, perm os.FileMode) (f1 mm_billy.File, err error) {
	mm_atomic.AddUint64(&mmOpenFile.beforeOpenFileCounter, 1)
	defer mm_atomic.AddUint64(&mmOpenFile.afterOpenFileCounter, 1)

	if mmOpenFile.inspectFuncOpenFile != nil {
		mmOpenFile.inspectFuncOpenFile(filename, flag, perm)
	}

	mm_params := &FilesystemMockOpenFileParams{filename, flag, perm}

	// Record call args
	mmOpenFile.OpenFileMock.mutex.Lock()
	mmOpenFile.OpenFileMock.callArgs = append(mmOpenFile.OpenFileMock.callArgs, mm_params)
	mmOpenFile.OpenFileMock.mutex.Unlock()

	for _, e := range mmOpenFile.OpenFileMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.f1, e.results.err
		}
	}

	if mmOpenFile.OpenFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmOpenFile.OpenFileMock.defaultExpectation.Counter, 1)
		mm_want := mmOpenFile.OpenFileMock.defaultExpectation.params
		mm_got := FilesystemMockOpenFileParams{filename, flag, perm}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmOpenFile.t.Errorf("FilesystemMock.OpenFile got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmOpenFile.OpenFileMock.defaultExpectation.results
		if mm_results == nil {
			mmOpenFile.t.Fatal("No results are set for the FilesystemMock.OpenFile")
		}
		return (*mm_results).f1, (*mm_results).err
	}
	if mmOpenFile.funcOpenFile != nil {
		return mmOpenFile.funcOpenFile(filename, flag, perm)
	}
	mmOpenFile.t.Fatalf("Unexpected call to FilesystemMock.OpenFile. %v %v %v", filename, flag, perm)
	return
}

// OpenFileAfterCounter returns a count of finished FilesystemMock.OpenFile invocations
func (mmOpenFile *FilesystemMock) OpenFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOpenFile.afterOpenFileCounter)
}

// OpenFileBeforeCounter returns a count of FilesystemMock.OpenFile invocations
func (mmOpenFile *FilesystemMock) OpenFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOpenFile.beforeOpenFileCounter)
}

// Calls returns a list of arguments used in each call to FilesystemMock.OpenFile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmOpenFile *mFilesystemMockOpenFile) Calls() []*FilesystemMockOpenFileParams {
	mmOpenFile.mutex.RLock()

	argCopy := make([]*FilesystemMockOpenFileParams, len(mmOpenFile.callArgs))
	copy(argCopy, mmOpenFile.callArgs)

	mmOpenFile.mutex.RUnlock()

	return argCopy
}

// MinimockOpenFileDone returns true if the count of the OpenFile invocations corresponds
// the number of defined expectations
func (m *FilesystemMock) MinimockOpenFileDone() bool {
	for _, e := range m.OpenFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OpenFileMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOpenFileCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOpenFile != nil && mm_atomic.LoadUint64(&m.afterOpenFileCounter) < 1 {
		return false
	}
	return true
}

// MinimockOpenFileInspect logs each unmet expectation
func (m *FilesystemMock) MinimockOpenFileInspect() {
	for _, e := range m.OpenFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FilesystemMock.OpenFile with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OpenFileMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOpenFileCounter) < 1 {
		if m.OpenFileMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FilesystemMock.OpenFile")
		} else {
			m.t.Errorf("Expected call to FilesystemMock.OpenFile with params: %#v", *m.OpenFileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOpenFile != nil && mm_atomic.LoadUint64(&m.afterOpenFileCounter) < 1 {
		m.t.Error("Expected call to FilesystemMock.OpenFile")
	}
}

type mFilesystemMockReadDir struct {
	mock               *FilesystemMock
	defaultExpectation *FilesystemMockReadDirExpectation
	expectations       []*FilesystemMockReadDirExpectation

	callArgs []*FilesystemMockReadDirParams
	mutex    sync.RWMutex
}

// FilesystemMockReadDirExpectation specifies expectation struct of the Filesystem.ReadDir
type FilesystemMockReadDirExpectation struct {
	mock    *FilesystemMock
	params  *FilesystemMockReadDirParams
	results *FilesystemMockReadDirResults
	Counter uint64
}

// FilesystemMockReadDirParams contains parameters of the Filesystem.ReadDir
type FilesystemMockReadDirParams struct {
	path string
}

// FilesystemMockReadDirResults contains results of the Filesystem.ReadDir
type FilesystemMockReadDirResults struct {
	fa1 []os.FileInfo
	err error
}

// Expect sets up expected params for Filesystem.ReadDir
func (mmReadDir *mFilesystemMockReadDir) Expect(path string) *mFilesystemMockReadDir {
	if mmReadDir.mock.funcReadDir != nil {
		mmReadDir.mock.t.Fatalf("FilesystemMock.ReadDir mock is already set by Set")
	}

	if mmReadDir.defaultExpectation == nil {
		mmReadDir.defaultExpectation = &FilesystemMockReadDirExpectation{}
	}

	mmReadDir.defaultExpectation.params = &FilesystemMockReadDirParams{path}
	for _, e := range mmReadDir.expectations {
		if minimock.Equal(e.params, mmReadDir.defaultExpectation.params) {
			mmReadDir.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReadDir.defaultExpectation.params)
		}
	}

	return mmReadDir
}

// Inspect accepts an inspector function that has same arguments as the Filesystem.ReadDir
func (mmReadDir *mFilesystemMockReadDir) Inspect(f func(path string)) *mFilesystemMockReadDir {
	if mmReadDir.mock.inspectFuncReadDir != nil {
		mmReadDir.mock.t.Fatalf("Inspect function is already set for FilesystemMock.ReadDir")
	}

	mmReadDir.mock.inspectFuncReadDir = f

	return mmReadDir
}

// Return sets up results that will be returned by Filesystem.ReadDir
func (mmReadDir *mFilesystemMockReadDir) Return(fa1 []os.FileInfo, err error) *FilesystemMock {
	if mmReadDir.mock.funcReadDir != nil {
		mmReadDir.mock.t.Fatalf("FilesystemMock.ReadDir mock is already set by Set")
	}

	if mmReadDir.defaultExpectation == nil {
		mmReadDir.defaultExpectation = &FilesystemMockReadDirExpectation{mock: mmReadDir.mock}
	}
	mmReadDir.defaultExpectation.results = &FilesystemMockReadDirResults{fa1, err}
	return mmReadDir.mock
}

// Set uses given function f to mock the Filesystem.ReadDir method
func (mmReadDir *mFilesystemMockReadDir) Set(f func(path string) (fa1 []os.FileInfo, err error)) *FilesystemMock {
	if mmReadDir.defaultExpectation != nil {
		mmReadDir.mock.t.Fatalf("Default expectation is already set for the Filesystem.ReadDir method")
	}

	if len(mmReadDir.expectations) > 0 {
		mmReadDir.mock.t.Fatalf("Some expectations are already set for the Filesystem.ReadDir method")
	}

	mmReadDir.mock.funcReadDir = f
	return mmReadDir.mock
}

// When sets expectation for the Filesystem.ReadDir which will trigger the result defined by the following
// Then helper
func (mmReadDir *mFilesystemMockReadDir) When(path string) *FilesystemMockReadDirExpectation {
	if mmReadDir.mock.funcReadDir != nil {
		mmReadDir.mock.t.Fatalf("FilesystemMock.ReadDir mock is already set by Set")
	}

	expectation := &FilesystemMockReadDirExpectation{
		mock:   mmReadDir.mock,
		params: &FilesystemMockReadDirParams{path},
	}
	mmReadDir.expectations = append(mmReadDir.expectations, expectation)
	return expectation
}

// Then sets up Filesystem.ReadDir return parameters for the expectation previously defined by the When method
func (e *FilesystemMockReadDirExpectation) Then(fa1 []os.FileInfo, err error) *FilesystemMock {
	e.results = &FilesystemMockReadDirResults{fa1, err}
	return e.mock
}

// ReadDir implements billy.Filesystem
func (mmReadDir *FilesystemMock) ReadDir(path string) (fa1 []os.FileInfo, err error) {
	mm_atomic.AddUint64(&mmReadDir.beforeReadDirCounter, 1)
	defer mm_atomic.AddUint64(&mmReadDir.afterReadDirCounter, 1)

	if mmReadDir.inspectFuncReadDir != nil {
		mmReadDir.inspectFuncReadDir(path)
	}

	mm_params := &FilesystemMockReadDirParams{path}

	// Record call args
	mmReadDir.ReadDirMock.mutex.Lock()
	mmReadDir.ReadDirMock.callArgs = append(mmReadDir.ReadDirMock.callArgs, mm_params)
	mmReadDir.ReadDirMock.mutex.Unlock()

	for _, e := range mmReadDir.ReadDirMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.fa1, e.results.err
		}
	}

	if mmReadDir.ReadDirMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReadDir.ReadDirMock.defaultExpectation.Counter, 1)
		mm_want := mmReadDir.ReadDirMock.defaultExpectation.params
		mm_got := FilesystemMockReadDirParams{path}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReadDir.t.Errorf("FilesystemMock.ReadDir got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReadDir.ReadDirMock.defaultExpectation.results
		if mm_results == nil {
			mmReadDir.t.Fatal("No results are set for the FilesystemMock.ReadDir")
		}
		return (*mm_results).fa1, (*mm_results).err
	}
	if mmReadDir.funcReadDir != nil {
		return mmReadDir.funcReadDir(path)
	}
	mmReadDir.t.Fatalf("Unexpected call to FilesystemMock.ReadDir. %v", path)
	return
}

// ReadDirAfterCounter returns a count of finished FilesystemMock.ReadDir invocations
func (mmReadDir *FilesystemMock) ReadDirAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReadDir.afterReadDirCounter)
}

// ReadDirBeforeCounter returns a count of FilesystemMock.ReadDir invocations
func (mmReadDir *FilesystemMock) ReadDirBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReadDir.beforeReadDirCounter)
}

// Calls returns a list of arguments used in each call to FilesystemMock.ReadDir.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReadDir *mFilesystemMockReadDir) Calls() []*FilesystemMockReadDirParams {
	mmReadDir.mutex.RLock()

	argCopy := make([]*FilesystemMockReadDirParams, len(mmReadDir.callArgs))
	copy(argCopy, mmReadDir.callArgs)

	mmReadDir.mutex.RUnlock()

	return argCopy
}

// MinimockReadDirDone returns true if the count of the ReadDir invocations corresponds
// the number of defined expectations
func (m *FilesystemMock) MinimockReadDirDone() bool {
	for _, e := range m.ReadDirMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReadDirMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReadDirCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReadDir != nil && mm_atomic.LoadUint64(&m.afterReadDirCounter) < 1 {
		return false
	}
	return true
}

// MinimockReadDirInspect logs each unmet expectation
func (m *FilesystemMock) MinimockReadDirInspect() {
	for _, e := range m.ReadDirMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FilesystemMock.ReadDir with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReadDirMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReadDirCounter) < 1 {
		if m.ReadDirMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FilesystemMock.ReadDir")
		} else {
			m.t.Errorf("Expected call to FilesystemMock.ReadDir with params: %#v", *m.ReadDirMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReadDir != nil && mm_atomic.LoadUint64(&m.afterReadDirCounter) < 1 {
		m.t.Error("Expected call to FilesystemMock.ReadDir")
	}
}

type mFilesystemMockReadlink struct {
	mock               *FilesystemMock
	defaultExpectation *FilesystemMockReadlinkExpectation
	expectations       []*FilesystemMockReadlinkExpectation

	callArgs []*FilesystemMockReadlinkParams
	mutex    sync.RWMutex
}

// FilesystemMockReadlinkExpectation specifies expectation struct of the Filesystem.Readlink
type FilesystemMockReadlinkExpectation struct {
	mock    *FilesystemMock
	params  *FilesystemMockReadlinkParams
	results *FilesystemMockReadlinkResults
	Counter uint64
}

// FilesystemMockReadlinkParams contains parameters of the Filesystem.Readlink
type FilesystemMockReadlinkParams struct {
	link string
}

// FilesystemMockReadlinkResults contains results of the Filesystem.Readlink
type FilesystemMockReadlinkResults struct {
	s1  string
	err error
}

// Expect sets up expected params for Filesystem.Readlink
func (mmReadlink *mFilesystemMockReadlink) Expect(link string) *mFilesystemMockReadlink {
	if mmReadlink.mock.funcReadlink != nil {
		mmReadlink.mock.t.Fatalf("FilesystemMock.Readlink mock is already set by Set")
	}

	if mmReadlink.defaultExpectation == nil {
		mmReadlink.defaultExpectation = &FilesystemMockReadlinkExpectation{}
	}

	mmReadlink.defaultExpectation.params = &FilesystemMockReadlinkParams{link}
	for _, e := range mmReadlink.expectations {
		if minimock.Equal(e.params, mmReadlink.defaultExpectation.params) {
			mmReadlink.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReadlink.defaultExpectation.params)
		}
	}

	return mmReadlink
}

// Inspect accepts an inspector function that has same arguments as the Filesystem.Readlink
func (mmReadlink *mFilesystemMockReadlink) Inspect(f func(link string)) *mFilesystemMockReadlink {
	if mmReadlink.mock.inspectFuncReadlink != nil {
		mmReadlink.mock.t.Fatalf("Inspect function is already set for FilesystemMock.Readlink")
	}

	mmReadlink.mock.inspectFuncReadlink = f

	return mmReadlink
}

// Return sets up results that will be returned by Filesystem.Readlink
func (mmReadlink *mFilesystemMockReadlink) Return(s1 string, err error) *FilesystemMock {
	if mmReadlink.mock.funcReadlink != nil {
		mmReadlink.mock.t.Fatalf("FilesystemMock.Readlink mock is already set by Set")
	}

	if mmReadlink.defaultExpectation == nil {
		mmReadlink.defaultExpectation = &FilesystemMockReadlinkExpectation{mock: mmReadlink.mock}
	}
	mmReadlink.defaultExpectation.results = &FilesystemMockReadlinkResults{s1, err}
	return mmReadlink.mock
}

// Set uses given function f to mock the Filesystem.Readlink method
func (mmReadlink *mFilesystemMockReadlink) Set(f func(link string) (s1 string, err error)) *FilesystemMock {
	if mmReadlink.defaultExpectation != nil {
		mmReadlink.mock.t.Fatalf("Default expectation is already set for the Filesystem.Readlink method")
	}

	if len(mmReadlink.expectations) > 0 {
		mmReadlink.mock.t.Fatalf("Some expectations are already set for the Filesystem.Readlink method")
	}

	mmReadlink.mock.funcReadlink = f
	return mmReadlink.mock
}

// When sets expectation for the Filesystem.Readlink which will trigger the result defined by the following
// Then helper
func (mmReadlink *mFilesystemMockReadlink) When(link string) *FilesystemMockReadlinkExpectation {
	if mmReadlink.mock.funcReadlink != nil {
		mmReadlink.mock.t.Fatalf("FilesystemMock.Readlink mock is already set by Set")
	}

	expectation := &FilesystemMockReadlinkExpectation{
		mock:   mmReadlink.mock,
		params: &FilesystemMockReadlinkParams{link},
	}
	mmReadlink.expectations = append(mmReadlink.expectations, expectation)
	return expectation
}

// Then sets up Filesystem.Readlink return parameters for the expectation previously defined by the When method
func (e *FilesystemMockReadlinkExpectation) Then(s1 string, err error) *FilesystemMock {
	e.results = &FilesystemMockReadlinkResults{s1, err}
	return e.mock
}

// Readlink implements billy.Filesystem
func (mmReadlink *FilesystemMock) Readlink(link string) (s1 string, err error) {
	mm_atomic.AddUint64(&mmReadlink.beforeReadlinkCounter, 1)
	defer mm_atomic.AddUint64(&mmReadlink.afterReadlinkCounter, 1)

	if mmReadlink.inspectFuncReadlink != nil {
		mmReadlink.inspectFuncReadlink(link)
	}

	mm_params := &FilesystemMockReadlinkParams{link}

	// Record call args
	mmReadlink.ReadlinkMock.mutex.Lock()
	mmReadlink.ReadlinkMock.callArgs = append(mmReadlink.ReadlinkMock.callArgs, mm_params)
	mmReadlink.ReadlinkMock.mutex.Unlock()

	for _, e := range mmReadlink.ReadlinkMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmReadlink.ReadlinkMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReadlink.ReadlinkMock.defaultExpectation.Counter, 1)
		mm_want := mmReadlink.ReadlinkMock.defaultExpectation.params
		mm_got := FilesystemMockReadlinkParams{link}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReadlink.t.Errorf("FilesystemMock.Readlink got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReadlink.ReadlinkMock.defaultExpectation.results
		if mm_results == nil {
			mmReadlink.t.Fatal("No results are set for the FilesystemMock.Readlink")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmReadlink.funcReadlink != nil {
		return mmReadlink.funcReadlink(link)
	}
	mmReadlink.t.Fatalf("Unexpected call to FilesystemMock.Readlink. %v", link)
	return
}

// ReadlinkAfterCounter returns a count of finished FilesystemMock.Readlink invocations
func (mmReadlink *FilesystemMock) ReadlinkAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReadlink.afterReadlinkCounter)
}

// ReadlinkBeforeCounter returns a count of FilesystemMock.Readlink invocations
func (mmReadlink *FilesystemMock) ReadlinkBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReadlink.beforeReadlinkCounter)
}

// Calls returns a list of arguments used in each call to FilesystemMock.Readlink.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReadlink *mFilesystemMockReadlink) Calls() []*FilesystemMockReadlinkParams {
	mmReadlink.mutex.RLock()

	argCopy := make([]*FilesystemMockReadlinkParams, len(mmReadlink.callArgs))
	copy(argCopy, mmReadlink.callArgs)

	mmReadlink.mutex.RUnlock()

	return argCopy
}

// MinimockReadlinkDone returns true if the count of the Readlink invocations corresponds
// the number of defined expectations
func (m *FilesystemMock) MinimockReadlinkDone() bool {
	for _, e := range m.ReadlinkMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReadlinkMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReadlinkCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReadlink != nil && mm_atomic.LoadUint64(&m.afterReadlinkCounter) < 1 {
		return false
	}
	return true
}

// MinimockReadlinkInspect logs each unmet expectation
func (m *FilesystemMock) MinimockReadlinkInspect() {
	for _, e := range m.ReadlinkMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FilesystemMock.Readlink with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReadlinkMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReadlinkCounter) < 1 {
		if m.ReadlinkMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FilesystemMock.Readlink")
		} else {
			m.t.Errorf("Expected call to FilesystemMock.Readlink with params: %#v", *m.ReadlinkMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReadlink != nil && mm_atomic.LoadUint64(&m.afterReadlinkCounter) < 1 {
		m.t.Error("Expected call to FilesystemMock.Readlink")
	}
}

type mFilesystemMockRemove struct {
	mock               *FilesystemMock
	defaultExpectation *FilesystemMockRemoveExpectation
	expectations       []*FilesystemMockRemoveExpectation

	callArgs []*FilesystemMockRemoveParams
	mutex    sync.RWMutex
}

// FilesystemMockRemoveExpectation specifies expectation struct of the Filesystem.Remove
type FilesystemMockRemoveExpectation struct {
	mock    *FilesystemMock
	params  *FilesystemMockRemoveParams
	results *FilesystemMockRemoveResults
	Counter uint64
}

// FilesystemMockRemoveParams contains parameters of the Filesystem.Remove
type FilesystemMockRemoveParams struct {
	filename string
}

// FilesystemMockRemoveResults contains results of the Filesystem.Remove
type FilesystemMockRemoveResults struct {
	err error
}

// Expect sets up expected params for Filesystem.Remove
func (mmRemove *mFilesystemMockRemove) Expect(filename string) *mFilesystemMockRemove {
	if mmRemove.mock.funcRemove != nil {
		mmRemove.mock.t.Fatalf("FilesystemMock.Remove mock is already set by Set")
	}

	if mmRemove.defaultExpectation == nil {
		mmRemove.defaultExpectation = &FilesystemMockRemoveExpectation{}
	}

	mmRemove.defaultExpectation.params = &FilesystemMockRemoveParams{filename}
	for _, e := range mmRemove.expectations {
		if minimock.Equal(e.params, mmRemove.defaultExpectation.params) {
			mmRemove.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRemove.defaultExpectation.params)
		}
	}

	return mmRemove
}

// Inspect accepts an inspector function that has same arguments as the Filesystem.Remove
func (mmRemove *mFilesystemMockRemove) Inspect(f func(filename string)) *mFilesystemMockRemove {
	if mmRemove.mock.inspectFuncRemove != nil {
		mmRemove.mock.t.Fatalf("Inspect function is already set for FilesystemMock.Remove")
	}

	mmRemove.mock.inspectFuncRemove = f

	return mmRemove
}

// Return sets up results that will be returned by Filesystem.Remove
func (mmRemove *mFilesystemMockRemove) Return(err error) *FilesystemMock {
	if mmRemove.mock.funcRemove != nil {
		mmRemove.mock.t.Fatalf("FilesystemMock.Remove mock is already set by Set")
	}

	if mmRemove.defaultExpectation == nil {
		mmRemove.defaultExpectation = &FilesystemMockRemoveExpectation{mock: mmRemove.mock}
	}
	mmRemove.defaultExpectation.results = &FilesystemMockRemoveResults{err}
	return mmRemove.mock
}

// Set uses given function f to mock the Filesystem.Remove method
func (mmRemove *mFilesystemMockRemove) Set(f func(filename string) (err error)) *FilesystemMock {
	if mmRemove.defaultExpectation != nil {
		mmRemove.mock.t.Fatalf("Default expectation is already set for the Filesystem.Remove method")
	}

	if len(mmRemove.expectations) > 0 {
		mmRemove.mock.t.Fatalf("Some expectations are already set for the Filesystem.Remove method")
	}

	mmRemove.mock.funcRemove = f
	return mmRemove.mock
}

// When sets expectation for the Filesystem.Remove which will trigger the result defined by the following
// Then helper
func (mmRemove *mFilesystemMockRemove) When(filename string) *FilesystemMockRemoveExpectation {
	if mmRemove.mock.funcRemove != nil {
		mmRemove.mock.t.Fatalf("FilesystemMock.Remove mock is already set by Set")
	}

	expectation := &FilesystemMockRemoveExpectation{
		mock:   mmRemove.mock,
		params: &FilesystemMockRemoveParams{filename},
	}
	mmRemove.expectations = append(mmRemove.expectations, expectation)
	return expectation
}

// Then sets up Filesystem.Remove return parameters for the expectation previously defined by the When method
func (e *FilesystemMockRemoveExpectation) Then(err error) *FilesystemMock {
	e.results = &FilesystemMockRemoveResults{err}
	return e.mock
}

// Remove implements billy.Filesystem
func (mmRemove *FilesystemMock) Remove(filename string) (err error) {
	mm_atomic.AddUint64(&mmRemove.beforeRemoveCounter, 1)
	defer mm_atomic.AddUint64(&mmRemove.afterRemoveCounter, 1)

	if mmRemove.inspectFuncRemove != nil {
		mmRemove.inspectFuncRemove(filename)
	}

	mm_params := &FilesystemMockRemoveParams{filename}

	// Record call args
	mmRemove.RemoveMock.mutex.Lock()
	mmRemove.RemoveMock.callArgs = append(mmRemove.RemoveMock.callArgs, mm_params)
	mmRemove.RemoveMock.mutex.Unlock()

	for _, e := range mmRemove.RemoveMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRemove.RemoveMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRemove.RemoveMock.defaultExpectation.Counter, 1)
		mm_want := mmRemove.RemoveMock.defaultExpectation.params
		mm_got := FilesystemMockRemoveParams{filename}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRemove.t.Errorf("FilesystemMock.Remove got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRemove.RemoveMock.defaultExpectation.results
		if mm_results == nil {
			mmRemove.t.Fatal("No results are set for the FilesystemMock.Remove")
		}
		return (*mm_results).err
	}
	if mmRemove.funcRemove != nil {
		return mmRemove.funcRemove(filename)
	}
	mmRemove.t.Fatalf("Unexpected call to FilesystemMock.Remove. %v", filename)
	return
}

// RemoveAfterCounter returns a count of finished FilesystemMock.Remove invocations
func (mmRemove *FilesystemMock) RemoveAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemove.afterRemoveCounter)
}

// RemoveBeforeCounter returns a count of FilesystemMock.Remove invocations
func (mmRemove *FilesystemMock) RemoveBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemove.beforeRemoveCounter)
}

// Calls returns a list of arguments used in each call to FilesystemMock.Remove.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRemove *mFilesystemMockRemove) Calls() []*FilesystemMockRemoveParams {
	mmRemove.mutex.RLock()

	argCopy := make([]*FilesystemMockRemoveParams, len(mmRemove.callArgs))
	copy(argCopy, mmRemove.callArgs)

	mmRemove.mutex.RUnlock()

	return argCopy
}

// MinimockRemoveDone returns true if the count of the Remove invocations corresponds
// the number of defined expectations
func (m *FilesystemMock) MinimockRemoveDone() bool {
	for _, e := range m.RemoveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RemoveMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRemoveCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemove != nil && mm_atomic.LoadUint64(&m.afterRemoveCounter) < 1 {
		return false
	}
	return true
}

// MinimockRemoveInspect logs each unmet expectation
func (m *FilesystemMock) MinimockRemoveInspect() {
	for _, e := range m.RemoveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FilesystemMock.Remove with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RemoveMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRemoveCounter) < 1 {
		if m.RemoveMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FilesystemMock.Remove")
		} else {
			m.t.Errorf("Expected call to FilesystemMock.Remove with params: %#v", *m.RemoveMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemove != nil && mm_atomic.LoadUint64(&m.afterRemoveCounter) < 1 {
		m.t.Error("Expected call to FilesystemMock.Remove")
	}
}

type mFilesystemMockRename struct {
	mock               *FilesystemMock
	defaultExpectation *FilesystemMockRenameExpectation
	expectations       []*FilesystemMockRenameExpectation

	callArgs []*FilesystemMockRenameParams
	mutex    sync.RWMutex
}

// FilesystemMockRenameExpectation specifies expectation struct of the Filesystem.Rename
type FilesystemMockRenameExpectation struct {
	mock    *FilesystemMock
	params  *FilesystemMockRenameParams
	results *FilesystemMockRenameResults
	Counter uint64
}

// FilesystemMockRenameParams contains parameters of the Filesystem.Rename
type FilesystemMockRenameParams struct {
	oldpath string
	newpath string
}

// FilesystemMockRenameResults contains results of the Filesystem.Rename
type FilesystemMockRenameResults struct {
	err error
}

// Expect sets up expected params for Filesystem.Rename
func (mmRename *mFilesystemMockRename) Expect(oldpath string, newpath string) *mFilesystemMockRename {
	if mmRename.mock.funcRename != nil {
		mmRename.mock.t.Fatalf("FilesystemMock.Rename mock is already set by Set")
	}

	if mmRename.defaultExpectation == nil {
		mmRename.defaultExpectation = &FilesystemMockRenameExpectation{}
	}

	mmRename.defaultExpectation.params = &FilesystemMockRenameParams{oldpath, newpath}
	for _, e := range mmRename.expectations {
		if minimock.Equal(e.params, mmRename.defaultExpectation.params) {
			mmRename.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRename.defaultExpectation.params)
		}
	}

	return mmRename
}

// Inspect accepts an inspector function that has same arguments as the Filesystem.Rename
func (mmRename *mFilesystemMockRename) Inspect(f func(oldpath string, newpath string)) *mFilesystemMockRename {
	if mmRename.mock.inspectFuncRename != nil {
		mmRename.mock.t.Fatalf("Inspect function is already set for FilesystemMock.Rename")
	}

	mmRename.mock.inspectFuncRename = f

	return mmRename
}

// Return sets up results that will be returned by Filesystem.Rename
func (mmRename *mFilesystemMockRename) Return(err error) *FilesystemMock {
	if mmRename.mock.funcRename != nil {
		mmRename.mock.t.Fatalf("FilesystemMock.Rename mock is already set by Set")
	}

	if mmRename.defaultExpectation == nil {
		mmRename.defaultExpectation = &FilesystemMockRenameExpectation{mock: mmRename.mock}
	}
	mmRename.defaultExpectation.results = &FilesystemMockRenameResults{err}
	return mmRename.mock
}

// Set uses given function f to mock the Filesystem.Rename method
func (mmRename *mFilesystemMockRename) Set(f func(oldpath string, newpath string) (err error)) *FilesystemMock {
	if mmRename.defaultExpectation != nil {
		mmRename.mock.t.Fatalf("Default expectation is already set for the Filesystem.Rename method")
	}

	if len(mmRename.expectations) > 0 {
		mmRename.mock.t.Fatalf("Some expectations are already set for the Filesystem.Rename method")
	}

	mmRename.mock.funcRename = f
	return mmRename.mock
}

// When sets expectation for the Filesystem.Rename which will trigger the result defined by the following
// Then helper
func (mmRename *mFilesystemMockRename) When(oldpath string, newpath string) *FilesystemMockRenameExpectation {
	if mmRename.mock.funcRename != nil {
		mmRename.mock.t.Fatalf("FilesystemMock.Rename mock is already set by Set")
	}

	expectation := &FilesystemMockRenameExpectation{
		mock:   mmRename.mock,
		params: &FilesystemMockRenameParams{oldpath, newpath},
	}
	mmRename.expectations = append(mmRename.expectations, expectation)
	return expectation
}

// Then sets up Filesystem.Rename return parameters for the expectation previously defined by the When method
func (e *FilesystemMockRenameExpectation) Then(err error) *FilesystemMock {
	e.results = &FilesystemMockRenameResults{err}
	return e.mock
}

// Rename implements billy.Filesystem
func (mmRename *FilesystemMock) Rename(oldpath string, newpath string) (err error) {
	mm_atomic.AddUint64(&mmRename.beforeRenameCounter, 1)
	defer mm_atomic.AddUint64(&mmRename.afterRenameCounter, 1)

	if mmRename.inspectFuncRename != nil {
		mmRename.inspectFuncRename(oldpath, newpath)
	}

	mm_params := &FilesystemMockRenameParams{oldpath, newpath}

	// Record call args
	mmRename.RenameMock.mutex.Lock()
	mmRename.RenameMock.callArgs = append(mmRename.RenameMock.callArgs, mm_params)
	mmRename.RenameMock.mutex.Unlock()

	for _, e := range mmRename.RenameMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRename.RenameMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRename.RenameMock.defaultExpectation.Counter, 1)
		mm_want := mmRename.RenameMock.defaultExpectation.params
		mm_got := FilesystemMockRenameParams{oldpath, newpath}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRename.t.Errorf("FilesystemMock.Rename got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRename.RenameMock.defaultExpectation.results
		if mm_results == nil {
			mmRename.t.Fatal("No results are set for the FilesystemMock.Rename")
		}
		return (*mm_results).err
	}
	if mmRename.funcRename != nil {
		return mmRename.funcRename(oldpath, newpath)
	}
	mmRename.t.Fatalf("Unexpected call to FilesystemMock.Rename. %v %v", oldpath, newpath)
	return
}

// RenameAfterCounter returns a count of finished FilesystemMock.Rename invocations
func (mmRename *FilesystemMock) RenameAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRename.afterRenameCounter)
}

// RenameBeforeCounter returns a count of FilesystemMock.Rename invocations
func (mmRename *FilesystemMock) RenameBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRename.beforeRenameCounter)
}

// Calls returns a list of arguments used in each call to FilesystemMock.Rename.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRename *mFilesystemMockRename) Calls() []*FilesystemMockRenameParams {
	mmRename.mutex.RLock()

	argCopy := make([]*FilesystemMockRenameParams, len(mmRename.callArgs))
	copy(argCopy, mmRename.callArgs)

	mmRename.mutex.RUnlock()

	return argCopy
}

// MinimockRenameDone returns true if the count of the Rename invocations corresponds
// the number of defined expectations
func (m *FilesystemMock) MinimockRenameDone() bool {
	for _, e := range m.RenameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RenameMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRenameCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRename != nil && mm_atomic.LoadUint64(&m.afterRenameCounter) < 1 {
		return false
	}
	return true
}

// MinimockRenameInspect logs each unmet expectation
func (m *FilesystemMock) MinimockRenameInspect() {
	for _, e := range m.RenameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FilesystemMock.Rename with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RenameMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRenameCounter) < 1 {
		if m.RenameMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FilesystemMock.Rename")
		} else {
			m.t.Errorf("Expected call to FilesystemMock.Rename with params: %#v", *m.RenameMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRename != nil && mm_atomic.LoadUint64(&m.afterRenameCounter) < 1 {
		m.t.Error("Expected call to FilesystemMock.Rename")
	}
}

type mFilesystemMockRoot struct {
	mock               *FilesystemMock
	defaultExpectation *FilesystemMockRootExpectation
	expectations       []*FilesystemMockRootExpectation
}

// FilesystemMockRootExpectation specifies expectation struct of the Filesystem.Root
type FilesystemMockRootExpectation struct {
	mock *FilesystemMock

	results *FilesystemMockRootResults
	Counter uint64
}

// FilesystemMockRootResults contains results of the Filesystem.Root
type FilesystemMockRootResults struct {
	s1 string
}

// Expect sets up expected params for Filesystem.Root
func (mmRoot *mFilesystemMockRoot) Expect() *mFilesystemMockRoot {
	if mmRoot.mock.funcRoot != nil {
		mmRoot.mock.t.Fatalf("FilesystemMock.Root mock is already set by Set")
	}

	if mmRoot.defaultExpectation == nil {
		mmRoot.defaultExpectation = &FilesystemMockRootExpectation{}
	}

	return mmRoot
}

// Inspect accepts an inspector function that has same arguments as the Filesystem.Root
func (mmRoot *mFilesystemMockRoot) Inspect(f func()) *mFilesystemMockRoot {
	if mmRoot.mock.inspectFuncRoot != nil {
		mmRoot.mock.t.Fatalf("Inspect function is already set for FilesystemMock.Root")
	}

	mmRoot.mock.inspectFuncRoot = f

	return mmRoot
}

// Return sets up results that will be returned by Filesystem.Root
func (mmRoot *mFilesystemMockRoot) Return(s1 string) *FilesystemMock {
	if mmRoot.mock.funcRoot != nil {
		mmRoot.mock.t.Fatalf("FilesystemMock.Root mock is already set by Set")
	}

	if mmRoot.defaultExpectation == nil {
		mmRoot.defaultExpectation = &FilesystemMockRootExpectation{mock: mmRoot.mock}
	}
	mmRoot.defaultExpectation.results = &FilesystemMockRootResults{s1}
	return mmRoot.mock
}

// Set uses given function f to mock the Filesystem.Root method
func (mmRoot *mFilesystemMockRoot) Set(f func() (s1 string)) *FilesystemMock {
	if mmRoot.defaultExpectation != nil {
		mmRoot.mock.t.Fatalf("Default expectation is already set for the Filesystem.Root method")
	}

	if len(mmRoot.expectations) > 0 {
		mmRoot.mock.t.Fatalf("Some expectations are already set for the Filesystem.Root method")
	}

	mmRoot.mock.funcRoot = f
	return mmRoot.mock
}

// Root implements billy.Filesystem
func (mmRoot *FilesystemMock) Root() (s1 string) {
	mm_atomic.AddUint64(&mmRoot.beforeRootCounter, 1)
	defer mm_atomic.AddUint64(&mmRoot.afterRootCounter, 1)

	if mmRoot.inspectFuncRoot != nil {
		mmRoot.inspectFuncRoot()
	}

	if mmRoot.RootMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRoot.RootMock.defaultExpectation.Counter, 1)

		mm_results := mmRoot.RootMock.defaultExpectation.results
		if mm_results == nil {
			mmRoot.t.Fatal("No results are set for the FilesystemMock.Root")
		}
		return (*mm_results).s1
	}
	if mmRoot.funcRoot != nil {
		return mmRoot.funcRoot()
	}
	mmRoot.t.Fatalf("Unexpected call to FilesystemMock.Root.")
	return
}

// RootAfterCounter returns a count of finished FilesystemMock.Root invocations
func (mmRoot *FilesystemMock) RootAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRoot.afterRootCounter)
}

// RootBeforeCounter returns a count of FilesystemMock.Root invocations
func (mmRoot *FilesystemMock) RootBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRoot.beforeRootCounter)
}

// MinimockRootDone returns true if the count of the Root invocations corresponds
// the number of defined expectations
func (m *FilesystemMock) MinimockRootDone() bool {
	for _, e := range m.RootMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RootMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRootCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRoot != nil && mm_atomic.LoadUint64(&m.afterRootCounter) < 1 {
		return false
	}
	return true
}

// MinimockRootInspect logs each unmet expectation
func (m *FilesystemMock) MinimockRootInspect() {
	for _, e := range m.RootMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to FilesystemMock.Root")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RootMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRootCounter) < 1 {
		m.t.Error("Expected call to FilesystemMock.Root")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRoot != nil && mm_atomic.LoadUint64(&m.afterRootCounter) < 1 {
		m.t.Error("Expected call to FilesystemMock.Root")
	}
}

type mFilesystemMockStat struct {
	mock               *FilesystemMock
	defaultExpectation *FilesystemMockStatExpectation
	expectations       []*FilesystemMockStatExpectation

	callArgs []*FilesystemMockStatParams
	mutex    sync.RWMutex
}

// FilesystemMockStatExpectation specifies expectation struct of the Filesystem.Stat
type FilesystemMockStatExpectation struct {
	mock    *FilesystemMock
	params  *FilesystemMockStatParams
	results *FilesystemMockStatResults
	Counter uint64
}

// FilesystemMockStatParams contains parameters of the Filesystem.Stat
type FilesystemMockStatParams struct {
	filename string
}

// FilesystemMockStatResults contains results of the Filesystem.Stat
type FilesystemMockStatResults struct {
	f1  os.FileInfo
	err error
}

// Expect sets up expected params for Filesystem.Stat
func (mmStat *mFilesystemMockStat) Expect(filename string) *mFilesystemMockStat {
	if mmStat.mock.funcStat != nil {
		mmStat.mock.t.Fatalf("FilesystemMock.Stat mock is already set by Set")
	}

	if mmStat.defaultExpectation == nil {
		mmStat.defaultExpectation = &FilesystemMockStatExpectation{}
	}

	mmStat.defaultExpectation.params = &FilesystemMockStatParams{filename}
	for _, e := range mmStat.expectations {
		if minimock.Equal(e.params, mmStat.defaultExpectation.params) {
			mmStat.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmStat.defaultExpectation.params)
		}
	}

	return mmStat
}

// Inspect accepts an inspector function that has same arguments as the Filesystem.Stat
func (mmStat *mFilesystemMockStat) Inspect(f func(filename string)) *mFilesystemMockStat {
	if mmStat.mock.inspectFuncStat != nil {
		mmStat.mock.t.Fatalf("Inspect function is already set for FilesystemMock.Stat")
	}

	mmStat.mock.inspectFuncStat = f

	return mmStat
}

// Return sets up results that will be returned by Filesystem.Stat
func (mmStat *mFilesystemMockStat) Return(f1 os.FileInfo, err error) *FilesystemMock {
	if mmStat.mock.funcStat != nil {
		mmStat.mock.t.Fatalf("FilesystemMock.Stat mock is already set by Set")
	}

	if mmStat.defaultExpectation == nil {
		mmStat.defaultExpectation = &FilesystemMockStatExpectation{mock: mmStat.mock}
	}
	mmStat.defaultExpectation.results = &FilesystemMockStatResults{f1, err}
	return mmStat.mock
}

// Set uses given function f to mock the Filesystem.Stat method
func (mmStat *mFilesystemMockStat) Set(f func(filename string) (f1 os.FileInfo, err error)) *FilesystemMock {
	if mmStat.defaultExpectation != nil {
		mmStat.mock.t.Fatalf("Default expectation is already set for the Filesystem.Stat method")
	}

	if len(mmStat.expectations) > 0 {
		mmStat.mock.t.Fatalf("Some expectations are already set for the Filesystem.Stat method")
	}

	mmStat.mock.funcStat = f
	return mmStat.mock
}

// When sets expectation for the Filesystem.Stat which will trigger the result defined by the following
// Then helper
func (mmStat *mFilesystemMockStat) When(filename string) *FilesystemMockStatExpectation {
	if mmStat.mock.funcStat != nil {
		mmStat.mock.t.Fatalf("FilesystemMock.Stat mock is already set by Set")
	}

	expectation := &FilesystemMockStatExpectation{
		mock:   mmStat.mock,
		params: &FilesystemMockStatParams{filename},
	}
	mmStat.expectations = append(mmStat.expectations, expectation)
	return expectation
}

// Then sets up Filesystem.Stat return parameters for the expectation previously defined by the When method
func (e *FilesystemMockStatExpectation) Then(f1 os.FileInfo, err error) *FilesystemMock {
	e.results = &FilesystemMockStatResults{f1, err}
	return e.mock
}

// Stat implements billy.Filesystem
func (mmStat *FilesystemMock) Stat(filename string) (f1 os.FileInfo, err error) {
	mm_atomic.AddUint64(&mmStat.beforeStatCounter, 1)
	defer mm_atomic.AddUint64(&mmStat.afterStatCounter, 1)

	if mmStat.inspectFuncStat != nil {
		mmStat.inspectFuncStat(filename)
	}

	mm_params := &FilesystemMockStatParams{filename}

	// Record call args
	mmStat.StatMock.mutex.Lock()
	mmStat.StatMock.callArgs = append(mmStat.StatMock.callArgs, mm_params)
	mmStat.StatMock.mutex.Unlock()

	for _, e := range mmStat.StatMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.f1, e.results.err
		}
	}

	if mmStat.StatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmStat.StatMock.defaultExpectation.Counter, 1)
		mm_want := mmStat.StatMock.defaultExpectation.params
		mm_got := FilesystemMockStatParams{filename}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmStat.t.Errorf("FilesystemMock.Stat got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmStat.StatMock.defaultExpectation.results
		if mm_results == nil {
			mmStat.t.Fatal("No results are set for the FilesystemMock.Stat")
		}
		return (*mm_results).f1, (*mm_results).err
	}
	if mmStat.funcStat != nil {
		return mmStat.funcStat(filename)
	}
	mmStat.t.Fatalf("Unexpected call to FilesystemMock.Stat. %v", filename)
	return
}

// StatAfterCounter returns a count of finished FilesystemMock.Stat invocations
func (mmStat *FilesystemMock) StatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStat.afterStatCounter)
}

// StatBeforeCounter returns a count of FilesystemMock.Stat invocations
func (mmStat *FilesystemMock) StatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStat.beforeStatCounter)
}

// Calls returns a list of arguments used in each call to FilesystemMock.Stat.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmStat *mFilesystemMockStat) Calls() []*FilesystemMockStatParams {
	mmStat.mutex.RLock()

	argCopy := make([]*FilesystemMockStatParams, len(mmStat.callArgs))
	copy(argCopy, mmStat.callArgs)

	mmStat.mutex.RUnlock()

	return argCopy
}

// MinimockStatDone returns true if the count of the Stat invocations corresponds
// the number of defined expectations
func (m *FilesystemMock) MinimockStatDone() bool {
	for _, e := range m.StatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStatCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStat != nil && mm_atomic.LoadUint64(&m.afterStatCounter) < 1 {
		return false
	}
	return true
}

// MinimockStatInspect logs each unmet expectation
func (m *FilesystemMock) MinimockStatInspect() {
	for _, e := range m.StatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FilesystemMock.Stat with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStatCounter) < 1 {
		if m.StatMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FilesystemMock.Stat")
		} else {
			m.t.Errorf("Expected call to FilesystemMock.Stat with params: %#v", *m.StatMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStat != nil && mm_atomic.LoadUint64(&m.afterStatCounter) < 1 {
		m.t.Error("Expected call to FilesystemMock.Stat")
	}
}

type mFilesystemMockSymlink struct {
	mock               *FilesystemMock
	defaultExpectation *FilesystemMockSymlinkExpectation
	expectations       []*FilesystemMockSymlinkExpectation

	callArgs []*FilesystemMockSymlinkParams
	mutex    sync.RWMutex
}

// FilesystemMockSymlinkExpectation specifies expectation struct of the Filesystem.Symlink
type FilesystemMockSymlinkExpectation struct {
	mock    *FilesystemMock
	params  *FilesystemMockSymlinkParams
	results *FilesystemMockSymlinkResults
	Counter uint64
}

// FilesystemMockSymlinkParams contains parameters of the Filesystem.Symlink
type FilesystemMockSymlinkParams struct {
	target string
	link   string
}

// FilesystemMockSymlinkResults contains results of the Filesystem.Symlink
type FilesystemMockSymlinkResults struct {
	err error
}

// Expect sets up expected params for Filesystem.Symlink
func (mmSymlink *mFilesystemMockSymlink) Expect(target string, link string) *mFilesystemMockSymlink {
	if mmSymlink.mock.funcSymlink != nil {
		mmSymlink.mock.t.Fatalf("FilesystemMock.Symlink mock is already set by Set")
	}

	if mmSymlink.defaultExpectation == nil {
		mmSymlink.defaultExpectation = &FilesystemMockSymlinkExpectation{}
	}

	mmSymlink.defaultExpectation.params = &FilesystemMockSymlinkParams{target, link}
	for _, e := range mmSymlink.expectations {
		if minimock.Equal(e.params, mmSymlink.defaultExpectation.params) {
			mmSymlink.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSymlink.defaultExpectation.params)
		}
	}

	return mmSymlink
}

// Inspect accepts an inspector function that has same arguments as the Filesystem.Symlink
func (mmSymlink *mFilesystemMockSymlink) Inspect(f func(target string, link string)) *mFilesystemMockSymlink {
	if mmSymlink.mock.inspectFuncSymlink != nil {
		mmSymlink.mock.t.Fatalf("Inspect function is already set for FilesystemMock.Symlink")
	}

	mmSymlink.mock.inspectFuncSymlink = f

	return mmSymlink
}

// Return sets up results that will be returned by Filesystem.Symlink
func (mmSymlink *mFilesystemMockSymlink) Return(err error) *FilesystemMock {
	if mmSymlink.mock.funcSymlink != nil {
		mmSymlink.mock.t.Fatalf("FilesystemMock.Symlink mock is already set by Set")
	}

	if mmSymlink.defaultExpectation == nil {
		mmSymlink.defaultExpectation = &FilesystemMockSymlinkExpectation{mock: mmSymlink.mock}
	}
	mmSymlink.defaultExpectation.results = &FilesystemMockSymlinkResults{err}
	return mmSymlink.mock
}

// Set uses given function f to mock the Filesystem.Symlink method
func (mmSymlink *mFilesystemMockSymlink) Set(f func(target string, link string) (err error)) *FilesystemMock {
	if mmSymlink.defaultExpectation != nil {
		mmSymlink.mock.t.Fatalf("Default expectation is already set for the Filesystem.Symlink method")
	}

	if len(mmSymlink.expectations) > 0 {
		mmSymlink.mock.t.Fatalf("Some expectations are already set for the Filesystem.Symlink method")
	}

	mmSymlink.mock.funcSymlink = f
	return mmSymlink.mock
}

// When sets expectation for the Filesystem.Symlink which will trigger the result defined by the following
// Then helper
func (mmSymlink *mFilesystemMockSymlink) When(target string, link string) *FilesystemMockSymlinkExpectation {
	if mmSymlink.mock.funcSymlink != nil {
		mmSymlink.mock.t.Fatalf("FilesystemMock.Symlink mock is already set by Set")
	}

	expectation := &FilesystemMockSymlinkExpectation{
		mock:   mmSymlink.mock,
		params: &FilesystemMockSymlinkParams{target, link},
	}
	mmSymlink.expectations = append(mmSymlink.expectations, expectation)
	return expectation
}

// Then sets up Filesystem.Symlink return parameters for the expectation previously defined by the When method
func (e *FilesystemMockSymlinkExpectation) Then(err error) *FilesystemMock {
	e.results = &FilesystemMockSymlinkResults{err}
	return e.mock
}

// Symlink implements billy.Filesystem
func (mmSymlink *FilesystemMock) Symlink(target string, link string) (err error) {
	mm_atomic.AddUint64(&mmSymlink.beforeSymlinkCounter, 1)
	defer mm_atomic.AddUint64(&mmSymlink.afterSymlinkCounter, 1)

	if mmSymlink.inspectFuncSymlink != nil {
		mmSymlink.inspectFuncSymlink(target, link)
	}

	mm_params := &FilesystemMockSymlinkParams{target, link}

	// Record call args
	mmSymlink.SymlinkMock.mutex.Lock()
	mmSymlink.SymlinkMock.callArgs = append(mmSymlink.SymlinkMock.callArgs, mm_params)
	mmSymlink.SymlinkMock.mutex.Unlock()

	for _, e := range mmSymlink.SymlinkMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSymlink.SymlinkMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSymlink.SymlinkMock.defaultExpectation.Counter, 1)
		mm_want := mmSymlink.SymlinkMock.defaultExpectation.params
		mm_got := FilesystemMockSymlinkParams{target, link}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSymlink.t.Errorf("FilesystemMock.Symlink got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSymlink.SymlinkMock.defaultExpectation.results
		if mm_results == nil {
			mmSymlink.t.Fatal("No results are set for the FilesystemMock.Symlink")
		}
		return (*mm_results).err
	}
	if mmSymlink.funcSymlink != nil {
		return mmSymlink.funcSymlink(target, link)
	}
	mmSymlink.t.Fatalf("Unexpected call to FilesystemMock.Symlink. %v %v", target, link)
	return
}

// SymlinkAfterCounter returns a count of finished FilesystemMock.Symlink invocations
func (mmSymlink *FilesystemMock) SymlinkAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSymlink.afterSymlinkCounter)
}

// SymlinkBeforeCounter returns a count of FilesystemMock.Symlink invocations
func (mmSymlink *FilesystemMock) SymlinkBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSymlink.beforeSymlinkCounter)
}

// Calls returns a list of arguments used in each call to FilesystemMock.Symlink.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSymlink *mFilesystemMockSymlink) Calls() []*FilesystemMockSymlinkParams {
	mmSymlink.mutex.RLock()

	argCopy := make([]*FilesystemMockSymlinkParams, len(mmSymlink.callArgs))
	copy(argCopy, mmSymlink.callArgs)

	mmSymlink.mutex.RUnlock()

	return argCopy
}

// MinimockSymlinkDone returns true if the count of the Symlink invocations corresponds
// the number of defined expectations
func (m *FilesystemMock) MinimockSymlinkDone() bool {
	for _, e := range m.SymlinkMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SymlinkMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSymlinkCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSymlink != nil && mm_atomic.LoadUint64(&m.afterSymlinkCounter) < 1 {
		return false
	}
	return true
}

// MinimockSymlinkInspect logs each unmet expectation
func (m *FilesystemMock) MinimockSymlinkInspect() {
	for _, e := range m.SymlinkMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FilesystemMock.Symlink with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SymlinkMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSymlinkCounter) < 1 {
		if m.SymlinkMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FilesystemMock.Symlink")
		} else {
			m.t.Errorf("Expected call to FilesystemMock.Symlink with params: %#v", *m.SymlinkMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSymlink != nil && mm_atomic.LoadUint64(&m.afterSymlinkCounter) < 1 {
		m.t.Error("Expected call to FilesystemMock.Symlink")
	}
}

type mFilesystemMockTempFile struct {
	mock               *FilesystemMock
	defaultExpectation *FilesystemMockTempFileExpectation
	expectations       []*FilesystemMockTempFileExpectation

	callArgs []*FilesystemMockTempFileParams
	mutex    sync.RWMutex
}

// FilesystemMockTempFileExpectation specifies expectation struct of the Filesystem.TempFile
type FilesystemMockTempFileExpectation struct {
	mock    *FilesystemMock
	params  *FilesystemMockTempFileParams
	results *FilesystemMockTempFileResults
	Counter uint64
}

// FilesystemMockTempFileParams contains parameters of the Filesystem.TempFile
type FilesystemMockTempFileParams struct {
	dir    string
	prefix string
}

// FilesystemMockTempFileResults contains results of the Filesystem.TempFile
type FilesystemMockTempFileResults struct {
	f1  mm_billy.File
	err error
}

// Expect sets up expected params for Filesystem.TempFile
func (mmTempFile *mFilesystemMockTempFile) Expect(dir string, prefix string) *mFilesystemMockTempFile {
	if mmTempFile.mock.funcTempFile != nil {
		mmTempFile.mock.t.Fatalf("FilesystemMock.TempFile mock is already set by Set")
	}

	if mmTempFile.defaultExpectation == nil {
		mmTempFile.defaultExpectation = &FilesystemMockTempFileExpectation{}
	}

	mmTempFile.defaultExpectation.params = &FilesystemMockTempFileParams{dir, prefix}
	for _, e := range mmTempFile.expectations {
		if minimock.Equal(e.params, mmTempFile.defaultExpectation.params) {
			mmTempFile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmTempFile.defaultExpectation.params)
		}
	}

	return mmTempFile
}

// Inspect accepts an inspector function that has same arguments as the Filesystem.TempFile
func (mmTempFile *mFilesystemMockTempFile) Inspect(f func(dir string, prefix string)) *mFilesystemMockTempFile {
	if mmTempFile.mock.inspectFuncTempFile != nil {
		mmTempFile.mock.t.Fatalf("Inspect function is already set for FilesystemMock.TempFile")
	}

	mmTempFile.mock.inspectFuncTempFile = f

	return mmTempFile
}

// Return sets up results that will be returned by Filesystem.TempFile
func (mmTempFile *mFilesystemMockTempFile) Return(f1 mm_billy.File, err error) *FilesystemMock {
	if mmTempFile.mock.funcTempFile != nil {
		mmTempFile.mock.t.Fatalf("FilesystemMock.TempFile mock is already set by Set")
	}

	if mmTempFile.defaultExpectation == nil {
		mmTempFile.defaultExpectation = &FilesystemMockTempFileExpectation{mock: mmTempFile.mock}
	}
	mmTempFile.defaultExpectation.results = &FilesystemMockTempFileResults{f1, err}
	return mmTempFile.mock
}

// Set uses given function f to mock the Filesystem.TempFile method
func (mmTempFile *mFilesystemMockTempFile) Set(f func(dir string, prefix string) (f1 mm_billy.File, err error)) *FilesystemMock {
	if mmTempFile.defaultExpectation != nil {
		mmTempFile.mock.t.Fatalf("Default expectation is already set for the Filesystem.TempFile method")
	}

	if len(mmTempFile.expectations) > 0 {
		mmTempFile.mock.t.Fatalf("Some expectations are already set for the Filesystem.TempFile method")
	}

	mmTempFile.mock.funcTempFile = f
	return mmTempFile.mock
}

// When sets expectation for the Filesystem.TempFile which will trigger the result defined by the following
// Then helper
func (mmTempFile *mFilesystemMockTempFile) When(dir string, prefix string) *FilesystemMockTempFileExpectation {
	if mmTempFile.mock.funcTempFile != nil {
		mmTempFile.mock.t.Fatalf("FilesystemMock.TempFile mock is already set by Set")
	}

	expectation := &FilesystemMockTempFileExpectation{
		mock:   mmTempFile.mock,
		params: &FilesystemMockTempFileParams{dir, prefix},
	}
	mmTempFile.expectations = append(mmTempFile.expectations, expectation)
	return expectation
}

// Then sets up Filesystem.TempFile return parameters for the expectation previously defined by the When method
func (e *FilesystemMockTempFileExpectation) Then(f1 mm_billy.File, err error) *FilesystemMock {
	e.results = &FilesystemMockTempFileResults{f1, err}
	return e.mock
}

// TempFile implements billy.Filesystem
func (mmTempFile *FilesystemMock) TempFile(dir string, prefix string) (f1 mm_billy.File, err error) {
	mm_atomic.AddUint64(&mmTempFile.beforeTempFileCounter, 1)
	defer mm_atomic.AddUint64(&mmTempFile.afterTempFileCounter, 1)

	if mmTempFile.inspectFuncTempFile != nil {
		mmTempFile.inspectFuncTempFile(dir, prefix)
	}

	mm_params := &FilesystemMockTempFileParams{dir, prefix}

	// Record call args
	mmTempFile.TempFileMock.mutex.Lock()
	mmTempFile.TempFileMock.callArgs = append(mmTempFile.TempFileMock.callArgs, mm_params)
	mmTempFile.TempFileMock.mutex.Unlock()

	for _, e := range mmTempFile.TempFileMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.f1, e.results.err
		}
	}

	if mmTempFile.TempFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTempFile.TempFileMock.defaultExpectation.Counter, 1)
		mm_want := mmTempFile.TempFileMock.defaultExpectation.params
		mm_got := FilesystemMockTempFileParams{dir, prefix}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmTempFile.t.Errorf("FilesystemMock.TempFile got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmTempFile.TempFileMock.defaultExpectation.results
		if mm_results == nil {
			mmTempFile.t.Fatal("No results are set for the FilesystemMock.TempFile")
		}
		return (*mm_results).f1, (*mm_results).err
	}
	if mmTempFile.funcTempFile != nil {
		return mmTempFile.funcTempFile(dir, prefix)
	}
	mmTempFile.t.Fatalf("Unexpected call to FilesystemMock.TempFile. %v %v", dir, prefix)
	return
}

// TempFileAfterCounter returns a count of finished FilesystemMock.TempFile invocations
func (mmTempFile *FilesystemMock) TempFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTempFile.afterTempFileCounter)
}

// TempFileBeforeCounter returns a count of FilesystemMock.TempFile invocations
func (mmTempFile *FilesystemMock) TempFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTempFile.beforeTempFileCounter)
}

// Calls returns a list of arguments used in each call to FilesystemMock.TempFile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmTempFile *mFilesystemMockTempFile) Calls() []*FilesystemMockTempFileParams {
	mmTempFile.mutex.RLock()

	argCopy := make([]*FilesystemMockTempFileParams, len(mmTempFile.callArgs))
	copy(argCopy, mmTempFile.callArgs)

	mmTempFile.mutex.RUnlock()

	return argCopy
}

// MinimockTempFileDone returns true if the count of the TempFile invocations corresponds
// the number of defined expectations
func (m *FilesystemMock) MinimockTempFileDone() bool {
	for _, e := range m.TempFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TempFileMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTempFileCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTempFile != nil && mm_atomic.LoadUint64(&m.afterTempFileCounter) < 1 {
		return false
	}
	return true
}

// MinimockTempFileInspect logs each unmet expectation
func (m *FilesystemMock) MinimockTempFileInspect() {
	for _, e := range m.TempFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FilesystemMock.TempFile with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TempFileMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTempFileCounter) < 1 {
		if m.TempFileMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FilesystemMock.TempFile")
		} else {
			m.t.Errorf("Expected call to FilesystemMock.TempFile with params: %#v", *m.TempFileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTempFile != nil && mm_atomic.LoadUint64(&m.afterTempFileCounter) < 1 {
		m.t.Error("Expected call to FilesystemMock.TempFile")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *FilesystemMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockChrootInspect()

		m.MinimockCreateInspect()

		m.MinimockJoinInspect()

		m.MinimockLstatInspect()

		m.MinimockMkdirAllInspect()

		m.MinimockOpenInspect()

		m.MinimockOpenFileInspect()

		m.MinimockReadDirInspect()

		m.MinimockReadlinkInspect()

		m.MinimockRemoveInspect()

		m.MinimockRenameInspect()

		m.MinimockRootInspect()

		m.MinimockStatInspect()

		m.MinimockSymlinkInspect()

		m.MinimockTempFileInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *FilesystemMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *FilesystemMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockChrootDone() &&
		m.MinimockCreateDone() &&
		m.MinimockJoinDone() &&
		m.MinimockLstatDone() &&
		m.MinimockMkdirAllDone() &&
		m.MinimockOpenDone() &&
		m.MinimockOpenFileDone() &&
		m.MinimockReadDirDone() &&
		m.MinimockReadlinkDone() &&
		m.MinimockRemoveDone() &&
		m.MinimockRenameDone() &&
		m.MinimockRootDone() &&
		m.MinimockStatDone() &&
		m.MinimockSymlinkDone() &&
		m.MinimockTempFileDone()
}
